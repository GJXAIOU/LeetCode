{"compress":true,"commitItems":[["7ee2335a-b963-431b-b957-26fc45447a7c",1560080103945,"",[[1560080052102,["GJX@GJXAIOU",[[1,0,"# 刷题经验\n\n\n\n"]],[0,0],[9,9]]],[1560080052265,["GJX@GJXAIOU",[[1,10,"\n"]],[9,9],[10,10]]],[1560080107350,["GJX@GJXAIOU",[[1,9,"作者：帅地\n链接：https://www.zhihu.com/question/321738058/answer/680613200\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n**从大一开始刷题到现在，自己也走过很多坑，作为一个刷题几年的老手，今天我来分享我这几年所积累的经验，相信会对你有所帮助，请耐心看完。**\n\n## **多刷题，且误盲目刷题**\n\n说实话，要说捷径，我觉得就是脚踏实地着多动手去刷题，多刷题。\n\n但是，如果你是小白，也就是说，你连常见的数据结构，如链表、树以及常见的算法思想，如递归、枚举、动态规划这些都没学过，那么，我不建议你**盲目疯狂着去刷题**的。而是先去找本书先去学习这些必要的知识，然后再去刷题。 因为，如果这些基础都不懂的话，估计一道题做了几个小时，然后看答案都不不懂，做题没有任何思路，这是很难受的。\n\n也就是说，假如你要去诸如leetcode这些网站刷题，那么，你要先具备一定的基础，这些基础包括：\n\n1、常见数据结构：链表、树(如二叉树)。（是的，链表和二叉树是重点，图这些可以先放着）\n\n2、常见算法思想：贪婪法、分治法、穷举法、动态规划，回溯法。（贪婪、穷举、分治是基础，动态规划有难度，可以先放着）\n\n以上列出来的算是最基本的吧。就是说你刷题之前，要把这些过一遍再去刷题。如果你连这些最基本的都不知道的话，那么你再刷题的过程中，会很难受的，思路也会相对比较少。\n\n总之，千万不要急，先把这些基本的过一遍，力求理解，再去刷题。这些基础的数据结构与算法，我是在大一第二学期学的，我没看视频，我是通过看书学的，那时候看的书是：\n\n1、算法分析与分析基础：这本比较简单，推荐新手看。\n\n2、数据结构与算法分析---C语言描述：代码用C写的，推荐看。\n\n3、挑战程序设计竞赛(第二版)：也是很不错的一本书，推荐看。\n\n4、编程之美：这本书真心不错，当时看的津津有味。\n\n5、编程珠玑：这本书也是学习算法必备\n\n说实话，我那一学期的时间几乎都花在数据结构与算法上，但刷的题很少，只是书本上的一些例题。所以当我把这些基本的过一遍之后，再去一些网站刷题依旧非常菜。\n\n所以你们千万别指望以为自己把这些思想学完之后刷题会很牛，只有多刷题，只有多动手实践，你的灵敏度才会提高起来。\n\n在这里说一下前阵子有个非常火爆的专栏---【数据结构与算法之美】\n\n我没买这个专栏，我想说的是，买了就一定要去看，千万别浪费。也千万不要觉得学完这个专栏你就会变的多牛逼，如果你只是跟着进度去学习这个专栏，自己没有花时间去刷题、去动手时间。那我可以保证，你学完之后还是那么菜。\n\n**总结下：**\n\n提高数据结构与算法没啥捷径，最好的捷径就是多刷题。但是，刷题的前提是你要先学会一些基本的数据结构与算法思想。\n\n### 挑战自己，跳出舒适区\n\n什么叫舒适区？在刷题的时候，可能有一类题是你比较懂的，你每次一看就有思路，然后半个小时就撸好代码，提交代码，然后通过了，然后，哇，又多刷了一道题，心里很舒服。\n\n但是，记住，前期你可以多刷这种题练手，提升自己的乐趣，但，我还是建议你慢慢跳出舒适区，去做一些自己不擅长的题，并且找段时间一直刷这种题。例如，我觉得我在递归方面的题还是挺强的， 但是，我对动态规划的题，很菜，每次都要想好久，每次遇到这种题都有点害怕，没什么信心。不过有段时间我觉得只刷动态规划的题，直接在 leetcode 选定专题，连续做了七八十道，刚开始很难受， 后来就慢慢知道了套路了，一道题从两三个小时最后缩到半小时，简单的十几分钟就搞定。感觉自己对这类型的题也不惧怕的。\n\n所以，建议你，一定要学好跳出自己的舒适区。\n\n### AC不是最终目的，而是要追求完美\n\n如何刷题？如何对待一道算法题？\n\n我觉得，在做题的时候，一定要**追求完美**，千万不要把一道题做出来之后，提交通过，然后就赶紧下一道。\n\n算法能力的提升和做题的数量是有一定的关系，但并不是线性关系。也就是说，在做题的时候，要力求一题多解，如果自己实在想不出来其他办法了，可以去看看别人是怎么做的，千万不要觉得模仿别人的做法是件丢人的事。\n\n我做题的时候，我一看到一道题，可能第一想法就是用很粗糙的方式做，因为很多题采用**暴力法**都会很容易做，就是时间复杂度很高。之后，我就会慢慢思考，看看有没其他方法来降低时间复杂度或空间复杂度。最后，我会去看一下别人的做法，当然，并不是每道题都会这样执行。\n\n衡量一道算法题的好坏无非就是**时间复杂度**和**空间复杂度**，所以我们要力求完美，就要把这两个降到最低，令他们相辅相成。\n\n我举道例题吧：\n\n**问题：** 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？\n\n这道题我在以前的分章分析过，不懂的可以先看下之前写的：[递归与动态规划---基础篇1](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2NzA4MTkxNQ%3D%3D%26mid%3D2247485287%26amp%3Bidx%3D1%26amp%3Bsn%3D334ca94218932fdb3bd60684f159a8bd%26source%3D41%23wechat_redirect)\n\n**方法1：**：暴力递归\n\n这道题不难，或许你会采取下面的做法：\n\n```text\npublic static int solve(int n){\n    if(n == 1 || n == 2){\n        return n;\n    }else if(n <= 0){\n        return 0;\n    }else{\n        return solve(n-1) + solve(n-2);\n    }\n}\n```\n\n这种做法的时间复杂度很高，指数级别了。但是如果你提交之后侥幸通过了，然后你就接着下一道题了，那么你就要好好想想了。\n\n**方法二**：空间换时间\n\n**力求完美**，我们可以考虑用空间换时间：这道题如何你去仔细想一想，会发现有很多是重复执行了。所以可以采取下面的方法：\n\n```text\n//用一个HashMap来保存已经计算过的状态\nstatic Map<Integer,Integer> map = new HashMap();\npublic static int solve(int n){\n    if(n <= 0)return 0;\n    else if(n <= 2){\n        return n;\n    }else{//是否计算过\n        if(map.containsKey(n)){\n            return map.get(n);\n        }else{\n            int m = solve(n-1) + solve(n-2);\n            map.put(n, m);\n            return m;\n        }\n    }\n}\n```\n\n这样，可以大大缩短时间。也就是说，当一道题你做了之后，发现时间复杂度很高，那么可以考虑下，是否有更好的方法，是否可以用空间换时间。\n\n**方法三**：斐波那契数列\n\n实际上，我们可以把空间复杂度弄的更小，不需要HashMap来保存状态：\n\n```text\npublic static int solve(int n){\n    if(n <= 0)\n       return 0;\n    if(n <= 2){\n        return n;\n    }\n\n    int f1 = 0;\n    int f2 = 1;\n    int sum = 0;\n    for(int i = 1; i<= n; i++){\n        sum = f1 + f2;\n        f1 = f2;\n        f2 = sum;\n    }\n    return sum;\n}\n```\n\n我弄这道题给你们看，并不是在教你们这道题怎么做，而是有以下目的：\n\n1、在刷题的时候，我们要力求完美。\n\n2、我想不到这些方法啊，怎么办？那么你就可以去看别人的做法，之后，遇到类似的题，你就会更有思路，更知道往哪个方向想。\n\n3、可以从简单暴力入手做一道题，在考虑空间与时间之间的衡量，一点点去优化。\n\n### 推荐一些刷题网站\n\n我一般是在leetcode和牛客网刷题，感觉挺不错，题目难度不是很大。\n\n在牛客网那里，我主要刷剑指Offer,不过那里也有个在线刷leetcode，不过里面的题量比较少。牛客网刷题有个非常方便的地方就是有个讨论区，那里会有很多大佬分享他们的解题方法，不用我们去百度找题解。所以你做完后，实在想不出，可以很方便着去看别人是怎么做的。\n\n至于leetcode，也是大部分题目官方都有给出答案，也是个不错的刷题网站。你们可以两个挑选一个，或者两个都刷。\n\n当然，还有其他刷题的网站，不过，其他网站没刷过，不大清除如何。\n\n至于leetcode，有中文版和英文版，个人建议英文版，英文版里面有各种大佬的解法分析。"]],[9,9],[3874,3874]]],[1560080113602,["GJX@GJXAIOU",[[-1,9,"作者：帅地\n链接：https://www.zhihu.com/question/321738058/answer/680613200\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[116,116],[9,9]]],[1560080154363,["GJX@GJXAIOU",[[1,449,"**"],[1,528,"**"]],[449,528],[449,532]]],[1560080487425,["GJX@GJXAIOU",[[1,3773,"\n"]],[3771,3771],[3772,3772]]],[1560080487548,["GJX@GJXAIOU",[[1,3774,"\n"]],[3772,3772],[3773,3773]]],[1560080487974,["GJX@GJXAIOU",[[1,3773,"[https://zhuanlan.zhihu.com/p/59389994](https://zhuanlan.zhihu.com/p/59389994)"]],[3773,3773],[3851,3851]]],[1560080491469,["GJX@GJXAIOU",[[-1,3773,"[https://zhuanlan.zhihu.com/p/59389994](https://zhuanlan.zhihu.com/p/59389994)"]],[3773,3851],[3773,3773]]],[1560080495786,["GJX@GJXAIOU",[[1,3773,"作者：帅地\n链接：https://www.zhihu.com/question/321738058/answer/680613200\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 再谈数据结构的重要性\n\n前面我主要是说了我平时都是怎么学习算法的。在数据结构方法，我只是列举了你们一定要学习**链表**和**树(二叉堆)**，但这是最基本的，刷题之前要掌握的，对于数据结构，我列举下一些比较重要的：\n\n1、链表（如单向链表、双向链表）。\n\n2、树（如二叉树、平衡树、红黑树）。\n\n3、图（如最短路径的几种算法）。\n\n4、队列、栈、矩阵。\n\n对于这些，自己一定要动手实现一遍。你可以看书，也可以看视频，新手可以先看视频，不过前期可以看视频，之后我建议是一定要看书。\n\n例如对于平衡树，可能你跟着书本的代码实现之后，过阵子你就忘记，不过这不要紧，虽然你忘记了，但是如果你之前用代码实现过，理解过，那么当你再次看到的时候，会很快就记起来，很快就知道思路,而且你的抽象能力等等会在不知不觉中提升起来。之后再学习红黑树啊，什么数据结构啊，都会学的很快。\n\n### --------------------6月6号更新-----------------\n\n### 学习一些解题技巧\n\n说实话，有些题在你没看别人的解法前，你好不知道有这么美妙优雅的解法，看了之后，卧槽，居然还可以这样。而我们在刷题的过程中，就要不断累积这些技巧，当你累计多了，你就会形成一种 神经反应，一下子就想到了某种方法。解题技巧很多，例如数组下标法、位图法、双指针等等，我自己也分享过一篇总结一些算法技巧的文章。给你举个例子吧，有时候有些技巧真让你大喊“卧槽”。\n\n### 1、找出没有重复的数\n\n> 给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。\n\n这道题可能很多人会用一个哈希表来存储，每次存储的时候，记录 某个数出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。这种方法的时间复杂度为 O(n)，空间复杂度也为 O(n)了。\n\n然而我想告诉你的是，采用位运算来做，绝对高逼格！\n\n我们刚才说过，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型全部异或一下，例如这组数据是：1， 2， 3， 4， 5， 1， 2， 3， 4。其中 5 只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下：\n\n由于异或支持交换律和结合律，所以:\n\n1^2^3^4^5^1^2^3^4 = （1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。\n\n也就是说，那些出现了两次的数异或之后会变成0，那个出现一次的数，和 0 异或之后就等于它本身。就问这个解法牛不牛逼？所以代码如下\n\n```text\nint find(int[] arr){\n    int tmp = arr[0];\n    for(int i = 1;i < arr.length; i++){\n        tmp = tmp ^ arr[i];\n    }\n    return tmp;\n}\n```\n\n时间复杂度为 O(n)，空间复杂度为 O(1)，而且看起来很牛逼。\n\n### 2、m的n次方\n\n如果让你求解 2 的 n 次方，并且不能使用系统自带的 pow 函数，你会怎么做呢？这还不简单，连续让 n 个 m 相乘就行了，代码如下：\n\n```text\nint pow(int n){\n    int tmp = 1;\n    for(int i = 1; i <= n; i++) {\n        tmp = tmp * m;\n    }\n    return tmp;\n}\n```\n\n不过你要是这样做的话，我只能呵呵，时间复杂度为 O(n) 了，怕是小学生都会！如果让你用位运算来做，你会怎么做呢？\n\n我举个例子吧，例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:\n\nm^1101 = m^0001 * m^0100 * m^1000。\n\n我们可以通过 & 1和 >>1 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解：\n\n```text\nint pow(int n){\n    int sum = 1;\n    int tmp = m;\n    while(n != 0){\n        if(n & 1 == 1){\n            sum *= tmp;\n        }\n        tmp *= tmp;\n        n = n >> 1;\n    }\n\n    return sum;\n}\n```\n\n时间复杂度近为 O(logn)，而且看起来很牛逼。\n\n给你算法技巧，当然也可以关注我的公众号：**苦逼的码农**，专注与分享算法、计算机基础等相关文章，已有100多篇原创，欢迎来撩。"]],[3773,3773],[5874,5874]]],[1560080498739,["GJX@GJXAIOU",[[-1,3773,"作者：帅地\n链接：https://www.zhihu.com/question/321738058/answer/680613200\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[3772,3880],[3772,3772]]],[1560080557888,["GJX@GJXAIOU",[[1,5768,"\n"]],[5766,5766],[5767,5767]]],[1560080558081,["GJX@GJXAIOU",[[1,5769,"\n"]],[5767,5767],[5768,5768]]],[1560080559938,["GJX@GJXAIOU",[[1,5768,"### 最最重要：执行力\n\n动手去做，动手去做，动手去做。重要的话说三遍。\n\n千万不要找了一堆资源，订好了学习计划，我要留到某某天就来去做.....\n\n千万不要这样，而是当你激情来的时候，就马上去干，千万不要留到某个放假日啊什么鬼了，很多这种想法的人，最后会啥也没做的。\n\n也不要觉得要学习的有好多啊，不知道从哪学习起。我上面说了，可以先学习最基本的，然后刷题，刷题是一个需要长期坚持的事情，一年，两年。在刷题的过程中，可以穿插和学习其他数据结构。\n\n大家也可以关注我的公众号：**苦逼的码农**，在我的公众号里，我也分享了很多与数据结构算法相同的文章，而且也分享了很多解题技巧。目前已分析了 100 多篇原创文章，下面是一些我觉得 很不错的文章，强烈建议阅读：\n\n作者：帅地\n链接：https://www.zhihu.com/question/321738058/answer/680613200\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[5768,5768],[6208,6208]]],[1560080568387,["GJX@GJXAIOU",[[-1,6101,"作者：帅地\n链接：https://www.zhihu.com/question/321738058/answer/680613200\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[6101,6208],[6101,6101]]],[1560080577535,["GJX@GJXAIOU",[[1,6101,"[link](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/j91IhcX0aE21G7NWYAVwrQ)"]],[6101,6101],[6191,6191]]],[1560080591045,["GJX@GJXAIOU",[[-1,6102,"link]("],[-1,6116,"link.zhihu"],[1,6126,"mp.weixin.qq"],[-1,6131,"?target="],[1,6139,"s/j91IhcX0aE21G7NWYAVwrQ]("],[-1,6144,"%3A"],[1,6147,":"]],[6101,6191],[6203,6203]]],[1560080871784,["GJX@GJXAIOU",[[1,6205,"\n"]],[6203,6203],[6204,6204]]],[1560080871930,["GJX@GJXAIOU",[[1,6206,"\n"]],[6204,6204],[6205,6205]]],[1560080872107,["GJX@GJXAIOU",[[1,6207,"\n"]],[6205,6205],[6206,6206]]],[1560080872305,["GJX@GJXAIOU",[[1,6208,"\n"]],[6206,6206],[6207,6207]]],[1560080872467,["GJX@GJXAIOU",[[1,6209,"\n"]],[6207,6207],[6208,6208]]],[1560080902942,["GJX@GJXAIOU",[[1,6210,"\n"]],[6206,6206],[6207,6207]]],[1560080903395,["GJX@GJXAIOU",[[1,6207,"## **一、先用伪代码写出逻辑，再补全小段代码**"]],[6207,6207],[6233,6233]]],[1560080918544,["GJX@GJXAIOU",[[1,6235,"## **一、先用伪代码写出逻辑，再补全小段代码**"]],[6235,6235],[6261,6261]]],[1560080921315,["GJX@GJXAIOU",[[-1,6235,"## **一、先用伪代码写出逻辑，再补全小段代码**"]],[6235,6261],[6235,6235]]],[1560080926972,["GJX@GJXAIOU",[[1,6236,"## **一、先用伪代码写出逻辑，再补全小段代码**"]],[6236,6236],[6262,6262]]],[1560080929535,["GJX@GJXAIOU",[[-1,6236,"## **一、先用伪代码写出逻辑，再补全小段代码**"]],[6236,6262],[6236,6236]]],[1560080945572,["GJX@GJXAIOU",[[1,6235,"## **一、先用伪代码写出逻辑，再补全小段代码**"]],[6235,6235],[6261,6261]]],[1560080947871,["GJX@GJXAIOU",[[-1,6235,"## **一、先用伪代码写出逻辑，再补全小段代码**\n"]],[6234,6261],[6234,6234]]],[1560080949907,["GJX@GJXAIOU",[[1,6236,"\n"]],[6234,6234],[6235,6235]]],[1560081172865,["GJX@GJXAIOU",[[1,6237,"\n"]],[6234,6234],[6235,6235]]],[1560081173000,["GJX@GJXAIOU",[[1,6238,"\n"]],[6235,6235],[6236,6236]]]],null,"GJX@GJXAIOU"],["d5d7c6ab-9851-481b-a948-8656170161a3",1560168039872,"# 刷题经验\n\n\n\n\n**从大一开始刷题到现在，自己也走过很多坑，作为一个刷题几年的老手，今天我来分享我这几年所积累的经验，相信会对你有所帮助，请耐心看完。**\n\n## **多刷题，且误盲目刷题**\n\n说实话，要说捷径，我觉得就是脚踏实地着多动手去刷题，多刷题。\n\n但是，如果你是小白，也就是说，你连常见的数据结构，如链表、树以及常见的算法思想，如递归、枚举、动态规划这些都没学过，那么，我不建议你**盲目疯狂着去刷题**的。而是先去找本书先去学习这些必要的知识，然后再去刷题。 因为，如果这些基础都不懂的话，估计一道题做了几个小时，然后看答案都不不懂，做题没有任何思路，这是很难受的。\n\n也就是说，假如你要去诸如leetcode这些网站刷题，那么，你要先具备一定的基础，这些基础包括：\n\n1、常见数据结构：链表、树(如二叉树)。（是的，链表和二叉树是重点，图这些可以先放着）\n\n2、常见算法思想：贪婪法、分治法、穷举法、动态规划，回溯法。（贪婪、穷举、分治是基础，动态规划有难度，可以先放着）\n\n**以上列出来的算是最基本的吧。就是说你刷题之前，要把这些过一遍再去刷题。如果你连这些最基本的都不知道的话，那么你再刷题的过程中，会很难受的，思路也会相对比较少。**\n\n总之，千万不要急，先把这些基本的过一遍，力求理解，再去刷题。这些基础的数据结构与算法，我是在大一第二学期学的，我没看视频，我是通过看书学的，那时候看的书是：\n\n1、算法分析与分析基础：这本比较简单，推荐新手看。\n\n2、数据结构与算法分析---C语言描述：代码用C写的，推荐看。\n\n3、挑战程序设计竞赛(第二版)：也是很不错的一本书，推荐看。\n\n4、编程之美：这本书真心不错，当时看的津津有味。\n\n5、编程珠玑：这本书也是学习算法必备\n\n说实话，我那一学期的时间几乎都花在数据结构与算法上，但刷的题很少，只是书本上的一些例题。所以当我把这些基本的过一遍之后，再去一些网站刷题依旧非常菜。\n\n所以你们千万别指望以为自己把这些思想学完之后刷题会很牛，只有多刷题，只有多动手实践，你的灵敏度才会提高起来。\n\n在这里说一下前阵子有个非常火爆的专栏---【数据结构与算法之美】\n\n我没买这个专栏，我想说的是，买了就一定要去看，千万别浪费。也千万不要觉得学完这个专栏你就会变的多牛逼，如果你只是跟着进度去学习这个专栏，自己没有花时间去刷题、去动手时间。那我可以保证，你学完之后还是那么菜。\n\n**总结下：**\n\n提高数据结构与算法没啥捷径，最好的捷径就是多刷题。但是，刷题的前提是你要先学会一些基本的数据结构与算法思想。\n\n### 挑战自己，跳出舒适区\n\n什么叫舒适区？在刷题的时候，可能有一类题是你比较懂的，你每次一看就有思路，然后半个小时就撸好代码，提交代码，然后通过了，然后，哇，又多刷了一道题，心里很舒服。\n\n但是，记住，前期你可以多刷这种题练手，提升自己的乐趣，但，我还是建议你慢慢跳出舒适区，去做一些自己不擅长的题，并且找段时间一直刷这种题。例如，我觉得我在递归方面的题还是挺强的， 但是，我对动态规划的题，很菜，每次都要想好久，每次遇到这种题都有点害怕，没什么信心。不过有段时间我觉得只刷动态规划的题，直接在 leetcode 选定专题，连续做了七八十道，刚开始很难受， 后来就慢慢知道了套路了，一道题从两三个小时最后缩到半小时，简单的十几分钟就搞定。感觉自己对这类型的题也不惧怕的。\n\n所以，建议你，一定要学好跳出自己的舒适区。\n\n### AC不是最终目的，而是要追求完美\n\n如何刷题？如何对待一道算法题？\n\n我觉得，在做题的时候，一定要**追求完美**，千万不要把一道题做出来之后，提交通过，然后就赶紧下一道。\n\n算法能力的提升和做题的数量是有一定的关系，但并不是线性关系。也就是说，在做题的时候，要力求一题多解，如果自己实在想不出来其他办法了，可以去看看别人是怎么做的，千万不要觉得模仿别人的做法是件丢人的事。\n\n我做题的时候，我一看到一道题，可能第一想法就是用很粗糙的方式做，因为很多题采用**暴力法**都会很容易做，就是时间复杂度很高。之后，我就会慢慢思考，看看有没其他方法来降低时间复杂度或空间复杂度。最后，我会去看一下别人的做法，当然，并不是每道题都会这样执行。\n\n衡量一道算法题的好坏无非就是**时间复杂度**和**空间复杂度**，所以我们要力求完美，就要把这两个降到最低，令他们相辅相成。\n\n我举道例题吧：\n\n**问题：** 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？\n\n这道题我在以前的分章分析过，不懂的可以先看下之前写的：[递归与动态规划---基础篇1](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2NzA4MTkxNQ%3D%3D%26mid%3D2247485287%26amp%3Bidx%3D1%26amp%3Bsn%3D334ca94218932fdb3bd60684f159a8bd%26source%3D41%23wechat_redirect)\n\n**方法1：**：暴力递归\n\n这道题不难，或许你会采取下面的做法：\n\n```text\npublic static int solve(int n){\n    if(n == 1 || n == 2){\n        return n;\n    }else if(n <= 0){\n        return 0;\n    }else{\n        return solve(n-1) + solve(n-2);\n    }\n}\n```\n\n这种做法的时间复杂度很高，指数级别了。但是如果你提交之后侥幸通过了，然后你就接着下一道题了，那么你就要好好想想了。\n\n**方法二**：空间换时间\n\n**力求完美**，我们可以考虑用空间换时间：这道题如何你去仔细想一想，会发现有很多是重复执行了。所以可以采取下面的方法：\n\n```text\n//用一个HashMap来保存已经计算过的状态\nstatic Map<Integer,Integer> map = new HashMap();\npublic static int solve(int n){\n    if(n <= 0)return 0;\n    else if(n <= 2){\n        return n;\n    }else{//是否计算过\n        if(map.containsKey(n)){\n            return map.get(n);\n        }else{\n            int m = solve(n-1) + solve(n-2);\n            map.put(n, m);\n            return m;\n        }\n    }\n}\n```\n\n这样，可以大大缩短时间。也就是说，当一道题你做了之后，发现时间复杂度很高，那么可以考虑下，是否有更好的方法，是否可以用空间换时间。\n\n**方法三**：斐波那契数列\n\n实际上，我们可以把空间复杂度弄的更小，不需要HashMap来保存状态：\n\n```text\npublic static int solve(int n){\n    if(n <= 0)\n       return 0;\n    if(n <= 2){\n        return n;\n    }\n\n    int f1 = 0;\n    int f2 = 1;\n    int sum = 0;\n    for(int i = 1; i<= n; i++){\n        sum = f1 + f2;\n        f1 = f2;\n        f2 = sum;\n    }\n    return sum;\n}\n```\n\n我弄这道题给你们看，并不是在教你们这道题怎么做，而是有以下目的：\n\n1、在刷题的时候，我们要力求完美。\n\n2、我想不到这些方法啊，怎么办？那么你就可以去看别人的做法，之后，遇到类似的题，你就会更有思路，更知道往哪个方向想。\n\n3、可以从简单暴力入手做一道题，在考虑空间与时间之间的衡量，一点点去优化。\n\n### 推荐一些刷题网站\n\n我一般是在leetcode和牛客网刷题，感觉挺不错，题目难度不是很大。\n\n在牛客网那里，我主要刷剑指Offer,不过那里也有个在线刷leetcode，不过里面的题量比较少。牛客网刷题有个非常方便的地方就是有个讨论区，那里会有很多大佬分享他们的解题方法，不用我们去百度找题解。所以你做完后，实在想不出，可以很方便着去看别人是怎么做的。\n\n至于leetcode，也是大部分题目官方都有给出答案，也是个不错的刷题网站。你们可以两个挑选一个，或者两个都刷。\n\n当然，还有其他刷题的网站，不过，其他网站没刷过，不大清除如何。\n\n至于leetcode，有中文版和英文版，个人建议英文版，英文版里面有各种大佬的解法分析。\n\n\n### 再谈数据结构的重要性\n\n前面我主要是说了我平时都是怎么学习算法的。在数据结构方法，我只是列举了你们一定要学习**链表**和**树(二叉堆)**，但这是最基本的，刷题之前要掌握的，对于数据结构，我列举下一些比较重要的：\n\n1、链表（如单向链表、双向链表）。\n\n2、树（如二叉树、平衡树、红黑树）。\n\n3、图（如最短路径的几种算法）。\n\n4、队列、栈、矩阵。\n\n对于这些，自己一定要动手实现一遍。你可以看书，也可以看视频，新手可以先看视频，不过前期可以看视频，之后我建议是一定要看书。\n\n例如对于平衡树，可能你跟着书本的代码实现之后，过阵子你就忘记，不过这不要紧，虽然你忘记了，但是如果你之前用代码实现过，理解过，那么当你再次看到的时候，会很快就记起来，很快就知道思路,而且你的抽象能力等等会在不知不觉中提升起来。之后再学习红黑树啊，什么数据结构啊，都会学的很快。\n\n### --------------------6月6号更新-----------------\n\n### 学习一些解题技巧\n\n说实话，有些题在你没看别人的解法前，你好不知道有这么美妙优雅的解法，看了之后，卧槽，居然还可以这样。而我们在刷题的过程中，就要不断累积这些技巧，当你累计多了，你就会形成一种 神经反应，一下子就想到了某种方法。解题技巧很多，例如数组下标法、位图法、双指针等等，我自己也分享过一篇总结一些算法技巧的文章。给你举个例子吧，有时候有些技巧真让你大喊“卧槽”。\n\n### 1、找出没有重复的数\n\n> 给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。\n\n这道题可能很多人会用一个哈希表来存储，每次存储的时候，记录 某个数出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。这种方法的时间复杂度为 O(n)，空间复杂度也为 O(n)了。\n\n然而我想告诉你的是，采用位运算来做，绝对高逼格！\n\n我们刚才说过，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型全部异或一下，例如这组数据是：1， 2， 3， 4， 5， 1， 2， 3， 4。其中 5 只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下：\n\n由于异或支持交换律和结合律，所以:\n\n1^2^3^4^5^1^2^3^4 = （1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。\n\n也就是说，那些出现了两次的数异或之后会变成0，那个出现一次的数，和 0 异或之后就等于它本身。就问这个解法牛不牛逼？所以代码如下\n\n```text\nint find(int[] arr){\n    int tmp = arr[0];\n    for(int i = 1;i < arr.length; i++){\n        tmp = tmp ^ arr[i];\n    }\n    return tmp;\n}\n```\n\n时间复杂度为 O(n)，空间复杂度为 O(1)，而且看起来很牛逼。\n\n### 2、m的n次方\n\n如果让你求解 2 的 n 次方，并且不能使用系统自带的 pow 函数，你会怎么做呢？这还不简单，连续让 n 个 m 相乘就行了，代码如下：\n\n```text\nint pow(int n){\n    int tmp = 1;\n    for(int i = 1; i <= n; i++) {\n        tmp = tmp * m;\n    }\n    return tmp;\n}\n```\n\n不过你要是这样做的话，我只能呵呵，时间复杂度为 O(n) 了，怕是小学生都会！如果让你用位运算来做，你会怎么做呢？\n\n我举个例子吧，例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:\n\nm^1101 = m^0001 * m^0100 * m^1000。\n\n我们可以通过 & 1和 >>1 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解：\n\n```text\nint pow(int n){\n    int sum = 1;\n    int tmp = m;\n    while(n != 0){\n        if(n & 1 == 1){\n            sum *= tmp;\n        }\n        tmp *= tmp;\n        n = n >> 1;\n    }\n\n    return sum;\n}\n```\n\n时间复杂度近为 O(logn)，而且看起来很牛逼。\n\n给你算法技巧，当然也可以关注我的公众号：**苦逼的码农**，专注与分享算法、计算机基础等相关文章，已有100多篇原创，欢迎来撩。\n\n### 最最重要：执行力\n\n动手去做，动手去做，动手去做。重要的话说三遍。\n\n千万不要找了一堆资源，订好了学习计划，我要留到某某天就来去做.....\n\n千万不要这样，而是当你激情来的时候，就马上去干，千万不要留到某个放假日啊什么鬼了，很多这种想法的人，最后会啥也没做的。\n\n也不要觉得要学习的有好多啊，不知道从哪学习起。我上面说了，可以先学习最基本的，然后刷题，刷题是一个需要长期坚持的事情，一年，两年。在刷题的过程中，可以穿插和学习其他数据结构。\n\n大家也可以关注我的公众号：**苦逼的码农**，在我的公众号里，我也分享了很多与数据结构算法相同的文章，而且也分享了很多解题技巧。目前已分析了 100 多篇原创文章，下面是一些我觉得 很不错的文章，强烈建议阅读：\n\n[https://mp.weixin.qq.com/s/j91IhcX0aE21G7NWYAVwrQ](https://mp.weixin.qq.com/s/j91IhcX0aE21G7NWYAVwrQ)\n\n\n\n## **一、先用伪代码写出逻辑，再补全小段代码**\n\n\n\n\n\n",[[1560167984303,["GJX@GJXAIOU",[[1,6207,"\n"]],[6205,6205],[6206,6206]]],[1560167984407,["GJX@GJXAIOU",[[1,6208,"\n"]],[6206,6206],[6207,6207]]],[1560167989752,["GJX@GJXAIOU",[[1,6207,"## 经验二："]],[6207,6207],[6214,6214]]],[1560167993360,["GJX@GJXAIOU",[[-1,6216,"## **一、先用伪代码写出逻辑，再补全小段代码**"]],[6216,6242],[6216,6216]]],[1560168020744,["GJX@GJXAIOU",[[1,6217,"@"]],[6217,6217],[6218,6218]]],[1560168021321,["GJX@GJXAIOU",[[-1,6217,"@"]],[6218,6218],[6217,6217]]],[1560168023464,["GJX@GJXAIOU",[[1,6217,"@"]],[6217,6217],[6218,6218]]],[1560168023972,["GJX@GJXAIOU",[[-1,6217,"@"]],[6218,6218],[6217,6217]]],[1560168037087,["GJX@GJXAIOU",[[1,6217,"- 先使用伪代码写出"]],[6217,6217],[6227,6227]]],[1560168064488,["GJX@GJXAIOU",[[1,6227,"程序的逻辑，在补全小段的代码- 针对不需要特定算法的题目"]],[6227,6227],[6255,6255]]],[1560168066652,["GJX@GJXAIOU",[[1,6256,"- \n"]],[6255,6255],[6258,6258]]],[1560168067008,["GJX@GJXAIOU",[[-1,6256,"- "]],[6258,6258],[6257,6257]]],[1560168067636,["GJX@GJXAIOU",[[-1,6260,"\n"]],[6257,6257],[6256,6256]]],[1560168068786,["GJX@GJXAIOU",[[-1,6259,"\n"]],[6256,6256],[6255,6255]]],[1560168069960,["GJX@GJXAIOU",[[-1,6253,"题目"]],[6255,6255],[6253,6253]]],[1560168071872,["GJX@GJXAIOU",[[1,6253,"题目；"]],[6253,6253],[6256,6256]]],[1560168072233,["GJX@GJXAIOU",[[1,6257,"- \n"]],[6256,6256],[6259,6259]]],[1560168096661,["GJX@GJXAIOU",[[1,6259,"判断题目的描述是否满足某个算法的"]],[6259,6259],[6275,6275]]],[1560168103072,["GJX@GJXAIOU",[[1,6275,"所需条件；"]],[6275,6275],[6280,6280]]],[1560168267190,["GJX@GJXAIOU",[[1,6281,"（）"]],[6281,6281],[6283,6283]]],[1560168276520,["GJX@GJXAIOU",[[1,6282,"主要面临的问题："]],[6282,6282],[6290,6290]]],[1560168326687,["GJX@GJXAIOU",[[1,6290,"读题太少，不知每一类算法的使用场景"]],[6290,6290],[6307,6307]]],[1560168475088,["GJX@GJXAIOU",[[1,6311,"\n"]],[6309,6309],[6310,6310]]],[1560168497771,["GJX@GJXAIOU",[[1,6310,"- 可以先按照Tag练习，通过Tag练习总结每类算法 的特点"]],[6310,6310],[6340,6340]]],[1560168500029,["GJX@GJXAIOU",[[-1,6336," "]],[6337,6337],[6336,6336]]],[1560168501681,["GJX@GJXAIOU",[[1,6339,"；"]],[6339,6339],[6340,6340]]],[1560168504550,["GJX@GJXAIOU",[[1,6341,"- \n"]],[6340,6340],[6343,6343]]],[1560168509814,["GJX@GJXAIOU",[[1,6341,"  "]],[6343,6343],[6345,6345]]],[1560168517698,["GJX@GJXAIOU",[[1,6345,"例如使用二分法的"]],[6345,6345],[6353,6353]]],[1560168526497,["GJX@GJXAIOU",[[1,6353,"基本认识：俺要"]],[6353,6353],[6360,6360]]],[1560168527254,["GJX@GJXAIOU",[[-1,6358,"俺要"]],[6360,6360],[6358,6358]]],[1560168540530,["GJX@GJXAIOU",[[1,6358,"答案要求有界且单调"]],[6358,6358],[6367,6367]]],[1560168541636,["GJX@GJXAIOU",[[1,6368,"  - \n"]],[6367,6367],[6372,6372]]],[1560168543645,["GJX@GJXAIOU",[[-1,6368,"  "]],[6372,6372],[6370,6370]]],[1560168578578,["GJX@GJXAIOU",[[1,6370,"如果一道题做两次仍然不会就放入收藏夹，同时"]],[6370,6370],[6391,6391]]],[1560168597986,["GJX@GJXAIOU",[[1,6391,"只有在自己不需要参考答案的情况"]],[6391,6391],[6406,6406]]],[1560168615370,["GJX@GJXAIOU",[[1,6404,"连续两次AC的"]],[6404,6404],[6411,6411]]],[1560168625335,["GJX@GJXAIOU",[[1,6413,"下才可以移除；"]],[6413,6413],[6420,6420]]],[1560168697823,["GJX@GJXAIOU",[[1,6421,"- \n"]],[6420,6420],[6423,6423]]],[1560168699970,["GJX@GJXAIOU",[[1,6423,"媒体"]],[6423,6423],[6425,6425]]],[1560168701669,["GJX@GJXAIOU",[[-1,6423,"媒体"]],[6425,6425],[6423,6423]]],[1560168709185,["GJX@GJXAIOU",[[1,6423,"每次阶梯"]],[6423,6423],[6427,6427]]],[1560168709964,["GJX@GJXAIOU",[[-1,6425,"阶梯"]],[6427,6427],[6425,6425]]],[1560168719600,["GJX@GJXAIOU",[[1,6425,"结题的时间要有所限制；"]],[6425,6425],[6436,6436]]],[1560168719948,["GJX@GJXAIOU",[[1,6437,"- \n"]],[6436,6436],[6439,6439]]],[1560168725439,["GJX@GJXAIOU",[[1,6439,"结题"]],[6439,6439],[6441,6441]]],[1560168726140,["GJX@GJXAIOU",[[-1,6439,"结题"]],[6441,6441],[6439,6439]]],[1560168756880,["GJX@GJXAIOU",[[1,6439,"解题不以AC为目标，要注重时间复杂度和"]],[6439,6439],[6458,6458]]],[1560168761856,["GJX@GJXAIOU",[[1,6458,"空间复杂度；"]],[6458,6458],[6464,6464]]],[1560168864621,["GJX@GJXAIOU",[[1,6216,"- 必须有基本的数据结构知识：链表、二叉树等等以及基本的算法 "]],[6216,6216],[6247,6247]]],[1560168865139,["GJX@GJXAIOU",[[-1,6246," "]],[6247,6247],[6246,6246]]],[1560168869263,["GJX@GJXAIOU",[[1,6246,"思想；"]],[6246,6246],[6249,6249]]],[1560168889383,["GJX@GJXAIOU",[[1,6231,"栈、队列、"]],[6231,6231],[6236,6236]]],[1560168897691,["GJX@GJXAIOU",[[1,6503,"- \n"]],[6502,6502],[6505,6505]]],[1560168902038,["GJX@GJXAIOU",[[1,6505,"按照tagjinx"]],[6505,6505],[6514,6514]]],[1560168902740,["GJX@GJXAIOU",[[-1,6510,"jinx"]],[6514,6514],[6510,6510]]],[1560168903529,["GJX@GJXAIOU",[[1,6510,"Jinx"]],[6510,6510],[6514,6514]]],[1560168904371,["GJX@GJXAIOU",[[-1,6509,"gJinx"]],[6514,6514],[6509,6509]]],[1560168909546,["GJX@GJXAIOU",[[1,6509,"进行刷题的时候"]],[6509,6509],[6516,6516]]],[1560168946905,["GJX@GJXAIOU",[[1,6509,"g"]],[6509,6509],[6510,6510]]],[1560168971895,["GJX@GJXAIOU",[[1,6517,"，像数组、字符串、数"]],[6517,6517],[6527,6527]]],[1560168972299,["GJX@GJXAIOU",[[-1,6526,"数"]],[6527,6527],[6526,6526]]],[1560168997341,["GJX@GJXAIOU",[[1,6526,"树、链表、数学这些问题可以先刷，其他尽量"]],[6526,6526],[6546,6546]]],[1560169004576,["GJX@GJXAIOU",[[1,6546,"不按照tag刷，"]],[6546,6546],[6554,6554]]],[1560169005530,["GJX@GJXAIOU",[[-1,6553,"，"]],[6554,6554],[6553,6553]]],[1560169015174,["GJX@GJXAIOU",[[1,6553,"，防止形成思维定式；"]],[6553,6553],[6563,6563]]],[1560172138910,["GJX@GJXAIOU",[[-1,11,"**从大一开始刷题到现在，自己也走过很多坑，作为一个刷题几年的老手，今天我来分享我这几年所积累的经验，相信会对你有所帮助，请耐心看完。**\n\n"]],[9,80],[9,9]]],[1560172150777,["GJX@GJXAIOU",[[1,142,"**"],[1,167,"**"]],[142,167],[142,171]]],[1560172162769,["GJX@GJXAIOU",[[1,79,"**"],[1,113,"**"]],[79,113],[79,117]]],[1560172168014,["GJX@GJXAIOU",[[-1,176," 因为，如果这些基础都不懂的话，估计一道题做了几个小时，然后看答案都不不懂，做题没有任何思路，这是很难受的。"]],[176,230],[176,176]]],[1560172175286,["GJX@GJXAIOU",[[1,221,"**"],[1,226,"**"]],[221,226],[221,230]]],[1560172180718,["GJX@GJXAIOU",[[-1,336,"**以上列出来的算是最基本的吧。就是说你刷题之前，要把这些过一遍再去刷题。如果你连这些最基本的都不知道的话，那么你再刷题的过程中，会很难受的，思路也会相对比较少。**"]],[336,419],[336,336]]],[1560172181609,["GJX@GJXAIOU",[[-1,337,"\n"]],[336,336],[335,335]]],[1560172862743,["GJX@GJXAIOU",[[-1,337,"总之，千万不要急，先把这些基本的过一遍，力求理解，再去刷题。这些基础的数据结构与算法，我是在大一第二学期学的，我没看视频，我是通过看书学的，那时候看的书是：\n\n1、算法分析与分析基础：这本比较简单，推荐新手看。\n\n2、数据结构与算法分析---C语言描述：代码用C写的，推荐看。\n\n3、挑战程序设计竞赛(第二版)：也是很不错的一本书，推荐看。\n\n4、编程之美：这本书真心不错，当时看的津津有味。\n\n5、编程珠玑：这本书也是学习算法必备\n\n说实话，我那一学期的时间几乎都花在数据结构与算法上，但刷的题很少，只是书本上的一些例题。所以当我把这些基本的过一遍之后，再去一些网站刷题依旧非常菜。\n\n所以你们千万别指望以为自己把这些思想学完之后刷题会很牛，只有多刷题，只有多动手实践，你的灵敏度才会提高起来。\n\n在这里说一下前阵子有个非常火爆的专栏---【数据结构与算法之美】\n\n我没买这个专栏，我想说的是，买了就一定要去看，千万别浪费。也千万不要觉得学完这个专栏你就会变的多牛逼，如果你只是跟着进度去学习这个专栏，自己没有花时间去刷题、去动手时间。那我可以保证，你学完之后还是那么菜。"]],[337,824],[337,337]]],[1560172886451,["GJX@GJXAIOU",[[-1,570,"例如，我觉得我在递归方面的题还是挺强的， 但是，我对动态规划的题，很菜，每次都要想好久，每次遇到这种题都有点害怕，没什么信心。不过有段时间我觉得只刷动态规划的题，直接在 leetcode 选定专题，连续做了七八十道，刚开始很难受， 后来就慢慢知道了套路了，一道题从两三个小时最后缩到半小时，简单的十几分钟就搞定。感觉自己对这类型的题也不惧怕的。"]],[570,742],[570,570]]],[1560172920563,["GJX@GJXAIOU",[[-1,983,"我举道例题吧：\n\n**问题：** 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？\n\n这道题我在以前的分章分析过，不懂的可以先看下之前写的：[递归与动态规划---基础篇1](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2NzA4MTkxNQ%3D%3D%26mid%3D2247485287%26amp%3Bidx%3D1%26amp%3Bsn%3D334ca94218932fdb3bd60684f159a8bd%26source%3D41%23wechat_redirect)\n\n**方法1：**：暴力递归\n\n这道题不难，或许你会采取下面的做法：\n\n```text\npublic static int solve(int n){\n    if(n == 1 || n == 2){\n        return n;\n    }else if(n <= 0){\n        return 0;\n    }else{\n        return solve(n-1) + solve(n-2);\n    }\n}\n```\n\n这种做法的时间复杂度很高，指数级别了。但是如果你提交之后侥幸通过了，然后你就接着下一道题了，那么你就要好好想想了。\n\n**方法二**：空间换时间\n\n**力求完美**，我们可以考虑用空间换时间：这道题如何你去仔细想一想，会发现有很多是重复执行了。所以可以采取下面的方法：\n\n```text\n//用一个HashMap来保存已经计算过的状态\nstatic Map<Integer,Integer> map = new HashMap();\npublic static int solve(int n){\n    if(n <= 0)return 0;\n    else if(n <= 2){\n        return n;\n    }else{//是否计算过\n        if(map.containsKey(n)){\n            return map.get(n);\n        }else{\n            int m = solve(n-1) + solve(n-2);\n            map.put(n, m);\n            return m;\n        }\n    }\n}\n```\n\n这样，可以大大缩短时间。也就是说，当一道题你做了之后，发现时间复杂度很高，那么可以考虑下，是否有更好的方法，是否可以用空间换时间。\n\n**方法三**：斐波那契数列\n\n实际上，我们可以把空间复杂度弄的更小，不需要HashMap来保存状态：\n\n```text\npublic static int solve(int n){\n    if(n <= 0)\n       return 0;\n    if(n <= 2){\n        return n;\n    }\n\n    int f1 = 0;\n    int f2 = 1;\n    int sum = 0;\n    for(int i = 1; i<= n; i++){\n        sum = f1 + f2;\n        f1 = f2;\n        f2 = sum;\n    }\n    return sum;\n}\n```\n"]],[983,2445],[983,983]]],[1560172940231,["GJX@GJXAIOU",[[-1,1150,"我一般是在leetcode和牛客网刷题，感觉挺不错，题目难度不是很大。\n\n在牛客网那里，我主要刷剑指Offer,不过那里也有个在线刷leetcode，不过里面的题量比较少。牛客网刷题有个非常方便的地方就是有个讨论区，那里会有很多大佬分享他们的解题方法，不用我们去百度找题解。所以你做完后，实在想不出，可以很方便着去看别人是怎么做的。\n\n至于leetcode，也是大部分题目官方都有给出答案，也是个不错的刷题网站。你们可以两个挑选一个，或者两个都刷。\n\n当然，还有其他刷题的网站，不过，其他网站没刷过，不大清除如何。\n\n至于leetcode，有中文版和英文版，个人建议英文版，英文版里面有各种大佬的解法分析。"]],[1150,1453],[1150,1150]]],[1560172989062,["GJX@GJXAIOU",[[-1,3186,"千万不要找了一堆资源，订好了学习计划，我要留到某某天就来去做.....\n\n千万不要这样，而是当你激情来的时候，就马上去干，千万不要留到某个放假日啊什么鬼了，很多这种想法的人，最后会啥也没做的。\n\n也不要觉得要学习的有好多啊，不知道从哪学习起。我上面说了，可以先学习最基本的，然后刷题，刷题是一个需要长期坚持的事情，一年，两年。在刷题的过程中，可以穿插和学习其他数据结构。\n\n大家也可以关注我的公众号：**苦逼的码农**，在我的公众号里，我也分享了很多与数据结构算法相同的文章，而且也分享了很多解题技巧。目前已分析了 100 多篇原创文章，下面是一些我觉得 很不错的文章，强烈建议阅读：\n\n[https://mp.weixin.qq.com/s/j91IhcX0aE21G7NWYAVwrQ](https://mp.weixin.qq.com/s/j91IhcX0aE21G7NWYAVwrQ)"]],[3186,3582],[3186,3186]]],[1560172989651,["GJX@GJXAIOU",[[-1,3189,"\n"]],[3186,3186],[3185,3185]]],[1560172990347,["GJX@GJXAIOU",[[-1,3188,"\n"]],[3187,3187],[3186,3186]]],[1560172990699,["GJX@GJXAIOU",[[-1,3187,"\n"]],[3186,3186],[3185,3185]]]],null,"GJX@GJXAIOU"],["69de4240-b040-46ef-9681-7cd4f35e5fff",1566996545004,"# 刷题经验\n\n\n\n\n## **多刷题，且误盲目刷题**\n\n说实话，要说捷径，我觉得就是脚踏实地着多动手去刷题，多刷题。\n\n但是，如果你是小白，也就是说，你连**常见的数据结构，如链表、树以及常见的算法思想，如递归、枚举、动态规划**这些都没学过，那么，我不建议你**盲目疯狂着去刷题**的。**而是先去找本书先去学习这些必要的知识，然后再去刷题**。\n\n也就是说，假如你要去诸如leetcode这些网站刷题，那么，你要先具备一定的基础，这些**基础包括：**\n\n1、常见数据结构：链表、树(如二叉树)。（是的，链表和二叉树是重点，图这些可以先放着）\n\n2、常见算法思想：贪婪法、分治法、穷举法、动态规划，回溯法。（贪婪、穷举、分治是基础，动态规划有难度，可以先放着）\n\n\n\n\n**总结下：**\n\n提高数据结构与算法没啥捷径，最好的捷径就是多刷题。但是，刷题的前提是你要先学会一些基本的数据结构与算法思想。\n\n### 挑战自己，跳出舒适区\n\n什么叫舒适区？在刷题的时候，可能有一类题是你比较懂的，你每次一看就有思路，然后半个小时就撸好代码，提交代码，然后通过了，然后，哇，又多刷了一道题，心里很舒服。\n\n但是，记住，前期你可以多刷这种题练手，提升自己的乐趣，但，我还是建议你慢慢跳出舒适区，去做一些自己不擅长的题，并且找段时间一直刷这种题。\n\n所以，建议你，一定要学好跳出自己的舒适区。\n\n### AC不是最终目的，而是要追求完美\n\n如何刷题？如何对待一道算法题？\n\n我觉得，在做题的时候，一定要**追求完美**，千万不要把一道题做出来之后，提交通过，然后就赶紧下一道。\n\n算法能力的提升和做题的数量是有一定的关系，但并不是线性关系。也就是说，在做题的时候，要力求一题多解，如果自己实在想不出来其他办法了，可以去看看别人是怎么做的，千万不要觉得模仿别人的做法是件丢人的事。\n\n我做题的时候，我一看到一道题，可能第一想法就是用很粗糙的方式做，因为很多题采用**暴力法**都会很容易做，就是时间复杂度很高。之后，我就会慢慢思考，看看有没其他方法来降低时间复杂度或空间复杂度。最后，我会去看一下别人的做法，当然，并不是每道题都会这样执行。\n\n衡量一道算法题的好坏无非就是**时间复杂度**和**空间复杂度**，所以我们要力求完美，就要把这两个降到最低，令他们相辅相成。\n\n\n我弄这道题给你们看，并不是在教你们这道题怎么做，而是有以下目的：\n\n1、在刷题的时候，我们要力求完美。\n\n2、我想不到这些方法啊，怎么办？那么你就可以去看别人的做法，之后，遇到类似的题，你就会更有思路，更知道往哪个方向想。\n\n3、可以从简单暴力入手做一道题，在考虑空间与时间之间的衡量，一点点去优化。\n\n### 推荐一些刷题网站\n\n\n\n\n### 再谈数据结构的重要性\n\n前面我主要是说了我平时都是怎么学习算法的。在数据结构方法，我只是列举了你们一定要学习**链表**和**树(二叉堆)**，但这是最基本的，刷题之前要掌握的，对于数据结构，我列举下一些比较重要的：\n\n1、链表（如单向链表、双向链表）。\n\n2、树（如二叉树、平衡树、红黑树）。\n\n3、图（如最短路径的几种算法）。\n\n4、队列、栈、矩阵。\n\n对于这些，自己一定要动手实现一遍。你可以看书，也可以看视频，新手可以先看视频，不过前期可以看视频，之后我建议是一定要看书。\n\n例如对于平衡树，可能你跟着书本的代码实现之后，过阵子你就忘记，不过这不要紧，虽然你忘记了，但是如果你之前用代码实现过，理解过，那么当你再次看到的时候，会很快就记起来，很快就知道思路,而且你的抽象能力等等会在不知不觉中提升起来。之后再学习红黑树啊，什么数据结构啊，都会学的很快。\n\n### --------------------6月6号更新-----------------\n\n### 学习一些解题技巧\n\n说实话，有些题在你没看别人的解法前，你好不知道有这么美妙优雅的解法，看了之后，卧槽，居然还可以这样。而我们在刷题的过程中，就要不断累积这些技巧，当你累计多了，你就会形成一种 神经反应，一下子就想到了某种方法。解题技巧很多，例如数组下标法、位图法、双指针等等，我自己也分享过一篇总结一些算法技巧的文章。给你举个例子吧，有时候有些技巧真让你大喊“卧槽”。\n\n### 1、找出没有重复的数\n\n> 给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。\n\n这道题可能很多人会用一个哈希表来存储，每次存储的时候，记录 某个数出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。这种方法的时间复杂度为 O(n)，空间复杂度也为 O(n)了。\n\n然而我想告诉你的是，采用位运算来做，绝对高逼格！\n\n我们刚才说过，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型全部异或一下，例如这组数据是：1， 2， 3， 4， 5， 1， 2， 3， 4。其中 5 只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下：\n\n由于异或支持交换律和结合律，所以:\n\n1^2^3^4^5^1^2^3^4 = （1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。\n\n也就是说，那些出现了两次的数异或之后会变成0，那个出现一次的数，和 0 异或之后就等于它本身。就问这个解法牛不牛逼？所以代码如下\n\n```text\nint find(int[] arr){\n    int tmp = arr[0];\n    for(int i = 1;i < arr.length; i++){\n        tmp = tmp ^ arr[i];\n    }\n    return tmp;\n}\n```\n\n时间复杂度为 O(n)，空间复杂度为 O(1)，而且看起来很牛逼。\n\n### 2、m的n次方\n\n如果让你求解 2 的 n 次方，并且不能使用系统自带的 pow 函数，你会怎么做呢？这还不简单，连续让 n 个 m 相乘就行了，代码如下：\n\n```text\nint pow(int n){\n    int tmp = 1;\n    for(int i = 1; i <= n; i++) {\n        tmp = tmp * m;\n    }\n    return tmp;\n}\n```\n\n不过你要是这样做的话，我只能呵呵，时间复杂度为 O(n) 了，怕是小学生都会！如果让你用位运算来做，你会怎么做呢？\n\n我举个例子吧，例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:\n\nm^1101 = m^0001 * m^0100 * m^1000。\n\n我们可以通过 & 1和 >>1 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解：\n\n```text\nint pow(int n){\n    int sum = 1;\n    int tmp = m;\n    while(n != 0){\n        if(n & 1 == 1){\n            sum *= tmp;\n        }\n        tmp *= tmp;\n        n = n >> 1;\n    }\n\n    return sum;\n}\n```\n\n时间复杂度近为 O(logn)，而且看起来很牛逼。\n\n给你算法技巧，当然也可以关注我的公众号：**苦逼的码农**，专注与分享算法、计算机基础等相关文章，已有100多篇原创，欢迎来撩。\n\n### 最最重要：执行力\n\n动手去做，动手去做，动手去做。重要的话说三遍。\n\n\n## 经验二：\n\n- 必须有基本的数据结构知识：栈、队列、链表、二叉树等等以及基本的算法思想；\n- 先使用伪代码写出程序的逻辑，在补全小段的代码- 针对不需要特定算法的题目；\n- 判断题目的描述是否满足某个算法的所需条件；\n（主要面临的问题：读题太少，不知每一类算法的使用场景）\n\n- 可以先按照Tag练习，通过Tag练习总结每类算法的特点；\n  - 例如使用二分法的基本认识：答案要求有界且单调\n- 如果一道题做两次仍然不会就放入收藏夹，同时只有在自己不需要参考答案的连续两次AC的情况下才可以移除；\n- 每次结题的时间要有所限制；\n- 解题不以AC为目标，要注重时间复杂度和空间复杂度；\n- 按照tag进行刷题的时候，像数组、字符串、树、链表、数学这些问题可以先刷，其他尽量不按照tag刷，防止形成思维定式；\n\n",[[1566996544944,["GJX@GJXAIOU",[[1,0,"---\npin: true\n---\n"]],[0,0],[18,18]]]],null,"GJX@GJXAIOU"]]}