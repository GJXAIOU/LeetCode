{"compress":true,"commitItems":[["f99feeae-7083-4c33-9353-60512b619cf0",1562849432120,"",[[1562849374231,["GJX@GJXAIOU",[[1,0,"# 一个方法团灭 6 道股票问题\n\n\n\n"]],[0,0],[19,19]]],[1562849386815,["GJX@GJXAIOU",[[1,19,"很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。\n\n这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。\n\n先随便抽出一道题，看看别人的解法：\n\nint maxProfit(vector<int>& prices) {\n    if(prices.empty()) return 0;\n    int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;\n        \n    for(int i=1;i<prices.size();++i) {            \n        s1 = max(s1, -prices[i]);\n        s2 = max(s2, s1+prices[i]);\n        s3 = max(s3, s2-prices[i]);\n        s4 = max(s4, s3+prices[i]);\n    }\n    return max(0,s4);\n}\n能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。\n\n本文就来告诉你这个框架，然后带着你一道一道秒杀。\n\n这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。\n\n第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。\n\n一、穷举框架\n首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。\n\n递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。\n\n而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。\n\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 择优(选择1，选择2...)\n比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。\n\n很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：\n\ndp[i][k][0 or 1]\n0 <= i <= n-1, 1 <= k <= K\nn 为天数，大 K 为最多交易数\n此问题共 n × K × 2 种状态，全部穷举就能搞定。\n\nfor 0 <= i < n:\n    for 1 <= k <= K:\n        for s in {0, 1}:\n            dp[i][k][s] = max(buy, sell, rest)\n而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？\n\n我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。\n\n记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。\n\n二、状态转移框架\n现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。\n\n\n\n通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：\n\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\n              max(   选择 rest  ,           选择 sell      )\n\n解释：今天我没有持有股票，有两种可能：\n要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；\n要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。\n\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n              max(   选择 rest  ,           选择 buy         )\n\n解释：今天我持有着股票，有两种可能：\n要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；\n要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。\n这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。\n\n现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。\n\ndp[-1][k][0] = 0\n解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。\ndp[-1][k][1] = -infinity\n解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。\ndp[i][0][0] = 0\n解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。\ndp[i][0][1] = -infinity\n解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。\n把上面的状态转移方程总结一下：\n\nbase case：\ndp[-1][k][0] = dp[i][0][0] = 0\ndp[-1][k][1] = dp[i][0][1] = -infinity\n\n状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。\n\n三、秒杀题目\n第一题，k = 1\n\n直接套状态转移方程，根据 base case，可以做一些化简：\n\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\ndp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) \n            = max(dp[i-1][1][1], -prices[i])\n解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。\n\n现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。\n可以进行进一步化简去掉所有 k：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], -prices[i])\n直接写出代码：\n\nint n = prices.length;\nint[][] dp = new int[n][2];\nfor (int i = 0; i < n; i++) {\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);\n}\nreturn dp[n - 1][0];\n显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：\n\nfor (int i = 0; i < n; i++) {\n    if (i - 1 == -1) {\n        dp[i][0] = 0;\n        // 解释：\n        //   dp[i][0] \n        // = max(dp[-1][0], dp[-1][1] + prices[i])\n        // = max(0, -infinity + prices[i]) = 0\n        dp[i][1] = -prices[i];\n        //解释：\n        //   dp[i][1] \n        // = max(dp[-1][1], dp[-1][0] - prices[i])\n        // = max(-infinity, 0 - prices[i]) \n        // = -prices[i]\n        continue;\n    }\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);\n}\nreturn dp[n - 1][0];\n第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):\n\n// k == 1\nint maxProfit_k_1(int[] prices) {\n    int n = prices.length;\n    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        // dp[i][1] = max(dp[i-1][1], -prices[i])\n        dp_i_1 = Math.max(dp_i_1, -prices[i]);\n    }\n    return dp_i_0;\n}\n两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。\n\n第二题，k = +infinity\n\n如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：\n\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\n\n我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n直接翻译成代码：\n\nint maxProfit_k_inf(int[] prices) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);\n    }\n    return dp_i_0;\n}\n第三题，k = +infinity with cooldown\n\n每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：\n\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\n解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。\n翻译成代码：\n\nint maxProfit_with_cool(int[] prices) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    int dp_pre_0 = 0; // 代表 dp[i-2][0]\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);\n        dp_pre_0 = temp;\n    }\n    return dp_i_0;\n}\n第四题，k = +infinity with fee\n\n每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：\n\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)\n解释：相当于买入股票的价格升高了。\n在第一个式子里减也是一样的，相当于卖出股票的价格减小了。\n直接翻译成代码：\n\nint maxProfit_with_fee(int[] prices, int fee) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);\n    }\n    return dp_i_0;\n}\n第五题，k = 2\n\nk = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。\n\n这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。\n\n原始的动态转移方程，没有可化简的地方\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n按照之前的代码，我们可能想当然这样写代码（错误的）：\n\nint k = 2;\nint[][][] dp = new int[n][k + 1][2];\nfor (int i = 0; i < n; i++)\n    if (i - 1 == -1) { /* 处理一下 base case*/ }\n    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n}\nreturn dp[n - 1][k][0];\n为什么错误？我这不是照着状态转移方程写的吗？\n\n还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：\n\nint max_k = 2;\nint[][][] dp = new int[n][max_k + 1][2];\nfor (int i = 0; i < n; i++) {\n    for (int k = max_k; k >= 1; k--) {\n        if (i - 1 == -1) { /*处理 base case */ }\n        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n    }\n}\n// 穷举了 n × max_k × 2 个状态，正确。\nreturn dp[n - 1][max_k][0];\n如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。\n\n这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：\n\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\n\nint maxProfit_k_2(int[] prices) {\n    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;\n    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;\n    for (int price : prices) {\n        dp_i20 = Math.max(dp_i20, dp_i21 + price);\n        dp_i21 = Math.max(dp_i21, dp_i10 - price);\n        dp_i10 = Math.max(dp_i10, dp_i11 + price);\n        dp_i11 = Math.max(dp_i11, -price);\n    }\n    return dp_i20;\n}\n有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。\n\n第六题，k = any integer\n\n有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？\n\n一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。\n\n直接把之前的代码重用：\n\nint maxProfit_k_any(int max_k, int[] prices) {\n    int n = prices.length;\n    if (max_k > n / 2) \n        return maxProfit_k_inf(prices);\n\n    int[][][] dp = new int[n][max_k + 1][2];\n    for (int i = 0; i < n; i++) \n        for (int k = max_k; k >= 1; k--) {\n            if (i - 1 == -1) { /* 处理 base case */ }\n            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     \n        }\n    return dp[n - 1][max_k][0];\n}\n至此，6 道题目通过一个状态转移方程全部解决。\n\n四、最后总结\n本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。\n\n关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？\n\n具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。\n\n所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。\n\n买卖股票的最佳时机\n\n买卖股票的最佳时机 II\n\n买卖股票的最佳时机 III\n\n买卖股票的最佳时机 IV\n\n最佳买卖股票时机含冷冻期\n\n买卖股票的最佳时机含手续费\n\n推荐阅读：\n\n学习数据结构的框架思维\n\n动态规划详解\n\n如果本文对大家有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～\n\n作者：labuladong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[19,19],[10757,10757]]],[1562849401570,["GJX@GJXAIOU",[[1,197,"···"]],[197,197],[200,200]]],[1562849402695,["GJX@GJXAIOU",[[-1,197,"···"]],[200,200],[197,197]]],[1562849404003,["GJX@GJXAIOU",[[1,197,"```"]],[197,197],[200,200]]],[1562849404048,["GJX@GJXAIOU",[[1,200,"language\n```\n"]],[200,200],[200,208]]],[1562849405410,["GJX@GJXAIOU",[[-1,200,"language"],[1,208,"j"]],[200,208],[201,201]]],[1562849405922,["GJX@GJXAIOU",[[1,201,"ava"]],[201,201],[204,204]]],[1562849406079,["GJX@GJXAIOU",[[1,205,"\n"]],[204,204],[205,205]]],[1562849408976,["GJX@GJXAIOU",[[-1,206,"```\n"]],[205,209],[205,205]]],[1562849411266,["GJX@GJXAIOU",[[-1,206,"\n"]],[206,206],[205,205]]],[1562849411611,["GJX@GJXAIOU",[[-1,205,"\n"]],[205,205],[204,204]]],[1562849413497,["GJX@GJXAIOU",[[1,563,"\n"]],[562,562],[563,563]]],[1562849415640,["GJX@GJXAIOU",[[1,564,"```\n"]],[563,563],[567,567]]],[1562849417767,["GJX@GJXAIOU",[[-1,563,"\n"]],[563,563],[562,562]]],[1562849426327,["GJX@GJXAIOU",[[1,935,"## "]],[935,935],[944,944]]],[1562849437162,["GJX@GJXAIOU",[[1,1237,"```"]],[1237,1237],[1240,1240]]],[1562849437208,["GJX@GJXAIOU",[[1,1240,"language\n```\n"]],[1240,1240],[1240,1248]]],[1562849438643,["GJX@GJXAIOU",[[-1,1240,"language"],[1,1248,"j"]],[1240,1248],[1241,1241]]],[1562849439205,["GJX@GJXAIOU",[[1,1241,"ava"]],[1241,1241],[1244,1244]]],[1562849441503,["GJX@GJXAIOU",[[-1,1245,"```"]],[1245,1248],[1245,1245]]],[1562849443808,["GJX@GJXAIOU",[[1,1356,"            \n"]],[1355,1355],[1368,1368]]],[1562849447519,["GJX@GJXAIOU",[[-1,1356,"            "]],[1356,1368],[1356,1356]]],[1562849448578,["GJX@GJXAIOU",[[1,1356,"```"]],[1356,1356],[1359,1359]]],[1562849450552,["GJX@GJXAIOU",[[-1,1246,"\n"]],[1246,1246],[1245,1245]]],[1562849450847,["GJX@GJXAIOU",[[-1,1245,"\n"]],[1245,1245],[1244,1244]]],[1562849458944,["GJX@GJXAIOU",[[1,1366,"**"],[1,1376,"**"]],[1366,1376],[1366,1380]]],[1562849470579,["GJX@GJXAIOU",[[1,1756,"```"]],[1756,1756],[1759,1759]]],[1562849470627,["GJX@GJXAIOU",[[1,1759,"language\n```\n"]],[1759,1759],[1759,1767]]],[1562849472937,["GJX@GJXAIOU",[[-1,1768,"```"]],[1768,1771],[1768,1768]]],[1562849474080,["GJX@GJXAIOU",[[-1,1769,"\n"]],[1768,1768],[1767,1767]]],[1562849478578,["GJX@GJXAIOU",[[1,1969,"            \n"]],[1968,1968],[1981,1981]]],[1562849481431,["GJX@GJXAIOU",[[-1,1969,"            "]],[1981,1981],[1969,1969]]],[1562849482609,["GJX@GJXAIOU",[[1,1969,"```"]],[1969,1969],[1972,1972]]],[1562849488467,["GJX@GJXAIOU",[[1,2002,"`"]],[2002,2002],[2003,2003]]],[1562849491580,["GJX@GJXAIOU",[[1,2012,"`"]],[2012,2012],[2013,2013]]],[1562849492613,["GJX@GJXAIOU",[[1,2000,"`"]],[2000,2000],[2001,2001]]],[1562849494143,["GJX@GJXAIOU",[[-1,2003,"`"]],[2004,2004],[2003,2003]]],[1562849497172,["GJX@GJXAIOU",[[1,2055,"`"]],[2055,2055],[2056,2056]]],[1562849498330,["GJX@GJXAIOU",[[1,2067,"`"]],[2067,2067],[2068,2068]]],[1562849500969,["GJX@GJXAIOU",[[1,2127,"`"]],[2127,2127],[2128,2128]]],[1562849501978,["GJX@GJXAIOU",[[1,2143,"`"]],[2143,2143],[2144,2144]]],[1562849504243,["GJX@GJXAIOU",[[1,2197,"`"]],[2197,2197],[2198,2198]]],[1562849505499,["GJX@GJXAIOU",[[1,2182,"`"]],[2182,2182],[2183,2183]]],[1562849511202,["GJX@GJXAIOU",[[1,2295,"## "]],[2295,2295],[2306,2306]]],[1562849528597,["GJX@GJXAIOU",[[1,2375,"![状态转移]($resource/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png)"]],[2375,2375],[2435,2435]]],[1562849536754,["GJX@GJXAIOU",[[1,2490,"```"]],[2490,2490],[2493,2493]]],[1562849536803,["GJX@GJXAIOU",[[1,2493,"language\n```\n"]],[2493,2493],[2493,2501]]],[1562849539744,["GJX@GJXAIOU",[[-1,2502,"```"]],[2502,2505],[2502,2502]]],[1562849541048,["GJX@GJXAIOU",[[-1,2503,"\n"]],[2503,2503],[2502,2502]]],[1562849541431,["GJX@GJXAIOU",[[-1,2502,"\n"]],[2502,2502],[2501,2501]]],[1562849547079,["GJX@GJXAIOU",[[1,2929,"\n"]],[2928,2928],[2929,2929]]],[1562849547770,["GJX@GJXAIOU",[[1,2929,"```"]],[2929,2929],[2932,2932]]],[1562849571095,["GJX@GJXAIOU",[[1,3115,"**"],[1,3154,"**"]],[3115,3154],[3115,3158]]],[1562849577468,["GJX@GJXAIOU",[[1,3193,"```"]],[3193,3193],[3196,3196]]],[1562849577516,["GJX@GJXAIOU",[[1,3196,"language\n```\n"]],[3196,3196],[3196,3204]]],[1562849579759,["GJX@GJXAIOU",[[-1,3205,"```"]],[3205,3208],[3205,3205]]],[1562849581282,["GJX@GJXAIOU",[[-1,3206,"\n"]],[3206,3206],[3205,3205]]],[1562849581447,["GJX@GJXAIOU",[[-1,3205,"\n"]],[3205,3205],[3204,3204]]],[1562849587991,["GJX@GJXAIOU",[[1,3457,"\n"]],[3457,3457],[3458,3458]]],[1562849589375,["GJX@GJXAIOU",[[1,3457,"```"]],[3457,3457],[3460,3460]]],[1562849592571,["GJX@GJXAIOU",[[1,3764,"```"]],[3764,3764],[3767,3767]]],[1562849592615,["GJX@GJXAIOU",[[1,3767,"language\n```\n"]],[3767,3767],[3767,3775]]],[1562849594468,["GJX@GJXAIOU",[[1,3477,"```"]],[3477,3477],[3480,3480]]],[1562849597407,["GJX@GJXAIOU",[[-1,3767,"```language"]],[3767,3778],[3767,3767]]],[1562849598047,["GJX@GJXAIOU",[[-1,3767,"\n"]],[3767,3767],[3766,3766]]],[1562849604186,["GJX@GJXAIOU",[[1,3772,"## "]],[3772,3772],[3781,3781]]],[1562849609447,["GJX@GJXAIOU",[[1,3782,"## "]],[3782,3791],[3794,3794]]],[1562849611001,["GJX@GJXAIOU",[[1,3784,"#"]],[3794,3794],[3795,3795]]],[1562849624219,["GJX@GJXAIOU",[[1,10178,"\n"]],[10177,10177],[10178,10178]]],[1562849625222,["GJX@GJXAIOU",[[1,10178,"```"]],[10178,10178],[10181,10181]]],[1562849625269,["GJX@GJXAIOU",[[1,10181,"language\n```\n"]],[10181,10181],[10181,10189]]],[1562849627783,["GJX@GJXAIOU",[[-1,10178,"```language"]],[10178,10189],[10178,10178]]],[1562849635914,["GJX@GJXAIOU",[[1,3829,"```"]],[3829,3829],[3832,3832]]],[1562849644392,["GJX@GJXAIOU",[[1,4185,"\n"]],[4184,4184],[4185,4185]]],[1562849645041,["GJX@GJXAIOU",[[1,4185,"```"]],[4185,4185],[4188,4188]]],[1562849647034,["GJX@GJXAIOU",[[1,4197,"```"]],[4197,4197],[4200,4200]]],[1562849650632,["GJX@GJXAIOU",[[1,4415,"\n"]],[4414,4414],[4415,4415]]],[1562849651258,["GJX@GJXAIOU",[[1,4415,"```"]],[4415,4415],[4418,4418]]],[1562849657516,["GJX@GJXAIOU",[[1,4481,"```"]],[4481,4481],[4484,4484]]],[1562849662632,["GJX@GJXAIOU",[[1,5040,"\n"]],[5039,5039],[5040,5040]]],[1562849663208,["GJX@GJXAIOU",[[1,5040,"```"]],[5040,5040],[5043,5043]]],[1562849665227,["GJX@GJXAIOU",[[1,5154,"```"]],[5154,5154],[5157,5157]]],[1562849669736,["GJX@GJXAIOU",[[1,5607,"\n"]],[5606,5606],[5607,5607]]],[1562849670528,["GJX@GJXAIOU",[[1,5607,"```"]],[5607,5607],[5610,5610]]],[1562849672697,["GJX@GJXAIOU",[[1,5689,"### "]],[5689,5689],[5710,5710]]],[1562849676931,["GJX@GJXAIOU",[[1,5755,"```"]],[5755,5755],[5758,5758]]],[1562849681225,["GJX@GJXAIOU",[[1,6082,"\n"]],[6082,6082],[6083,6083]]],[1562849682356,["GJX@GJXAIOU",[[1,6082,"````"]],[6082,6082],[6086,6086]]],[1562849683417,["GJX@GJXAIOU",[[-1,6085,"`"]],[6086,6086],[6085,6085]]],[1562849685211,["GJX@GJXAIOU",[[1,6095,"```"]],[6095,6095],[6098,6098]]],[1562849690171,["GJX@GJXAIOU",[[1,6406,"\n"]],[6405,6405],[6406,6406]]],[1562849690731,["GJX@GJXAIOU",[[1,6406,"```"]],[6406,6406],[6409,6409]]],[1562849692737,["GJX@GJXAIOU",[[1,6410,"### "]],[6410,6410],[6445,6445]]],[1562849694861,["GJX@GJXAIOU",[[1,6491,"```"]],[6491,6491],[6494,6494]]],[1562849701531,["GJX@GJXAIOU",[[1,6639,"\n"]],[6639,6639],[6640,6640]]],[1562849702474,["GJX@GJXAIOU",[[1,6639,"```"]],[6639,6639],[6642,6642]]],[1562849703765,["GJX@GJXAIOU",[[1,6650,"```"]],[6650,6650],[6653,6653]]],[1562849705849,["GJX@GJXAIOU",[[1,7033,"\n"]],[7032,7032],[7033,7033]]],[1562849706370,["GJX@GJXAIOU",[[1,7033,"```"]],[7033,7033],[7036,7036]]],[1562849708256,["GJX@GJXAIOU",[[1,7037,"### "]],[7037,7037],[7067,7067]]],[1562849715908,["GJX@GJXAIOU",[[1,7101,"```"]],[7101,7101],[7104,7104]]],[1562849717970,["GJX@GJXAIOU",[[1,7260,"\n"]],[7260,7260],[7261,7261]]],[1562849718835,["GJX@GJXAIOU",[[1,7260,"```"]],[7260,7260],[7263,7263]]],[1562849720107,["GJX@GJXAIOU",[[1,7273,"```"]],[7273,7273],[7276,7276]]],[1562849724393,["GJX@GJXAIOU",[[1,7602,"\n"]],[7601,7601],[7602,7602]]],[1562849724962,["GJX@GJXAIOU",[[1,7602,"```"]],[7602,7602],[7605,7605]]],[1562849726864,["GJX@GJXAIOU",[[1,7606,"### "]],[7606,7606],[7619,7619]]],[1562849733034,["GJX@GJXAIOU",[[1,7788,"```"]],[7788,7788],[7791,7791]]],[1562849733698,["GJX@GJXAIOU",[[1,7960,"`"]],[7960,7960],[7961,7961]]],[1562849736368,["GJX@GJXAIOU",[[-1,7960,"`"]],[7961,7961],[7960,7960]]],[1562849737579,["GJX@GJXAIOU",[[1,7933,"\n"]],[7933,7933],[7934,7934]]],[1562849738418,["GJX@GJXAIOU",[[1,7933,"```"]],[7933,7933],[7936,7936]]],[1562849740419,["GJX@GJXAIOU",[[1,7964,"```"]],[7964,7964],[7967,7967]]],[1562849744848,["GJX@GJXAIOU",[[1,8257,"\n"]],[8256,8256],[8257,8257]]],[1562849745402,["GJX@GJXAIOU",[[1,8257,"```"]],[8257,8257],[8260,8260]]],[1562849748419,["GJX@GJXAIOU",[[1,8383,"```"]],[8383,8383],[8386,8386]]],[1562849755487,["GJX@GJXAIOU",[[1,8764,"\n"]],[8763,8763],[8764,8764]]],[1562849756057,["GJX@GJXAIOU",[[1,8764,"```"]],[8764,8764],[8767,8767]]],[1562849758610,["GJX@GJXAIOU",[[1,8854,"```"]],[8854,8854],[8857,8857]]],[1562849762959,["GJX@GJXAIOU",[[1,9468,"\n"]],[9467,9467],[9468,9468]]],[1562849763516,["GJX@GJXAIOU",[[1,9468,"```"]],[9468,9468],[9471,9471]]],[1562849766223,["GJX@GJXAIOU",[[1,9568,"### "]],[9568,9568],[9591,9591]]],[1562849769939,["GJX@GJXAIOU",[[1,9786,"```"]],[9786,9786],[9789,9789]]],[1562849793187,["GJX@GJXAIOU",[[-1,10721,"买卖股票的最佳时机\n\n买卖股票的最佳时机 II\n\n买卖股票的最佳时机 III\n\n买卖股票的最佳时机 IV\n\n最佳买卖股票时机含冷冻期\n\n买卖股票的最佳时机含手续费\n\n推荐阅读：\n\n学习数据结构的框架思维\n\n动态规划详解"],[1,10830,"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"]],[10721,10830],[10800,10800]]],[1562849812344,["GJX@GJXAIOU",[[1,10721,"买卖股票的最佳时机\n\n买卖股票的最佳时机 II\n\n买卖股票的最佳时机 III\n\n买卖股票的最佳时机 IV\n\n最佳买卖股票时机含冷冻期\n\n买卖股票的最佳时机含手续费\n\n推荐阅读：\n\n学习数据结构的框架思维\n\n动态规划详解"],[-1,10721,"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/买卖股票的最佳时机\n\n买卖股票的最佳时机 II\n\n买卖股票的最佳时机 III\n\n买卖股票的最佳时机 IV\n\n最佳买卖股票时机含冷冻期\n\n买卖股票的最佳时机含手续费\n\n推荐阅读：\n\n学习数据结构的框架思维\n\n动态规划详解"]],[10800,10800],[10721,10721]]],[1562849815728,["GJX@GJXAIOU",[[-1,10723,"如果本文对大家有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～"]],[10723,10767],[10723,10723]]],[1562849823281,["GJX@GJXAIOU",[[1,10721,"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/"]],[10721,10721],[10795,10795]]],[1562849834139,["GJX@GJXAIOU",[[1,10720,"买卖股票的最佳时机\n\n买卖股票的最佳时机 II\n\n买卖股票的最佳时机 III\n\n买卖股票的最佳时机 IV\n\n最佳买卖股票时机含冷冻期\n\n买卖股票的最佳时机含手续费\n\n作者：labuladong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[10720,10720],[10972,10972]]],[1562849839314,["GJX@GJXAIOU",[[-1,10803,"作者：labuladong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[10803,10972],[10803,10803]]],[1562849842926,["GJX@GJXAIOU",[[1,10803,"作者：labuladong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[10803,10803],[10803,10972]]],[1562849850079,["GJX@GJXAIOU",[[-1,10803,"作者：labuladong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[10803,10972],[10803,10803]]],[1562849912158,[null,[[-1,10878,"买卖佳时机 IV"],[-1,10888,"最佳买卖股票时机含冷冻期"],[-1,10902,"买卖股票的最佳时机含手续费\n\n推荐阅读：\n\n学习数据结构的框架思维\n\n动态规划详解"],[1,10943,"作者：labuladong\n链接：https://leetcode-cn.com/problems/two-sum/sol"]],[10878,10878],[11004,11004]]],[1562849912158,[null,[[1,10878,"买卖佳时机 IV"],[1,10880,"最佳买卖股票时机含冷冻期"],[1,10882,"买卖股票的最佳时机含手续费\n\n推荐阅读：\n\n学习数据结构的框架思维\n\n动态规划详解"],[-1,10882,"作者：labuladong\n链接：https://leetcode-cn.com/problems/two-sum/sol"]],[11004,11004],[10878,10878]]],[1562849856032,["GJX@GJXAIOU",[[1,10729,"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/"]],[10729,10729],[10803,10803]]],[1562849856065,["GJX@GJXAIOU",[[1,10729," "]],[10803,10803],[10804,10804]]],[1562849859079,["GJX@GJXAIOU",[[-1,10879,"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/"]],[10879,10953],[10879,10879]]],[1562849872288,["GJX@GJXAIOU",[[1,10818," https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/"]],[10818,10818],[10887,10887]]],[1562849878311,["GJX@GJXAIOU",[[1,10902," https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/"]],[10902,10902],[10972,10972]]],[1562849885367,["GJX@GJXAIOU",[[1,10986," https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/"]],[10986,10986],[11055,11055]]],[1562849890976,["GJX@GJXAIOU",[[1,11069," https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"]],[11069,11069],[11149,11149]]],[1562849896800,["GJX@GJXAIOU",[[1,11164," ****"]],[11164,11164],[11167,11167]]],[1562849898817,["GJX@GJXAIOU",[[-1,11164," ****"],[1,11169,"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/"]],[11164,11169],[11250,11250]]]],null,"GJX@GJXAIOU"]]}