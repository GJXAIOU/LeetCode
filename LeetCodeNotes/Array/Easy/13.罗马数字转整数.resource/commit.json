{"compress":true,"commitItems":[["d30c0846-a64b-4b7b-9dec-7bac9e7fa4da",1559724101768,"罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**          **数值**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.",[[1559724046119,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1559724046242,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1559724076861,["GJX@GJXAIOU",[[1,0,"-"],[-1,15," "],[1,16," "],[-1,20," "],[1,21," "],[-1,25," "],[1,26," "],[-1,30," "],[1,31," "],[-1,42," 和 "],[1,45," 和 "],[-1,209," "],[1,210," "],[-1,214," "],[1,215," "],[-1,231," "],[1,232," "],[-1,237," ，即为 `X` + "],[1,248," ，即为 `X` + "],[-1,252," "],[1,253," "],[-1,260,"  "],[1,262,"  "],[-1,273," "],[1,274," "],[-1,278," + `V` + "],[1,287," + `V` + "],[-1,291," "],[1,292," "],[-1,334," "],[1,335," "],[-1,344," "],[1,345," "],[-1,404," "],[1,405," "],[-1,437," "],[1,438," "],[-1,442," `V` "],[1,447," `V` "],[-1,452," `X` "],[1,457," `X` "],[-1,484," "],[1,485," "],[-1,489," `L` "],[1,494," `L` "],[-1,500," `C` "],[1,505," `C` "],[-1,523," 90。 "],[1,528," 90。 "],[-1,536," "],[1,537," "],[-1,541," `D` "],[1,546," `D` "],[-1,553," `M` "],[1,558," `M` "],[-1,572," "],[1,573," "],[-1,578," "],[1,579," "],[-1,609," "],[1,610," "],[-1,628," "],[1,629," "],[-1,642," "],[1,643," "],[-1,664," "],[1,665," "],[-1,678," "],[1,679," "],[-1,699," "],[1,700," "],[-1,713," "],[1,714," "],[-1,734," "],[1,735," "],[-1,748," "],[1,749," "],[-1,804," "],[1,805," "],[-1,818," "],[1,819," "]],[0,0],[1,1]]],[1559724076992,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1559724077105,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1559724077132,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1559724083111,["GJX@GJXAIOU",[[1,4,"tag:\""]],[4,4],[9,9]]],[1559724084038,["GJX@GJXAIOU",[[-1,8,"\""]],[9,9],[8,8]]],[1559724085103,["GJX@GJXAIOU",[[1,8,"'ge"]],[8,8],[11,11]]],[1559724085985,["GJX@GJXAIOU",[[-1,10,"e"]],[11,11],[10,10]]],[1559724087602,["GJX@GJXAIOU",[[1,10,"reen‘"]],[10,10],[15,15]]],[1559724088955,["GJX@GJXAIOU",[[-1,14,"‘"]],[15,15],[14,14]]],[1559724089559,["GJX@GJXAIOU",[[1,14,"'"]],[14,14],[15,15]]],[1559724090302,["GJX@GJXAIOU",[[1,16,"\n"]],[15,15],[16,16]]],[1559724099190,["GJX@GJXAIOU",[[-1,8,"'green'"]],[15,15],[8,8]]],[1559724100136,["GJX@GJXAIOU",[[1,7,"s"]],[7,7],[8,8]]],[1559724101545,["GJX@GJXAIOU",[[1,11,"\n"]],[9,9],[10,10]]],[1559724104432,["GJX@GJXAIOU",[[1,10,"- "]],[10,10],[12,12]]],[1559724143040,["GJX@GJXAIOU",[[1,14,"\n"]],[12,12],[13,13]]],[1559724161673,["GJX@GJXAIOU",[[1,14,"flag:'gree"]],[14,14],[24,24]]],[1559724162410,["GJX@GJXAIOU",[[1,24,"n'"]],[24,24],[26,26]]],[1559724163063,["GJX@GJXAIOU",[[1,27,"\n"]],[26,26],[27,27]]],[1559724171551,["GJX@GJXAIOU",[[-1,25,"'"]],[26,26],[25,25]]],[1559724173367,["GJX@GJXAIOU",[[-1,19,"'"]],[20,20],[19,19]]],[1559724177431,["GJX@GJXAIOU",[[1,25,"ta"]],[25,25],[27,27]]],[1559724178875,["GJX@GJXAIOU",[[-1,25,"ta"]],[27,27],[25,25]]],[1559724184967,["GJX@GJXAIOU",[[1,25,"date:'2019="]],[25,25],[36,36]]],[1559724185554,["GJX@GJXAIOU",[[-1,35,"="]],[36,36],[35,35]]],[1559724205431,["GJX@GJXAIOU",[[1,35,"-6-3'"]],[35,35],[40,40]]],[1559724208711,["GJX@GJXAIOU",[[-1,13,"\n"]],[13,13],[12,12]]],[1559724213992,["GJX@GJXAIOU",[[1,12,"ha"]],[12,12],[14,14]]],[1559724214609,["GJX@GJXAIOU",[[-1,12,"ha"]],[14,14],[12,12]]],[1559724216354,["GJX@GJXAIOU",[[1,12,"哈希表"]],[12,12],[15,15]]],[1559724217349,["GJX@GJXAIOU",[[1,16,"\n"]],[15,15],[16,16]]],[1559724219499,["GJX@GJXAIOU",[[1,10," "]],[10,10],[11,11]]],[1559724224614,["GJX@GJXAIOU",[[1,50,"### "]],[50,50],[54,54]]],[1559724227080,["GJX@GJXAIOU",[[-1,52,"# "]],[54,54],[52,52]]],[1559724231009,["GJX@GJXAIOU",[[1,52," 4。"]],[52,52],[55,55]]],[1559724231741,["GJX@GJXAIOU",[[-1,54,"。"]],[55,55],[54,54]]],[1559724232919,["GJX@GJXAIOU",[[1,54,".h"]],[54,54],[56,56]]],[1559724233314,["GJX@GJXAIOU",[[-1,55,"h"]],[56,56],[55,55]]],[1559724233912,["GJX@GJXAIOU",[[1,55,"luo"]],[55,55],[58,58]]],[1559724234622,["GJX@GJXAIOU",[[-1,55,"luo"]],[58,58],[55,55]]],[1559724235751,["GJX@GJXAIOU",[[1,55,"Luoma"]],[55,55],[60,60]]],[1559724236790,["GJX@GJXAIOU",[[-1,55,"Luoma"]],[60,60],[55,55]]],[1559724237577,["GJX@GJXAIOU",[[1,55,"Luo"]],[55,55],[58,58]]],[1559724238175,["GJX@GJXAIOU",[[-1,55,"Luo"]],[58,58],[55,55]]],[1559724239063,["GJX@GJXAIOU",[[1,55,"Lu"]],[55,55],[57,57]]],[1559724240048,["GJX@GJXAIOU",[[-1,55,"Lu"]],[57,57],[55,55]]],[1559724247482,["GJX@GJXAIOU",[[1,55,"罗马数字转整数"]],[55,55],[62,62]]],[1559724249474,["GJX@GJXAIOU",[[1,63,"\n"]],[62,62],[63,63]]],[1559724250033,["GJX@GJXAIOU",[[1,64,"\n"]],[63,63],[64,64]]],[1559724256828,["GJX@GJXAIOU",[[1,64,"### 一 、题目"]],[64,64],[73,73]]],[1559724266784,["GJX@GJXAIOU",[[1,133,"|"]],[133,133],[134,134]]],[1559724271054,["GJX@GJXAIOU",[[1,147,"\n"]],[146,146],[147,147]]],[1559724272586,["GJX@GJXAIOU",[[1,147,"、"]],[147,147],[148,148]]],[1559724273561,["GJX@GJXAIOU",[[-1,147,"、"]],[148,148],[147,147]]],[1559724277401,["GJX@GJXAIOU",[[1,147,"|---|---"]],[147,147],[155,155]]],[1559724279964,["GJX@GJXAIOU",[[1,164,"|"]],[164,164],[165,165]]],[1559724282833,["GJX@GJXAIOU",[[1,186,"|"]],[186,186],[187,187]]],[1559724284881,["GJX@GJXAIOU",[[1,204,"|"]],[204,204],[205,205]]],[1559724287745,["GJX@GJXAIOU",[[1,209,"|"]],[209,209],[210,210]]],[1559724289610,["GJX@GJXAIOU",[[1,229,"|"]],[229,229],[230,230]]],[1559724290922,["GJX@GJXAIOU",[[1,251,"|"]],[251,251],[252,252]]],[1559724292825,["GJX@GJXAIOU",[[1,275,"|"]],[275,275],[276,276]]],[1559724320002,["GJX@GJXAIOU",[[1,29,"\n"]],[28,28],[29,29]]]],null,"GJX@GJXAIOU"],["cc71fcd2-7aa0-4273-b647-3d98222a4d7f",1559724394227,"---\ntags:\n - 哈希表\n\nflag:green\n\ndate:'2019-6-3'\n---\n\n## 4.罗马数字转整数\n\n### 一 、题目\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**    |      **数值**\n|---|---\nI       |      1\nV            | 5\nX             |10\nL|             50\nC  |           100\nD     |        500\nM          |   1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.",[[1559724343594,["GJX@GJXAIOU",[[-1,0,"---\ntags:\n - 哈希表\n\nflag:green\n\ndate:'2019-6-3'\n---"]],[0,49],[0,0]]],[1559724344767,["GJX@GJXAIOU",[[1,0,"---\ntags:\n - 哈希表\n\nflag:green\n\ndate:'2019-6-3'\n---"]],[0,0],[49,49]]],[1559724352874,["GJX@GJXAIOU",[[1,4,"\n"]],[3,3],[4,4]]],[1559724356655,["GJX@GJXAIOU",[[1,12,"    "]],[12,12],[16,16]]],[1559724361719,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1559724366638,["GJX@GJXAIOU",[[-1,12,"     "]],[12,17],[12,12]]],[1559724370839,["GJX@GJXAIOU",[[1,12,"  "]],[12,12],[14,14]]],[1559724379343,["GJX@GJXAIOU",[[1,26," "]],[26,26],[27,27]]],[1559724381671,["GJX@GJXAIOU",[[1,39," "]],[39,39],[40,40]]],[1559724388952,["GJX@GJXAIOU",[[-1,11,"\n"]],[11,11],[10,10]]],[1559735491369,["GJX@GJXAIOU",[[1,980,"\n\n"]],[980,980],[981,981]]],[1559735491502,["GJX@GJXAIOU",[[1,982,"\n"]],[981,981],[982,982]]],[1559735491657,["GJX@GJXAIOU",[[1,983,"\n"]],[982,982],[983,983]]],[1559735505644,["GJX@GJXAIOU",[[1,982,"### 二、解法"]],[982,982],[990,990]]],[1559735506454,["GJX@GJXAIOU",[[1,992,"\n"]],[990,990],[991,991]]],[1559735506800,["GJX@GJXAIOU",[[1,993,"\n"]],[991,991],[992,992]]],[1559735512826,["GJX@GJXAIOU",[[1,992,"- 常规解法："]],[992,992],[999,999]]],[1559735513055,["GJX@GJXAIOU",[[1,1000,"- \n"]],[999,999],[1002,1002]]],[1559735520745,["GJX@GJXAIOU",[[1,1002,"哈希表解法："]],[1002,1002],[1008,1008]]],[1559735522223,["GJX@GJXAIOU",[[1,1002,"\n- "]],[999,999],[1002,1002]]],[1559735522350,["GJX@GJXAIOU",[[-1,1000,"- "]],[1002,1002],[1001,1001]]],[1559735522470,["GJX@GJXAIOU",[[1,1001,"\n"]],[1001,1001],[1002,1002]]],[1559735525078,["GJX@GJXAIOU",[[1,1002,"\n"]],[1000,1000],[1001,1001]]],[1559735526431,["GJX@GJXAIOU",[[1,1001,"```"]],[1001,1001],[1004,1004]]],[1559735526459,["GJX@GJXAIOU",[[1,1004,"language\n```\n"]],[1004,1004],[1004,1012]]],[1559735527464,["GJX@GJXAIOU",[[-1,1004,"language"],[1,1012,"c"]],[1004,1012],[1005,1005]]],[1559735527671,["GJX@GJXAIOU",[[1,1006,"\n"]],[1005,1005],[1006,1006]]],[1559735594394,["GJX@GJXAIOU",[[1,1022,"最基础情况\n试想一下，假如没有那几条特殊的规则，就是最简单的文字转换。那像XIV这样就可以直接转换为10+1+5=16\n\n注意：这是我们的整体思路，即字符的转换。\n\n特殊情况\n现在我们得知有三大种、六小种特殊情况，即：\n\nI(1) 和 V(5) 或 X(10) 组成 IV(4) 和 IX(9)\n\nX(10) 和 L(50) 或 C(100) 组成 XL(40) 和 XC(90)\n\nC(100) 和 D(500) 或 M(1000) 组成 CD(400) 和 CM(900)\n\n我把他们写成这样的形式相信大家一眼就可以看出来这其中的规律：当右边的数是左边的数5倍或10倍的时候，左边的数就去相反数与其相加即可。\n\n举个例子，IV其中V(5)是I(1)的五倍，那么这时候两者在一起，只需将I取值为相反数-1，然后再相加即可。那么XIV也就可以写成10+-1+5=14（可以看看后记哦）\n\n需要注意的地方\n因为需要用到前一个和后一个值做比较，所以需要考虑下标是否越界的问题，因此在遍历字符串时要在倒数第二个地方结束，即i只能取值0 <= i < s.length()-1。最后再加上字符串最后一位的值。\n\nJava代码\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();//使用map把他们对应存储起来\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;          //存放结果\n        int current=0;     //第一个值\n        int next=0;       //后一个值\n        \n        for(int i=0;i<s.length()-1;++i){        //注意这里的s.length()-1是为了防止下标越界\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n\n            if(next/current==5||next/current==10){    //如果满足后一个是前一个5倍或10倍\n                res-=map.get(s.charAt(i));            //结果减掉当前值（相当于加了相反数）\n            }else{\n                res+=map.get(s.charAt(i));            //否则加上当前值\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));        //最后再加上字符串末尾的值\n        \n        return res;\n    }\n}\n后记\n这里能有人会问，那万一是 V(5) 和 L(50) 放在一起呢？这也是十倍的关系啊！说实话一开始我也没有想到这一点，就是在写这篇文章的时候才发现的。但事实上这是不符合题目假设的，因为题目说明除了6种情况外，小的数必须在大的数右边。\n\n但本着杠精的思想，我提交了测试，发现LeetCode返回的结果是VL=45，这让我很惊讶！于是我大胆尝试测试了一个V(5)和C(100)组合是什么结果，结果更让我惊讶的是VC=95，但按照我之前写的思路，应该是VC=105。这样看来我萌生了一个大胆的想法，只要是左边的数比右边的数小，那么左边的数就要变成相反数，基于这一想法我修改代码，再次提交。再次惊讶，竟然运行时间比之前减小了20%。咱也不知道为啥，咱也不敢问。多半是判断条件减少了所以快了吧。不知道这种小数在大数左边的到底该怎么判定，不该返回0或者错误吗？😂\n\n这是修改后的代码（就改了个判断条件）\n\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;\n        int current=0;\n        int next=0;\n        \n        for(int i=0;i<s.length()-1;++i){\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n            if(next>current){\n                res-=map.get(s.charAt(i));\n            }else{\n                res+=map.get(s.charAt(i));\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));\n        \n        return res;\n    }\n}\n欢迎大家讨论这个VC的问题\n作者：godk-1\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhua-zhu-guan-jian-qu-bie-xiang-xi-fen-xi-ti-mu-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1022,1022],[3841,3841]]],[1559735597937,["GJX@GJXAIOU",[[1,1022,"- \n"]],[1021,1021],[1024,1024]]],[1559735599863,["GJX@GJXAIOU",[[-1,1022,"- "]],[1024,1024],[1022,1022]]],[1559735604553,["GJX@GJXAIOU",[[1,1023,"**"],[1,1028,"**"]],[1023,1028],[1023,1032]]],[1559735606991,["GJX@GJXAIOU",[[1,1110,"**"],[1,1114,"**"]],[1110,1114],[1110,1118]]],[1559735622680,["GJX@GJXAIOU",[[1,1301,"**"],[1,1337,"**"]],[1301,1337],[1301,1341]]],[1559735629975,["GJX@GJXAIOU",[[1,1429,"**"],[1,1436,"**"]],[1429,1436],[1429,1440]]],[1559735637489,["GJX@GJXAIOU",[[1,1541,"```"]],[1541,1541],[1544,1544]]],[1559735637520,["GJX@GJXAIOU",[[1,1544,"language\n```\n"]],[1544,1544],[1544,1552]]],[1559735639649,["GJX@GJXAIOU",[[-1,1544,"language"],[1,1552,"J"]],[1544,1552],[1545,1545]]],[1559735640410,["GJX@GJXAIOU",[[1,1545,"ava"]],[1545,1545],[1548,1548]]],[1559735643759,["GJX@GJXAIOU",[[-1,1549,"```"]],[1549,1552],[1549,1549]]],[1559735649343,["GJX@GJXAIOU",[[1,2528,"\n"]],[2527,2527],[2528,2528]]],[1559735649786,["GJX@GJXAIOU",[[1,2528,"```"]],[2528,2528],[2531,2531]]],[1559735653577,["GJX@GJXAIOU",[[-1,1550,"Java代码\n"]],[1549,1556],[1549,1549]]],[1559735653705,["GJX@GJXAIOU",[[-1,1549,"\n"]],[1549,1549],[1548,1548]]],[1559735663566,["GJX@GJXAIOU",[[1,2524,"**"],[1,2526,"**"]],[2524,2526],[2524,2530]]],[1559735669040,["GJX@GJXAIOU",[[1,2927,"```"]],[2927,2927],[2930,2930]]],[1559735669070,["GJX@GJXAIOU",[[1,2930,"language\n```\n"]],[2930,2930],[2930,2938]]],[1559735670304,["GJX@GJXAIOU",[[-1,2930,"language"],[1,2938,"j"]],[2930,2938],[2931,2931]]],[1559735670672,["GJX@GJXAIOU",[[1,2931,"ava"]],[2931,2931],[2934,2934]]],[1559735673422,["GJX@GJXAIOU",[[-1,2935,"```"]],[2935,2938],[2935,2935]]],[1559735676286,["GJX@GJXAIOU",[[1,3697,"\n"]],[3696,3696],[3697,3697]]],[1559735676415,["GJX@GJXAIOU",[[1,3698,"\n"]],[3697,3697],[3698,3698]]],[1559735676774,["GJX@GJXAIOU",[[1,3698,"```"]],[3698,3698],[3701,3701]]],[1559735813298,["GJX@GJXAIOU",[[1,1000,"第一次遍历一个字符把符合值加到结果里，第二次遍历两个字符从结果中减去符合值。"]],[1000,1000],[1038,1038]]],[1559735859358,["GJX@GJXAIOU",[[1,1044,"class Solution {\n    public int romanToInt(String s) {\n\tint result = 0;\n        for(int i = 0; i < s.length(); i++) {\n            switch(s.charAt(i)) {\n                case 'I': \n                    result += 1;\n                    break;\n                case 'V': \n                    result += 5;\n                    break;\n                case 'X':\n                    result += 10;\n                    break;\n                case 'L':\n                    result += 50;\n                    break;\n                case 'C':\n                    result += 100;\n                    break;\n                case 'D':\n                    result += 500;\n                    break;\n                case 'M':\n                    result += 1000;\n                    break;\n            }\n        }\n\tfor(int j = 0; j < s.length() - 1; j++) {\n            switch(\"\" + s.charAt(j) + s.charAt(j+1)) {\n                case \"IV\":\n                case \"IX\":\n                    result -= 2;\n                    break;\n                case \"XL\":\n                case \"XC\":\n                    result -= 20;\n                    break;\n                case \"CD\":\n                case \"CM\":\n                    result -= 200;\n                    break;\n            }\n        }\n        return result;\n    }\n}\n"]],[1044,1044],[2331,2331]]]],null,"GJX@GJXAIOU"],["9a38ee8e-8e8d-4385-9284-7e0c82290b3f",1559805112165,"---\n\ntags:\n  - 哈希表\n\nflag: green\n\ndate: '2019-6-3'\n---\n\n## 4.罗马数字转整数\n\n### 一 、题目\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**    |      **数值**\n|---|---\nI       |      1\nV            | 5\nX             |10\nL|             50\nC  |           100\nD     |        500\nM          |   1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.\n\n### 二、解法\n\n- 常规解法：\n第一次遍历一个字符把符合值加到结果里，第二次遍历两个字符从结果中减去符合值。\n```c\nclass Solution {\n    public int romanToInt(String s) {\n\tint result = 0;\n        for(int i = 0; i < s.length(); i++) {\n            switch(s.charAt(i)) {\n                case 'I': \n                    result += 1;\n                    break;\n                case 'V': \n                    result += 5;\n                    break;\n                case 'X':\n                    result += 10;\n                    break;\n                case 'L':\n                    result += 50;\n                    break;\n                case 'C':\n                    result += 100;\n                    break;\n                case 'D':\n                    result += 500;\n                    break;\n                case 'M':\n                    result += 1000;\n                    break;\n            }\n        }\n\tfor(int j = 0; j < s.length() - 1; j++) {\n            switch(\"\" + s.charAt(j) + s.charAt(j+1)) {\n                case \"IV\":\n                case \"IX\":\n                    result -= 2;\n                    break;\n                case \"XL\":\n                case \"XC\":\n                    result -= 20;\n                    break;\n                case \"CD\":\n                case \"CM\":\n                    result -= 200;\n                    break;\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n\n- 哈希表解法：\n\n**最基础情况**\n试想一下，假如没有那几条特殊的规则，就是最简单的文字转换。那像XIV这样就可以直接转换为10+1+5=16\n\n注意：这是我们的整体思路，即字符的转换。\n\n**特殊情况**\n现在我们得知有三大种、六小种特殊情况，即：\n\nI(1) 和 V(5) 或 X(10) 组成 IV(4) 和 IX(9)\n\nX(10) 和 L(50) 或 C(100) 组成 XL(40) 和 XC(90)\n\nC(100) 和 D(500) 或 M(1000) 组成 CD(400) 和 CM(900)\n\n我把他们写成这样的形式相信大家一眼就可以看出来这其中的规律：**当右边的数是左边的数5倍或10倍的时候，左边的数就去相反数与其相加即可。**\n\n举个例子，IV其中V(5)是I(1)的五倍，那么这时候两者在一起，只需将I取值为相反数-1，然后再相加即可。那么XIV也就可以写成10+-1+5=14（可以看看后记哦）\n\n**需要注意的地方**\n因为需要用到前一个和后一个值做比较，所以需要考虑下标是否越界的问题，因此在遍历字符串时要在倒数第二个地方结束，即i只能取值0 <= i < s.length()-1。最后再加上字符串最后一位的值。\n\n```Java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();//使用map把他们对应存储起来\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;          //存放结果\n        int current=0;     //第一个值\n        int next=0;       //后一个值\n        \n        for(int i=0;i<s.length()-1;++i){        //注意这里的s.length()-1是为了防止下标越界\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n\n            if(next/current==5||next/current==10){    //如果满足后一个是前一个5倍或10倍\n                res-=map.get(s.charAt(i));            //结果减掉当前值（相当于加了相反数）\n            }else{\n                res+=map.get(s.charAt(i));            //否则加上当前值\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));        //最后再加上字符串末尾的值\n        \n        return res;\n    }\n}\n```\n**后记**\n这里能有人会问，那万一是 V(5) 和 L(50) 放在一起呢？这也是十倍的关系啊！说实话一开始我也没有想到这一点，就是在写这篇文章的时候才发现的。但事实上这是不符合题目假设的，因为题目说明除了6种情况外，小的数必须在大的数右边。\n\n但本着杠精的思想，我提交了测试，发现LeetCode返回的结果是VL=45，这让我很惊讶！于是我大胆尝试测试了一个V(5)和C(100)组合是什么结果，结果更让我惊讶的是VC=95，但按照我之前写的思路，应该是VC=105。这样看来我萌生了一个大胆的想法，只要是左边的数比右边的数小，那么左边的数就要变成相反数，基于这一想法我修改代码，再次提交。再次惊讶，竟然运行时间比之前减小了20%。咱也不知道为啥，咱也不敢问。多半是判断条件减少了所以快了吧。不知道这种小数在大数左边的到底该怎么判定，不该返回0或者错误吗？😂\n\n这是修改后的代码（就改了个判断条件）\n```java\n\n\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;\n        int current=0;\n        int next=0;\n        \n        for(int i=0;i<s.length()-1;++i){\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n            if(next>current){\n                res-=map.get(s.charAt(i));\n            }else{\n                res+=map.get(s.charAt(i));\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));\n        \n        return res;\n    }\n}\n\n```\n欢迎大家讨论这个VC的问题\n作者：godk-1\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhua-zhu-guan-jian-qu-bie-xiang-xi-fen-xi-ti-mu-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n",[[1559805075585,["GJX@GJXAIOU",[[-1,4,"\n"]],[4,4],[3,3]]]],null,"GJX@GJXAIOU"],["317d2c1b-fc7f-4be2-9c2d-62508cef9587",1559891517786,"---\ntags:\n  - 哈希表\n\nflag: green\n\ndate: '2019-6-3'\n---\n\n## 4.罗马数字转整数\n\n### 一 、题目\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**    |      **数值**\n|---|---\nI       |      1\nV            | 5\nX             |10\nL|             50\nC  |           100\nD     |        500\nM          |   1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.\n\n### 二、解法\n\n- 常规解法：\n第一次遍历一个字符把符合值加到结果里，第二次遍历两个字符从结果中减去符合值。\n```c\nclass Solution {\n    public int romanToInt(String s) {\n\tint result = 0;\n        for(int i = 0; i < s.length(); i++) {\n            switch(s.charAt(i)) {\n                case 'I': \n                    result += 1;\n                    break;\n                case 'V': \n                    result += 5;\n                    break;\n                case 'X':\n                    result += 10;\n                    break;\n                case 'L':\n                    result += 50;\n                    break;\n                case 'C':\n                    result += 100;\n                    break;\n                case 'D':\n                    result += 500;\n                    break;\n                case 'M':\n                    result += 1000;\n                    break;\n            }\n        }\n\tfor(int j = 0; j < s.length() - 1; j++) {\n            switch(\"\" + s.charAt(j) + s.charAt(j+1)) {\n                case \"IV\":\n                case \"IX\":\n                    result -= 2;\n                    break;\n                case \"XL\":\n                case \"XC\":\n                    result -= 20;\n                    break;\n                case \"CD\":\n                case \"CM\":\n                    result -= 200;\n                    break;\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n\n- 哈希表解法：\n\n**最基础情况**\n试想一下，假如没有那几条特殊的规则，就是最简单的文字转换。那像XIV这样就可以直接转换为10+1+5=16\n\n注意：这是我们的整体思路，即字符的转换。\n\n**特殊情况**\n现在我们得知有三大种、六小种特殊情况，即：\n\nI(1) 和 V(5) 或 X(10) 组成 IV(4) 和 IX(9)\n\nX(10) 和 L(50) 或 C(100) 组成 XL(40) 和 XC(90)\n\nC(100) 和 D(500) 或 M(1000) 组成 CD(400) 和 CM(900)\n\n我把他们写成这样的形式相信大家一眼就可以看出来这其中的规律：**当右边的数是左边的数5倍或10倍的时候，左边的数就去相反数与其相加即可。**\n\n举个例子，IV其中V(5)是I(1)的五倍，那么这时候两者在一起，只需将I取值为相反数-1，然后再相加即可。那么XIV也就可以写成10+-1+5=14（可以看看后记哦）\n\n**需要注意的地方**\n因为需要用到前一个和后一个值做比较，所以需要考虑下标是否越界的问题，因此在遍历字符串时要在倒数第二个地方结束，即i只能取值0 <= i < s.length()-1。最后再加上字符串最后一位的值。\n\n```Java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();//使用map把他们对应存储起来\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;          //存放结果\n        int current=0;     //第一个值\n        int next=0;       //后一个值\n        \n        for(int i=0;i<s.length()-1;++i){        //注意这里的s.length()-1是为了防止下标越界\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n\n            if(next/current==5||next/current==10){    //如果满足后一个是前一个5倍或10倍\n                res-=map.get(s.charAt(i));            //结果减掉当前值（相当于加了相反数）\n            }else{\n                res+=map.get(s.charAt(i));            //否则加上当前值\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));        //最后再加上字符串末尾的值\n        \n        return res;\n    }\n}\n```\n**后记**\n这里能有人会问，那万一是 V(5) 和 L(50) 放在一起呢？这也是十倍的关系啊！说实话一开始我也没有想到这一点，就是在写这篇文章的时候才发现的。但事实上这是不符合题目假设的，因为题目说明除了6种情况外，小的数必须在大的数右边。\n\n但本着杠精的思想，我提交了测试，发现LeetCode返回的结果是VL=45，这让我很惊讶！于是我大胆尝试测试了一个V(5)和C(100)组合是什么结果，结果更让我惊讶的是VC=95，但按照我之前写的思路，应该是VC=105。这样看来我萌生了一个大胆的想法，只要是左边的数比右边的数小，那么左边的数就要变成相反数，基于这一想法我修改代码，再次提交。再次惊讶，竟然运行时间比之前减小了20%。咱也不知道为啥，咱也不敢问。多半是判断条件减少了所以快了吧。不知道这种小数在大数左边的到底该怎么判定，不该返回0或者错误吗？😂\n\n这是修改后的代码（就改了个判断条件）\n```java\n\n\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;\n        int current=0;\n        int next=0;\n        \n        for(int i=0;i<s.length()-1;++i){\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n            if(next>current){\n                res-=map.get(s.charAt(i));\n            }else{\n                res+=map.get(s.charAt(i));\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));\n        \n        return res;\n    }\n}\n\n```\n欢迎大家讨论这个VC的问题\n作者：godk-1\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhua-zhu-guan-jian-qu-bie-xiang-xi-fen-xi-ti-mu-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n",[[1559891490725,["GJX@GJXAIOU",[[-1,46,"3"]],[47,47],[46,46]]],[1559891491254,["GJX@GJXAIOU",[[1,46,"5"]],[46,46],[47,47]]]],null,"GJX@GJXAIOU"],["13c6c36b-1ea9-4a27-a4d9-f696c5a9d61d",1560058678193,"---\ntags:\n  - 哈希表\n\nflag: green\n\ndate: '2019-6-5'\n---\n\n## 4.罗马数字转整数\n\n### 一 、题目\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**    |      **数值**\n|---|---\nI       |      1\nV            | 5\nX             |10\nL|             50\nC  |           100\nD     |        500\nM          |   1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.\n\n### 二、解法\n\n- 常规解法：\n第一次遍历一个字符把符合值加到结果里，第二次遍历两个字符从结果中减去符合值。\n```c\nclass Solution {\n    public int romanToInt(String s) {\n\tint result = 0;\n        for(int i = 0; i < s.length(); i++) {\n            switch(s.charAt(i)) {\n                case 'I': \n                    result += 1;\n                    break;\n                case 'V': \n                    result += 5;\n                    break;\n                case 'X':\n                    result += 10;\n                    break;\n                case 'L':\n                    result += 50;\n                    break;\n                case 'C':\n                    result += 100;\n                    break;\n                case 'D':\n                    result += 500;\n                    break;\n                case 'M':\n                    result += 1000;\n                    break;\n            }\n        }\n\tfor(int j = 0; j < s.length() - 1; j++) {\n            switch(\"\" + s.charAt(j) + s.charAt(j+1)) {\n                case \"IV\":\n                case \"IX\":\n                    result -= 2;\n                    break;\n                case \"XL\":\n                case \"XC\":\n                    result -= 20;\n                    break;\n                case \"CD\":\n                case \"CM\":\n                    result -= 200;\n                    break;\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n\n- 哈希表解法：\n\n**最基础情况**\n试想一下，假如没有那几条特殊的规则，就是最简单的文字转换。那像XIV这样就可以直接转换为10+1+5=16\n\n注意：这是我们的整体思路，即字符的转换。\n\n**特殊情况**\n现在我们得知有三大种、六小种特殊情况，即：\n\nI(1) 和 V(5) 或 X(10) 组成 IV(4) 和 IX(9)\n\nX(10) 和 L(50) 或 C(100) 组成 XL(40) 和 XC(90)\n\nC(100) 和 D(500) 或 M(1000) 组成 CD(400) 和 CM(900)\n\n我把他们写成这样的形式相信大家一眼就可以看出来这其中的规律：**当右边的数是左边的数5倍或10倍的时候，左边的数就去相反数与其相加即可。**\n\n举个例子，IV其中V(5)是I(1)的五倍，那么这时候两者在一起，只需将I取值为相反数-1，然后再相加即可。那么XIV也就可以写成10+-1+5=14（可以看看后记哦）\n\n**需要注意的地方**\n因为需要用到前一个和后一个值做比较，所以需要考虑下标是否越界的问题，因此在遍历字符串时要在倒数第二个地方结束，即i只能取值0 <= i < s.length()-1。最后再加上字符串最后一位的值。\n\n```Java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();//使用map把他们对应存储起来\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;          //存放结果\n        int current=0;     //第一个值\n        int next=0;       //后一个值\n        \n        for(int i=0;i<s.length()-1;++i){        //注意这里的s.length()-1是为了防止下标越界\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n\n            if(next/current==5||next/current==10){    //如果满足后一个是前一个5倍或10倍\n                res-=map.get(s.charAt(i));            //结果减掉当前值（相当于加了相反数）\n            }else{\n                res+=map.get(s.charAt(i));            //否则加上当前值\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));        //最后再加上字符串末尾的值\n        \n        return res;\n    }\n}\n```\n**后记**\n这里能有人会问，那万一是 V(5) 和 L(50) 放在一起呢？这也是十倍的关系啊！说实话一开始我也没有想到这一点，就是在写这篇文章的时候才发现的。但事实上这是不符合题目假设的，因为题目说明除了6种情况外，小的数必须在大的数右边。\n\n但本着杠精的思想，我提交了测试，发现LeetCode返回的结果是VL=45，这让我很惊讶！于是我大胆尝试测试了一个V(5)和C(100)组合是什么结果，结果更让我惊讶的是VC=95，但按照我之前写的思路，应该是VC=105。这样看来我萌生了一个大胆的想法，只要是左边的数比右边的数小，那么左边的数就要变成相反数，基于这一想法我修改代码，再次提交。再次惊讶，竟然运行时间比之前减小了20%。咱也不知道为啥，咱也不敢问。多半是判断条件减少了所以快了吧。不知道这种小数在大数左边的到底该怎么判定，不该返回0或者错误吗？😂\n\n这是修改后的代码（就改了个判断条件）\n```java\n\n\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;\n        int current=0;\n        int next=0;\n        \n        for(int i=0;i<s.length()-1;++i){\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n            if(next>current){\n                res-=map.get(s.charAt(i));\n            }else{\n                res+=map.get(s.charAt(i));\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));\n        \n        return res;\n    }\n}\n\n```\n欢迎大家讨论这个VC的问题\n作者：godk-1\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhua-zhu-guan-jian-qu-bie-xiang-xi-fen-xi-ti-mu-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n",[[1560058635141,["GJX@GJXAIOU",[[1,10,"\n"]],[9,9],[10,10]]],[1560058639179,["GJX@GJXAIOU",[[1,10,"- 简单"]],[10,10],[14,14]]],[1560058641116,["GJX@GJXAIOU",[[1,10,"  "]],[10,10],[12,12]]]],null,"GJX@GJXAIOU"],["4344410c-214d-4b1d-8c83-a78c6f939ab0",1560157655765,"---\ntags:\n  - 简单\n  - 哈希表\n\nflag: green\n\ndate: '2019-6-5'\n---\n\n## 4.罗马数字转整数\n\n### 一 、题目\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**    |      **数值**\n|---|---\nI       |      1\nV            | 5\nX             |10\nL|             50\nC  |           100\nD     |        500\nM          |   1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.\n\n### 二、解法\n\n- 常规解法：\n第一次遍历一个字符把符合值加到结果里，第二次遍历两个字符从结果中减去符合值。\n```c\nclass Solution {\n    public int romanToInt(String s) {\n\tint result = 0;\n        for(int i = 0; i < s.length(); i++) {\n            switch(s.charAt(i)) {\n                case 'I': \n                    result += 1;\n                    break;\n                case 'V': \n                    result += 5;\n                    break;\n                case 'X':\n                    result += 10;\n                    break;\n                case 'L':\n                    result += 50;\n                    break;\n                case 'C':\n                    result += 100;\n                    break;\n                case 'D':\n                    result += 500;\n                    break;\n                case 'M':\n                    result += 1000;\n                    break;\n            }\n        }\n\tfor(int j = 0; j < s.length() - 1; j++) {\n            switch(\"\" + s.charAt(j) + s.charAt(j+1)) {\n                case \"IV\":\n                case \"IX\":\n                    result -= 2;\n                    break;\n                case \"XL\":\n                case \"XC\":\n                    result -= 20;\n                    break;\n                case \"CD\":\n                case \"CM\":\n                    result -= 200;\n                    break;\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n\n- 哈希表解法：\n\n**最基础情况**\n试想一下，假如没有那几条特殊的规则，就是最简单的文字转换。那像XIV这样就可以直接转换为10+1+5=16\n\n注意：这是我们的整体思路，即字符的转换。\n\n**特殊情况**\n现在我们得知有三大种、六小种特殊情况，即：\n\nI(1) 和 V(5) 或 X(10) 组成 IV(4) 和 IX(9)\n\nX(10) 和 L(50) 或 C(100) 组成 XL(40) 和 XC(90)\n\nC(100) 和 D(500) 或 M(1000) 组成 CD(400) 和 CM(900)\n\n我把他们写成这样的形式相信大家一眼就可以看出来这其中的规律：**当右边的数是左边的数5倍或10倍的时候，左边的数就去相反数与其相加即可。**\n\n举个例子，IV其中V(5)是I(1)的五倍，那么这时候两者在一起，只需将I取值为相反数-1，然后再相加即可。那么XIV也就可以写成10+-1+5=14（可以看看后记哦）\n\n**需要注意的地方**\n因为需要用到前一个和后一个值做比较，所以需要考虑下标是否越界的问题，因此在遍历字符串时要在倒数第二个地方结束，即i只能取值0 <= i < s.length()-1。最后再加上字符串最后一位的值。\n\n```Java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();//使用map把他们对应存储起来\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;          //存放结果\n        int current=0;     //第一个值\n        int next=0;       //后一个值\n        \n        for(int i=0;i<s.length()-1;++i){        //注意这里的s.length()-1是为了防止下标越界\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n\n            if(next/current==5||next/current==10){    //如果满足后一个是前一个5倍或10倍\n                res-=map.get(s.charAt(i));            //结果减掉当前值（相当于加了相反数）\n            }else{\n                res+=map.get(s.charAt(i));            //否则加上当前值\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));        //最后再加上字符串末尾的值\n        \n        return res;\n    }\n}\n```\n**后记**\n这里能有人会问，那万一是 V(5) 和 L(50) 放在一起呢？这也是十倍的关系啊！说实话一开始我也没有想到这一点，就是在写这篇文章的时候才发现的。但事实上这是不符合题目假设的，因为题目说明除了6种情况外，小的数必须在大的数右边。\n\n但本着杠精的思想，我提交了测试，发现LeetCode返回的结果是VL=45，这让我很惊讶！于是我大胆尝试测试了一个V(5)和C(100)组合是什么结果，结果更让我惊讶的是VC=95，但按照我之前写的思路，应该是VC=105。这样看来我萌生了一个大胆的想法，只要是左边的数比右边的数小，那么左边的数就要变成相反数，基于这一想法我修改代码，再次提交。再次惊讶，竟然运行时间比之前减小了20%。咱也不知道为啥，咱也不敢问。多半是判断条件减少了所以快了吧。不知道这种小数在大数左边的到底该怎么判定，不该返回0或者错误吗？😂\n\n这是修改后的代码（就改了个判断条件）\n```java\n\n\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;\n        int current=0;\n        int next=0;\n        \n        for(int i=0;i<s.length()-1;++i){\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n            if(next>current){\n                res-=map.get(s.charAt(i));\n            }else{\n                res+=map.get(s.charAt(i));\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));\n        \n        return res;\n    }\n}\n\n```\n欢迎大家讨论这个VC的问题\n作者：godk-1\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhua-zhu-guan-jian-qu-bie-xiang-xi-fen-xi-ti-mu-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n",[[1560157626000,["GJX@GJXAIOU",[[-1,64,"4"]],[65,65],[64,64]]],[1560157626777,["GJX@GJXAIOU",[[1,64,"413"]],[64,64],[67,67]]],[1560157628464,["GJX@GJXAIOU",[[-1,64,"4"]],[65,65],[64,64]]],[1560157631932,["GJX@GJXAIOU",[[1,64," 4"]],[64,64],[65,65]]],[1560157634539,["GJX@GJXAIOU",[[-1,63,"  4"]],[66,66],[63,63]]],[1560157653902,["GJX@GJXAIOU",[[-1,65,".罗"]],[66,66],[65,65]]]],null,"GJX@GJXAIOU"],["59e2e9e3-1bac-4123-bab0-cd8f2c62dbc3",1560157722362,"---\ntags:\n  - 简单\n  - 哈希表\n\nflag: green\n\ndate: '2019-6-5'\n---\n\n##13马数字转整数\n\n### 一 、题目\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**    |      **数值**\n|---|---\nI       |      1\nV            | 5\nX             |10\nL|             50\nC  |           100\nD     |        500\nM          |   1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.\n\n### 二、解法\n\n- 常规解法：\n第一次遍历一个字符把符合值加到结果里，第二次遍历两个字符从结果中减去符合值。\n```c\nclass Solution {\n    public int romanToInt(String s) {\n\tint result = 0;\n        for(int i = 0; i < s.length(); i++) {\n            switch(s.charAt(i)) {\n                case 'I': \n                    result += 1;\n                    break;\n                case 'V': \n                    result += 5;\n                    break;\n                case 'X':\n                    result += 10;\n                    break;\n                case 'L':\n                    result += 50;\n                    break;\n                case 'C':\n                    result += 100;\n                    break;\n                case 'D':\n                    result += 500;\n                    break;\n                case 'M':\n                    result += 1000;\n                    break;\n            }\n        }\n\tfor(int j = 0; j < s.length() - 1; j++) {\n            switch(\"\" + s.charAt(j) + s.charAt(j+1)) {\n                case \"IV\":\n                case \"IX\":\n                    result -= 2;\n                    break;\n                case \"XL\":\n                case \"XC\":\n                    result -= 20;\n                    break;\n                case \"CD\":\n                case \"CM\":\n                    result -= 200;\n                    break;\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n\n- 哈希表解法：\n\n**最基础情况**\n试想一下，假如没有那几条特殊的规则，就是最简单的文字转换。那像XIV这样就可以直接转换为10+1+5=16\n\n注意：这是我们的整体思路，即字符的转换。\n\n**特殊情况**\n现在我们得知有三大种、六小种特殊情况，即：\n\nI(1) 和 V(5) 或 X(10) 组成 IV(4) 和 IX(9)\n\nX(10) 和 L(50) 或 C(100) 组成 XL(40) 和 XC(90)\n\nC(100) 和 D(500) 或 M(1000) 组成 CD(400) 和 CM(900)\n\n我把他们写成这样的形式相信大家一眼就可以看出来这其中的规律：**当右边的数是左边的数5倍或10倍的时候，左边的数就去相反数与其相加即可。**\n\n举个例子，IV其中V(5)是I(1)的五倍，那么这时候两者在一起，只需将I取值为相反数-1，然后再相加即可。那么XIV也就可以写成10+-1+5=14（可以看看后记哦）\n\n**需要注意的地方**\n因为需要用到前一个和后一个值做比较，所以需要考虑下标是否越界的问题，因此在遍历字符串时要在倒数第二个地方结束，即i只能取值0 <= i < s.length()-1。最后再加上字符串最后一位的值。\n\n```Java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();//使用map把他们对应存储起来\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;          //存放结果\n        int current=0;     //第一个值\n        int next=0;       //后一个值\n        \n        for(int i=0;i<s.length()-1;++i){        //注意这里的s.length()-1是为了防止下标越界\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n\n            if(next/current==5||next/current==10){    //如果满足后一个是前一个5倍或10倍\n                res-=map.get(s.charAt(i));            //结果减掉当前值（相当于加了相反数）\n            }else{\n                res+=map.get(s.charAt(i));            //否则加上当前值\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));        //最后再加上字符串末尾的值\n        \n        return res;\n    }\n}\n```\n**后记**\n这里能有人会问，那万一是 V(5) 和 L(50) 放在一起呢？这也是十倍的关系啊！说实话一开始我也没有想到这一点，就是在写这篇文章的时候才发现的。但事实上这是不符合题目假设的，因为题目说明除了6种情况外，小的数必须在大的数右边。\n\n但本着杠精的思想，我提交了测试，发现LeetCode返回的结果是VL=45，这让我很惊讶！于是我大胆尝试测试了一个V(5)和C(100)组合是什么结果，结果更让我惊讶的是VC=95，但按照我之前写的思路，应该是VC=105。这样看来我萌生了一个大胆的想法，只要是左边的数比右边的数小，那么左边的数就要变成相反数，基于这一想法我修改代码，再次提交。再次惊讶，竟然运行时间比之前减小了20%。咱也不知道为啥，咱也不敢问。多半是判断条件减少了所以快了吧。不知道这种小数在大数左边的到底该怎么判定，不该返回0或者错误吗？😂\n\n这是修改后的代码（就改了个判断条件）\n```java\n\n\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;\n        int current=0;\n        int next=0;\n        \n        for(int i=0;i<s.length()-1;++i){\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n            if(next>current){\n                res-=map.get(s.charAt(i));\n            }else{\n                res+=map.get(s.charAt(i));\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));\n        \n        return res;\n    }\n}\n\n```\n欢迎大家讨论这个VC的问题\n作者：godk-1\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhua-zhu-guan-jian-qu-bie-xiang-xi-fen-xi-ti-mu-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n",[[1560157669702,["GJX@GJXAIOU",[[1,63," "]],[63,63],[64,64]]],[1560157671283,["GJX@GJXAIOU",[[1,66,"。"]],[66,66],[67,67]]],[1560157672286,["GJX@GJXAIOU",[[-1,66,"。"]],[67,67],[66,66]]],[1560157676554,["GJX@GJXAIOU",[[1,66,".luo"]],[66,66],[70,70]]],[1560157678373,["GJX@GJXAIOU",[[-1,67,"luo"]],[70,70],[67,67]]],[1560157681130,["GJX@GJXAIOU",[[1,67,"罗"]],[67,67],[68,68]]]],null,"GJX@GJXAIOU"],["59d3d095-cd89-427d-b23e-759b021f9548",1561422805377,"---\ntags:\n  - 简单\n  - 哈希表\n\nflag: green\n\ndate: '2019-6-5'\n---\n\n## 13.罗马数字转整数\n\n### 一 、题目\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n**字符**    |      **数值**\n|---|---\nI       |      1\nV            | 5\nX             |10\nL|             50\nC  |           100\nD     |        500\nM          |   1000\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n**示例 1:**\n\n**输入:** \"III\"\n**输出:** 3\n\n**示例 2:**\n\n**输入:** \"IV\"\n**输出:** 4\n\n**示例 3:**\n\n**输入:** \"IX\"\n**输出:** 9\n\n**示例 4:**\n\n**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n\n**示例 5:**\n\n**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.\n\n### 二、解法\n\n- 常规解法：\n第一次遍历一个字符把符合值加到结果里，第二次遍历两个字符从结果中减去符合值。\n```c\nclass Solution {\n    public int romanToInt(String s) {\n\tint result = 0;\n        for(int i = 0; i < s.length(); i++) {\n            switch(s.charAt(i)) {\n                case 'I': \n                    result += 1;\n                    break;\n                case 'V': \n                    result += 5;\n                    break;\n                case 'X':\n                    result += 10;\n                    break;\n                case 'L':\n                    result += 50;\n                    break;\n                case 'C':\n                    result += 100;\n                    break;\n                case 'D':\n                    result += 500;\n                    break;\n                case 'M':\n                    result += 1000;\n                    break;\n            }\n        }\n\tfor(int j = 0; j < s.length() - 1; j++) {\n            switch(\"\" + s.charAt(j) + s.charAt(j+1)) {\n                case \"IV\":\n                case \"IX\":\n                    result -= 2;\n                    break;\n                case \"XL\":\n                case \"XC\":\n                    result -= 20;\n                    break;\n                case \"CD\":\n                case \"CM\":\n                    result -= 200;\n                    break;\n            }\n        }\n        return result;\n    }\n}\n\n```\n\n\n- 哈希表解法：\n\n**最基础情况**\n试想一下，假如没有那几条特殊的规则，就是最简单的文字转换。那像XIV这样就可以直接转换为10+1+5=16\n\n注意：这是我们的整体思路，即字符的转换。\n\n**特殊情况**\n现在我们得知有三大种、六小种特殊情况，即：\n\nI(1) 和 V(5) 或 X(10) 组成 IV(4) 和 IX(9)\n\nX(10) 和 L(50) 或 C(100) 组成 XL(40) 和 XC(90)\n\nC(100) 和 D(500) 或 M(1000) 组成 CD(400) 和 CM(900)\n\n我把他们写成这样的形式相信大家一眼就可以看出来这其中的规律：**当右边的数是左边的数5倍或10倍的时候，左边的数就去相反数与其相加即可。**\n\n举个例子，IV其中V(5)是I(1)的五倍，那么这时候两者在一起，只需将I取值为相反数-1，然后再相加即可。那么XIV也就可以写成10+-1+5=14（可以看看后记哦）\n\n**需要注意的地方**\n因为需要用到前一个和后一个值做比较，所以需要考虑下标是否越界的问题，因此在遍历字符串时要在倒数第二个地方结束，即i只能取值0 <= i < s.length()-1。最后再加上字符串最后一位的值。\n\n```Java\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();//使用map把他们对应存储起来\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;          //存放结果\n        int current=0;     //第一个值\n        int next=0;       //后一个值\n        \n        for(int i=0;i<s.length()-1;++i){        //注意这里的s.length()-1是为了防止下标越界\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n\n            if(next/current==5||next/current==10){    //如果满足后一个是前一个5倍或10倍\n                res-=map.get(s.charAt(i));            //结果减掉当前值（相当于加了相反数）\n            }else{\n                res+=map.get(s.charAt(i));            //否则加上当前值\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));        //最后再加上字符串末尾的值\n        \n        return res;\n    }\n}\n```\n**后记**\n这里能有人会问，那万一是 V(5) 和 L(50) 放在一起呢？这也是十倍的关系啊！说实话一开始我也没有想到这一点，就是在写这篇文章的时候才发现的。但事实上这是不符合题目假设的，因为题目说明除了6种情况外，小的数必须在大的数右边。\n\n但本着杠精的思想，我提交了测试，发现LeetCode返回的结果是VL=45，这让我很惊讶！于是我大胆尝试测试了一个V(5)和C(100)组合是什么结果，结果更让我惊讶的是VC=95，但按照我之前写的思路，应该是VC=105。这样看来我萌生了一个大胆的想法，只要是左边的数比右边的数小，那么左边的数就要变成相反数，基于这一想法我修改代码，再次提交。再次惊讶，竟然运行时间比之前减小了20%。咱也不知道为啥，咱也不敢问。多半是判断条件减少了所以快了吧。不知道这种小数在大数左边的到底该怎么判定，不该返回0或者错误吗？😂\n\n这是修改后的代码（就改了个判断条件）\n```java\n\n\nclass Solution {\n    public int romanToInt(String s) {\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        \n        int res=0;\n        int current=0;\n        int next=0;\n        \n        for(int i=0;i<s.length()-1;++i){\n            current=map.get(s.charAt(i));\n            next=map.get(s.charAt(i+1));\n            if(next>current){\n                res-=map.get(s.charAt(i));\n            }else{\n                res+=map.get(s.charAt(i));\n            }\n        }\n        \n        res+=map.get(s.charAt(s.length()-1));\n        \n        return res;\n    }\n}\n\n```\n欢迎大家讨论这个VC的问题\n作者：godk-1\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhua-zhu-guan-jian-qu-bie-xiang-xi-fen-xi-ti-mu-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n",[[1561422751273,["GJX@GJXAIOU",[[1,38,"style: summer"]],[38,38],[51,51]]],[1561422759365,["GJX@GJXAIOU",[[1,19,"\n  "]],[16,16],[19,19]]],[1561422762766,["GJX@GJXAIOU",[[1,19,"- wan"]],[19,19],[24,24]]],[1561422763729,["GJX@GJXAIOU",[[-1,21,"wan"]],[24,24],[21,21]]],[1561422766632,["GJX@GJXAIOU",[[1,21,"完成"]],[21,21],[23,23]]],[1561422768693,["GJX@GJXAIOU",[[1,26,"\n  "]],[23,23],[26,26]]],[1561422770874,["GJX@GJXAIOU",[[1,26,"- 数组"]],[26,26],[30,30]]]],null,"GJX@GJXAIOU"]]}