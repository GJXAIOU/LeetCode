{"compress":true,"commitItems":[["72aee329-1490-46d0-90fd-8976db851761",1561528501779,"",[[1561528453728,["GJX@GJXAIOU",[[1,0,"# 665.非递减数列\n\n\n\n"]],[0,0],[14,14]]],[1561528473041,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1561528473156,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1561528474793,["GJX@GJXAIOU",[[1,0,"---\ntags: \n- 简单\n- 参考\n- 数组\n\nflag: green\nstyle: summer\ndate: '2019-6-25'\n---"]],[0,0],[74,74]]],[1561528477654,["GJX@GJXAIOU",[[-1,68,"5"]],[69,69],[68,68]]],[1561528478405,["GJX@GJXAIOU",[[1,68,"6"]],[68,68],[69,69]]],[1561528487453,["GJX@GJXAIOU",[[1,89,"## 一、题目"]],[89,89],[96,96]]],[1561528487714,["GJX@GJXAIOU",[[1,98,"\n"]],[96,96],[97,97]]],[1561528487824,["GJX@GJXAIOU",[[1,99,"\n"]],[97,97],[98,98]]],[1561528487940,["GJX@GJXAIOU",[[1,100,"\n"]],[98,98],[99,99]]],[1561528488077,["GJX@GJXAIOU",[[1,101,"\n"]],[99,99],[100,100]]],[1561528488175,["GJX@GJXAIOU",[[1,102,"\n"]],[100,100],[101,101]]],[1561528488309,["GJX@GJXAIOU",[[1,103,"\n"]],[101,101],[102,102]]],[1561528492403,["GJX@GJXAIOU",[[1,102,"## 二、解答"]],[102,102],[109,109]]],[1561528500429,["GJX@GJXAIOU",[[1,98,"给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。\n\n我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 <= i < n)，满足 array[i] <= array[i + 1]。\n\n示例 1:\n\n输入: [4,2,3]\n输出: True\n解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。\n示例 2:\n\n输入: [4,2,1]\n输出: False\n解释: 你不能在只改变一个元素的情况下将其变为非递减数列。\n说明:  n 的范围为 [1, 10,000]。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/non-decreasing-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[98,98],[477,477]]],[1561528522092,["GJX@GJXAIOU",[[1,122,"**"],[1,132,"**"]],[122,132],[122,136]]],[1561530176314,["GJX@GJXAIOU",[[1,494,"\n"]],[493,493],[494,494]]],[1561530176450,["GJX@GJXAIOU",[[1,495,"\n"]],[494,494],[495,495]]],[1561530176589,["GJX@GJXAIOU",[[1,496,"\n"]],[495,495],[496,496]]],[1561530177113,["GJX@GJXAIOU",[[-1,105," n "],[1,108," n "],[-1,128," "],[1,129," "],[-1,174," "],[1,175," "],[-1,183," "],[1,184," "],[-1,201," "],[1,202," "],[-1,351,"  "],[1,353,"  "],[-1,496,"\n"],[1,497,"-"]],[496,496],[497,497]]],[1561530181003,["GJX@GJXAIOU",[[1,497," 自己解答\n- "]],[497,497],[505,505]]],[1561530181421,["GJX@GJXAIOU",[[-1,503,"- "],[1,505,"\n\n"]],[505,505],[504,504]]],[1561530181986,["GJX@GJXAIOU",[[-1,504,"\n"]],[504,504],[503,503]]],[1561530183203,["GJX@GJXAIOU",[[-1,503,"\n"],[1,504,"`"]],[503,503],[504,504]]],[1561530183548,["GJX@GJXAIOU",[[1,504,"``"]],[504,504],[506,506]]],[1561530183572,["GJX@GJXAIOU",[[1,506,"language\n```\n"]],[506,506],[506,514]]],[1561530184723,["GJX@GJXAIOU",[[-1,506,"language"],[1,514,"j"]],[506,514],[507,507]]],[1561530185148,["GJX@GJXAIOU",[[1,507,"ava"]],[507,507],[510,510]]],[1561530185475,["GJX@GJXAIOU",[[1,511,"\n"]],[510,510],[511,511]]],[1561530185555,["GJX@GJXAIOU",[[1,512,"\n"]],[511,511],[512,512]]],[1561530186762,["GJX@GJXAIOU",[[1,512,"class Solution {\n    public boolean checkPossibility(int[] nums) {\n        //遍历一遍数组，如果后一个值小于前一个值，则计数+1\n\n        int length = nums.length;\n        int count = 0;\n\n        if (length < 3) {\n            return true;\n        }\n\n        if (nums[0] <= nums[1]) {\n            }else{\n            nums[0] = nums[1];\n                count++;\n            }\n        for (int i = 1; i < length - 1; i++) {\n            if (nums[i] > nums[i + 1]) {\n                count++;\n                if (count > 1) {\n                    return false;\n                }\n\n                if (nums[i + 1] > nums[i - 1]) {\n                    nums[i] = nums[i - 1];\n                }else{\n                    nums[i + 1] = nums[i];\n                }\n            }\n        }\n        \n        return true;\n    }\n}"]],[512,512],[1295,1295]]],[1561530191748,["GJX@GJXAIOU",[[1,494,"- jief"]],[494,494],[500,500]]],[1561530192562,["GJX@GJXAIOU",[[-1,495," jief"]],[500,500],[495,495]]],[1561530195215,["GJX@GJXAIOU",[[1,495,"解法"]],[495,495],[497,497]]],[1561530197062,["GJX@GJXAIOU",[[1,495," "]],[495,495],[496,496]]],[1561530199613,["GJX@GJXAIOU",[[1,498,"一："]],[498,498],[500,500]]],[1561530200883,["GJX@GJXAIOU",[[1,501,"- \n"]],[500,500],[503,503]]],[1561530201363,["GJX@GJXAIOU",[[-1,501,"- "]],[503,503],[501,501]]],[1561530210812,["GJX@GJXAIOU",[[1,1307,"\n"]],[1306,1306],[1307,1307]]],[1561530210941,["GJX@GJXAIOU",[[1,1308,"\n"]],[1307,1307],[1308,1308]]],[1561530211475,["GJX@GJXAIOU",[[1,1308,"执行用时 :3 ms, 在所有 Java 提交中击败了96.88%的用户\n\n内存消耗 :49.9 MB, 在所有 Java 提交中击败了32.45%的用户"]],[1308,1308],[1385,1385]]],[1561530215958,["GJX@GJXAIOU",[[1,1307,"复杂度"],[-1,1323," "],[1,1324," "],[-1,1328," "],[1,1329," "],[-1,1364," "],[1,1365," "],[-1,1369," "],[1,1370," "]],[1307,1307],[1310,1310]]],[1561530219365,["GJX@GJXAIOU",[[1,1310,"分析："]],[1310,1310],[1313,1313]]],[1561530220372,["GJX@GJXAIOU",[[1,1314,"\n"]],[1313,1313],[1314,1314]]],[1561530223794,["GJX@GJXAIOU",[[-1,1352,"\n"]],[1352,1352],[1352,1352]]],[1561530225715,["GJX@GJXAIOU",[[1,1307,"\n"]],[1307,1307],[1308,1308]]],[1561530271461,["GJX@GJXAIOU",[[1,501,"···"]],[501,501],[504,504]]],[1561530272809,["GJX@GJXAIOU",[[-1,501,"···"]],[504,504],[501,501]]],[1561530275386,["GJX@GJXAIOU",[[1,501,"```java"]],[501,501],[508,508]]],[1561530275642,["GJX@GJXAIOU",[[1,510,"\n"]],[508,508],[509,509]]],[1561530275772,["GJX@GJXAIOU",[[1,511,"\n"]],[509,509],[510,510]]],[1561530275923,["GJX@GJXAIOU",[[1,512,"\n"]],[510,510],[511,511]]],[1561530276906,["GJX@GJXAIOU",[[1,511,"```"]],[511,511],[514,514]]],[1561530278506,["GJX@GJXAIOU",[[1,509,"public static boolean checkPossibility(int[] nums){\n\t\tint count = 0;\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif(nums[i]<nums[i-1]){\n\t\t\t\tif(count==1) return false;\n\t\t\t\tif((i-2>=0)&&nums[i]<nums[i-2]){\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n作者：lin-120\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-ceng-pan-duan-by-lin-120/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[509,509],[933,933]]],[1561530281292,["GJX@GJXAIOU",[[1,940,"\n"]],[939,939],[940,940]]],[1561530281401,["GJX@GJXAIOU",[[1,941,"\n"]],[940,940],[941,941]]],[1561530316196,["GJX@GJXAIOU",[[1,940,"- liang"]],[940,940],[947,947]]],[1561530317297,["GJX@GJXAIOU",[[-1,942,"liang"]],[947,947],[942,942]]],[1561530318362,["GJX@GJXAIOU",[[1,942,"Lingyi"]],[942,942],[948,948]]],[1561530319346,["GJX@GJXAIOU",[[-1,942,"Lingyi"]],[948,948],[942,942]]],[1561530320066,["GJX@GJXAIOU",[[1,942,"Ling"]],[942,942],[946,946]]],[1561530320801,["GJX@GJXAIOU",[[-1,942,"Ling"]],[946,946],[942,942]]],[1561530321436,["GJX@GJXAIOU",[[1,942,"Lin"]],[942,942],[945,945]]],[1561530321995,["GJX@GJXAIOU",[[-1,942,"Lin"]],[945,945],[942,942]]],[1561530328204,["GJX@GJXAIOU",[[1,942,"另一种相似解法"]],[942,942],[949,949]]],[1561530328716,["GJX@GJXAIOU",[[1,950,"- \n"]],[949,949],[952,952]]],[1561530329356,["GJX@GJXAIOU",[[-1,950,"- "]],[952,952],[950,950]]],[1561530332530,["GJX@GJXAIOU",[[1,950,"```cpp"]],[950,950],[956,956]]],[1561530333001,["GJX@GJXAIOU",[[1,958,"\n"]],[956,956],[957,957]]],[1561530333122,["GJX@GJXAIOU",[[1,959,"\n"]],[957,957],[958,958]]],[1561530333354,["GJX@GJXAIOU",[[1,960,"\n"]],[958,958],[959,959]]],[1561530333482,["GJX@GJXAIOU",[[1,961,"\n"]],[959,959],[960,960]]],[1561530334188,["GJX@GJXAIOU",[[1,960,"```"]],[960,960],[963,963]]],[1561530336236,["GJX@GJXAIOU",[[1,957,"```\nbool checkPossibility(int* nums, int numsSize) {\n    // 数组个数小于2个 一定可以\n    if (numsSize < 3) {\n        return true;\n    }\n\n    // 思路如下：\n    // 如果出现 a[i] > a[i+1]   改变一个数 就面临两种选择\n    // 1\\. 把a[i]变大\n    // 2\\. 把a[i+1] 变小\n    // 这两种选择其实是有依据的 需要比较a[i-1] 与 a[i+1]的值\n    // eg.  ... 1 4 3 ...   只能选择把4变小   ... 3 4 1 ... 只能选择把1变大\n    // 改变完之后，记录改变次数，再检测是否升序\n    // 如果次数大于1，至少改了两次 返回false\n\n    // 先让前两个有序\n    // 因为没有左边没有数 所以对于前两个数来说，最佳选择就是吧 a[0] 变小\n    int changeCount = 0;\n    if (nums[0] > nums[1]) {\n        nums[0] = nums[1];\n        changeCount++;\n    }\n\n    for (int i = 1; i < numsSize - 1; i++) {\n        int right = nums[i+1];\n        if (nums[i] > right) {\n            changeCount++;\n            if (changeCount > 1) {\n                // 后面不用再看了\n                return false;\n            }\n            int left = nums[i-1];\n            if (left > right) {\n                nums[i+1] = nums[i];\n            } else {\n                nums[i] = left;\n            }\n        }\n    }\n    return true;\n}\n```"]],[957,957],[1960,1960]]],[1561530338813,["GJX@GJXAIOU",[[-1,957,"```\nbool checkPossibility(int* nums, int numsSize) {\n    // 数组个数小于2个 一定可以\n    if (numsSize < 3) {\n        return true;\n    }\n\n    // 思路如下：\n    // 如果出现 a[i] > a[i+1]   改变一个数 就面临两种选择\n    // 1\\. 把a[i]变大\n    // 2\\. 把a[i+1] 变小\n    // 这两种选择其实是有依据的 需要比较a[i-1] 与 a[i+1]的值\n    // eg.  ... 1 4 3 ...   只能选择把4变小   ... 3 4 1 ... 只能选择把1变大\n    // 改变完之后，记录改变次数，再检测是否升序\n    // 如果次数大于1，至少改了两次 返回false\n\n    // 先让前两个有序\n    // 因为没有左边没有数 所以对于前两个数来说，最佳选择就是吧 a[0] 变小\n    int changeCount = 0;\n    if (nums[0] > nums[1]) {\n        nums[0] = nums[1];\n        changeCount++;\n    }\n\n    for (int i = 1; i < numsSize - 1; i++) {\n        int right = nums[i+1];\n        if (nums[i] > right) {\n            changeCount++;\n            if (changeCount > 1) {\n                // 后面不用再看了\n                return false;\n            }\n            int left = nums[i-1];\n            if (left > right) {\n                nums[i+1] = nums[i];\n            } else {\n                nums[i] = left;\n            }\n        }\n    }\n    return true;\n}\n```"]],[1960,1960],[957,957]]],[1561530341564,["GJX@GJXAIOU",[[1,949,"()"]],[949,949],[951,951]]],[1561530344219,["GJX@GJXAIOU",[[1,950,"cpp"]],[950,950],[953,953]]],[1561530346762,["GJX@GJXAIOU",[[1,962,"```\nbool checkPossibility(int* nums, int numsSize) {\n    // 数组个数小于2个 一定可以\n    if (numsSize < 3) {\n        return true;\n    }\n\n    // 思路如下：\n    // 如果出现 a[i] > a[i+1]   改变一个数 就面临两种选择\n    // 1\\. 把a[i]变大\n    // 2\\. 把a[i+1] 变小\n    // 这两种选择其实是有依据的 需要比较a[i-1] 与 a[i+1]的值\n    // eg.  ... 1 4 3 ...   只能选择把4变小   ... 3 4 1 ... 只能选择把1变大\n    // 改变完之后，记录改变次数，再检测是否升序\n    // 如果次数大于1，至少改了两次 返回false\n\n    // 先让前两个有序\n    // 因为没有左边没有数 所以对于前两个数来说，最佳选择就是吧 a[0] 变小\n    int changeCount = 0;\n    if (nums[0] > nums[1]) {\n        nums[0] = nums[1];\n        changeCount++;\n    }\n\n    for (int i = 1; i < numsSize - 1; i++) {\n        int right = nums[i+1];\n        if (nums[i] > right) {\n            changeCount++;\n            if (changeCount > 1) {\n                // 后面不用再看了\n                return false;\n            }\n            int left = nums[i-1];\n            if (left > right) {\n                nums[i+1] = nums[i];\n            } else {\n                nums[i] = left;\n            }\n        }\n    }\n    return true;\n}\n```"]],[962,962],[1965,1965]]],[1561530350265,["GJX@GJXAIOU",[[-1,962,"```"]],[962,965],[962,962]]],[1561530363785,["GJX@GJXAIOU",[[-1,1965,"```"]],[1968,1968],[1965,1965]]],[1561530421771,["GJX@GJXAIOU",[[1,1965,"-"]],[1965,1965],[1966,1966]]],[1561530424859,["GJX@GJXAIOU",[[1,1966," lingyi"]],[1966,1966],[1973,1973]]],[1561530426824,["GJX@GJXAIOU",[[-1,1967,"lingyi"]],[1973,1973],[1967,1967]]],[1561530429236,["GJX@GJXAIOU",[[1,1967,"另一种："]],[1967,1967],[1971,1971]]],[1561530429558,["GJX@GJXAIOU",[[1,1972,"- \n"]],[1971,1971],[1974,1974]]],[1561530430421,["GJX@GJXAIOU",[[-1,1972,"- "]],[1974,1974],[1972,1972]]],[1561530434666,["GJX@GJXAIOU",[[1,1972,"```java"]],[1972,1972],[1979,1979]]],[1561530434770,["GJX@GJXAIOU",[[1,1981,"\n"]],[1979,1979],[1980,1980]]],[1561530434952,["GJX@GJXAIOU",[[1,1982,"\n"]],[1980,1980],[1981,1981]]],[1561530437674,["GJX@GJXAIOU",[[1,1981,"```"]],[1981,1981],[1984,1984]]],[1561530439219,["GJX@GJXAIOU",[[1,1980,"```\npublic static boolean checkPossibility(int[] nums){\n\t\tint count = 0;\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif(nums[i]<nums[i-1]){\n\t\t\t\tif(count==1) return false;\n\t\t\t\tif((i-2>=0)&&nums[i]<nums[i-2]){\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n```"]],[1980,1980],[2264,2264]]],[1561530441275,["GJX@GJXAIOU",[[-1,1980,"```"]],[1980,1983],[1980,1980]]],[1561530443572,["GJX@GJXAIOU",[[-1,2258,"```"]],[2258,2261],[2258,2258]]],[1561530472426,["GJX@GJXAIOU",[[1,2504,"\n"]],[2503,2503],[2504,2504]]],[1561530475229,["GJX@GJXAIOU",[[1,2504,"// 思路如下：\n    // 如果出现 a[i] > a[i+1]   改变一个数 就面临两种选择\n    // 1\\. 把a[i]变大\n    // 2\\. 把a[i+1] 变小\n    // 这两种选择其实是有依据的 需要比较a[i-1] 与 a[i+1]的值\n    // eg.  ... 1 4 3 ...   只能选择把4变小   ... 3 4 1 ... 只能选择把1变大\n    // 改变完之后，记录改变次数，再检测是否升序\n    // 如果次数大于1，至少改了两次 返回false\n\n    // 先让前两个有序\n    // 因为没有左边没有数 所以对于前两个数来说，最佳选择就是吧 a[0] 变小"]],[2504,2504],[2817,2817]]],[1561530480701,["GJX@GJXAIOU",[[1,2441,"        、、"]],[2441,2441],[2451,2451]]],[1561530481320,["GJX@GJXAIOU",[[-1,2449,"、、"]],[2451,2451],[2449,2449]]],[1561530492604,["GJX@GJXAIOU",[[1,2449,"//如果只有两个元素一定成立"]],[2449,2449],[2463,2463]]],[1561530500704,["GJX@GJXAIOU",[[1,2526,"  "],[1,2535,"  "],[1,2577,"  "],[1,2600,"  "],[1,2618,"  "],[1,2660," "],[1,2664," "],[1,2726,"  "],[1,2750,"  "],[1,2780,"  "],[1,2781,"  "],[1,2796,"  "]],[2526,2839],[2526,2861]]],[1561530502436,["GJX@GJXAIOU",[[1,2528,"  "],[1,2537,"  "],[1,2581,"  "],[1,2608,"  "],[1,2626,"  "],[1,2670," "],[1,2676," "],[1,2740,"  "],[1,2764,"  "],[1,2796," "],[1,2798," "],[1,2799,"  "],[1,2816,"  "]],[2526,2861],[2526,2883]]],[1561530516984,["GJX@GJXAIOU",[[-1,940,"- 另一种相似解法(cpp)\n```cpp\n\nbool checkPossibility(int* nums, int numsSize) {\n    // 数组个数小于2个 一定可以\n    if (numsSize < 3) {\n        return true;\n    }\n\n    // 思路如下：\n    // 如果出现 a[i] > a[i+1]   改变一个数 就面临两种选择\n    // 1\\. 把a[i]变大\n    // 2\\. 把a[i+1] 变小\n    // 这两种选择其实是有依据的 需要比较a[i-1] 与 a[i+1]的值\n    // eg.  ... 1 4 3 ...   只能选择把4变小   ... 3 4 1 ... 只能选择把1变大\n    // 改变完之后，记录改变次数，再检测是否升序\n    // 如果次数大于1，至少改了两次 返回false\n\n    // 先让前两个有序\n    // 因为没有左边没有数 所以对于前两个数来说，最佳选择就是吧 a[0] 变小\n    int changeCount = 0;\n    if (nums[0] > nums[1]) {\n        nums[0] = nums[1];\n        changeCount++;\n    }\n\n    for (int i = 1; i < numsSize - 1; i++) {\n        int right = nums[i+1];\n        if (nums[i] > right) {\n            changeCount++;\n            if (changeCount > 1) {\n                // 后面不用再看了\n                return false;\n            }\n            int left = nums[i-1];\n            if (left > right) {\n                nums[i+1] = nums[i];\n            } else {\n                nums[i] = left;\n            }\n        }\n    }\n    return true;\n}\n```"]],[940,1962],[940,940]]],[1561530594547,["GJX@GJXAIOU",[[1,1870,"\n        "]],[1861,1861],[1870,1870]]],[1561530594941,["GJX@GJXAIOU",[[-1,1862,"        "],[1,1870,"\n"]],[1870,1870],[1863,1863]]],[1561530599073,["GJX@GJXAIOU",[[1,1863,"//```\n如果nums[i]>nums[i+1]，说明要调整，【敲黑板】调整的原则是尽量把大数往小里调，为后面排序留空间。所以先看看能不能调小i（因为i元素较大），实在不行则调大i+1\n```"]],[1863,1863],[1960,1960]]],[1561530601764,["GJX@GJXAIOU",[[-1,1866,"``"]],[1868,1868],[1866,1866]]],[1561530602387,["GJX@GJXAIOU",[[-1,1865,"`"]],[1866,1866],[1865,1865]]],[1561530603512,["GJX@GJXAIOU",[[-1,1954,"```"]],[1957,1957],[1954,1954]]],[1561530803226,["GJX@GJXAIOU",[[1,786,"```"]],[786,786],[789,789]]],[1561530804935,["GJX@GJXAIOU",[[-1,938,"```"]],[938,941],[938,938]]],[1561530924077,["GJX@GJXAIOU",[[1,500," ()"]],[500,500],[503,503]]],[1561530926059,["GJX@GJXAIOU",[[1,502,"you"]],[502,502],[505,505]]],[1561530926650,["GJX@GJXAIOU",[[-1,502,"you"]],[505,505],[502,502]]],[1561530935510,["GJX@GJXAIOU",[[1,502,"有问题待作者回复"]],[502,502],[510,510]]],[1561530940551,["GJX@GJXAIOU",[[-1,969,"\n"]],[969,969],[968,968]]],[1561530957146,["GJX@GJXAIOU",[[-1,969,"public static boolean checkPossibility(int[] nums){\n\t\tint count = 0;\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif(nums[i]<nums[i-1]){\n\t\t\t\tif(count==1) return false;\n\t\t\t\tif((i-2>=0)&&nums[i]<nums[i-2]){\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}"]],[969,1245],[969,969]]],[1561530958658,["GJX@GJXAIOU",[[-1,970,"\n"]],[970,970],[969,969]]],[1561531437731,["GJX@GJXAIOU",[[-1,954,"- 另一种：\n```java\n\n```\n"]],[953,973],[953,953]]],[1561531437949,["GJX@GJXAIOU",[[-1,954,"\n"]],[953,953],[952,952]]],[1561531438308,["GJX@GJXAIOU",[[-1,953,"\n"]],[952,952],[951,951]]],[1561531438491,["GJX@GJXAIOU",[[-1,952,"\n"]],[951,951],[950,950]]],[1561531438691,["GJX@GJXAIOU",[[-1,951,"\n"]],[950,950],[949,949]]],[1561531438877,["GJX@GJXAIOU",[[-1,950,"\n"]],[949,949],[948,948]]]],null,"GJX@GJXAIOU"],["c101943b-8218-4729-8c33-1b172abe7388",1561643200482,"---\ntags: \n- 简单\n- 参考\n- 数组\n\nflag: green\nstyle: summer\ndate: '2019-6-26'\n---\n\n# 665.非递减数列\n\n## 一、题目\n\n给定一个长度为 n 的整数数组，你的任务是判断在**最多改变 1 个元素**的情况下，该数组能否变成一个非递减数列。\n\n我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 <= i < n)，满足 array[i] <= array[i + 1]。\n\n示例 1:\n\n输入: [4,2,3]\n输出: True\n解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。\n示例 2:\n\n输入: [4,2,1]\n输出: False\n解释: 你不能在只改变一个元素的情况下将其变为非递减数列。\n说明:  n 的范围为 [1, 10,000]。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/non-decreasing-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n\n## 二、解答\n\n- 解法一： (有问题待作者回复)\n```java\npublic static boolean checkPossibility(int[] nums){\n\t\tint count = 0;\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif(nums[i]<nums[i-1]){\n\t\t\t\tif(count==1) return false;\n\t\t\t\tif((i-2>=0)&&nums[i]<nums[i-2]){\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n```\n作者：lin-120\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-ceng-pan-duan-by-lin-120/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n- 自己解答\n```java\n\nclass Solution {\n    public boolean checkPossibility(int[] nums) {\n        //遍历一遍数组，如果后一个值小于前一个值，则计数+1\n\n        int length = nums.length;\n        int count = 0;\n        //如果只有两个元素一定成立\n        if (length < 3) {\n            return true;\n        }\n\n    // 思路如下：\n        // 如果出现 a[i] > a[i+1]   改变一个数 就面临两种选择\n        // 1\\. 把a[i]变大\n        // 2\\. 把a[i+1] 变小\n        // 这两种选择其实是有依据的 需要比较a[i-1] 与 a[i+1]的值\n        // eg.  ... 1 4 3 ...   只能选择把4变小   ... 3 4 1 ... 只能选择把1变大\n        // 改变完之后，记录改变次数，再检测是否升序\n        // 如果次数大于1，至少改了两次 返回false\n    \n        // 先让前两个有序\n        // 因为没有左边没有数 所以对于前两个数来说，最佳选择就是吧 a[0] 变小\n\n//\n如果nums[i]>nums[i+1]，说明要调整，【敲黑板】调整的原则是尽量把大数往小里调，为后面排序留空间。所以先看看能不能调小i（因为i元素较大），实在不行则调大i+1\n\n        if (nums[0] <= nums[1]) {\n            }else{\n            nums[0] = nums[1];\n                count++;\n            }\n        for (int i = 1; i < length - 1; i++) {\n            if (nums[i] > nums[i + 1]) {\n                count++;\n                if (count > 1) {\n                    return false;\n                }\n\n                if (nums[i + 1] > nums[i - 1]) {\n                    nums[i] = nums[i - 1];\n                }else{\n                    nums[i + 1] = nums[i];\n                }\n            }\n        }\n        \n        return true;\n    }\n}\n```\n\n复杂度分析：\n\n执行用时 :3 ms, 在所有 Java 提交中击败了96.88%的用户\n内存消耗 :49.9 MB, 在所有 Java 提交中击败了32.45%的用户\n",[[1561643144624,["GJX@GJXAIOU",[[1,950,"\n"]],[948,948],[949,949]]],[1561643144748,["GJX@GJXAIOU",[[1,951,"\n"]],[949,949],[950,950]]],[1561643146422,["GJX@GJXAIOU",[[1,950,"---"]],[950,950],[953,953]]],[1561643147700,["GJX@GJXAIOU",[[-1,951,"--"]],[953,953],[951,951]]],[1561643163540,["GJX@GJXAIOU",[[1,951," lingyige"]],[951,951],[960,960]]],[1561643165818,["GJX@GJXAIOU",[[-1,952,"lingyige"]],[960,960],[952,952]]],[1561643168542,["GJX@GJXAIOU",[[1,952,"另一个解答"]],[952,952],[957,957]]],[1561643169178,["GJX@GJXAIOU",[[1,958,"- \n"]],[957,957],[960,960]]],[1561643170188,["GJX@GJXAIOU",[[-1,958,"- "]],[960,960],[958,958]]],[1561643171010,["GJX@GJXAIOU",[[1,960,"\n"]],[958,958],[959,959]]],[1561643173315,["GJX@GJXAIOU",[[1,959,"```java"]],[959,959],[966,966]]],[1561643173379,["GJX@GJXAIOU",[[1,968,"\n"]],[966,966],[967,967]]],[1561643174554,["GJX@GJXAIOU",[[1,969,"\n"]],[967,967],[968,968]]],[1561643174674,["GJX@GJXAIOU",[[1,970,"\n"]],[968,968],[969,969]]],[1561643175211,["GJX@GJXAIOU",[[1,969,"```"]],[969,969],[972,972]]],[1561643176731,["GJX@GJXAIOU",[[1,967,"class Solution {\n    public static boolean checkPossibility(int[] nums){\n\t\tint count = 0;\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif(nums[i]<nums[i-1]){\n\t\t\t\tif(count==1) return false;\n\t\t\t\tif((i-2>=0)&&nums[i]<nums[i-2]){\n\t\t\t\t\tnums[i]=nums[i-1];\n\t\t\t\t}\n                count++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\n作者：lin-120\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-ceng-pan-duan-by-lin-120/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[967,967],[1424,1424]]],[1561643182666,["GJX@GJXAIOU",[[-1,1426,"```"]],[1426,1429],[1426,1426]]],[1561643184394,["GJX@GJXAIOU",[[1,1277,"```"]],[1277,1277],[1280,1280]]],[1561643230685,["GJX@GJXAIOU",[[1,1431,"\n"]],[1427,1427],[1428,1428]]],[1561643230819,["GJX@GJXAIOU",[[1,1432,"\n"]],[1428,1428],[1429,1429]]],[1561643234357,["GJX@GJXAIOU",[[1,1429,"- fu"]],[1429,1429],[1433,1433]]],[1561643235523,["GJX@GJXAIOU",[[-1,1429,"- fu"]],[1433,1433],[1429,1429]]],[1561643238444,["GJX@GJXAIOU",[[1,1281,"\n"]],[1280,1280],[1281,1281]]],[1561643238587,["GJX@GJXAIOU",[[1,1282,"\n"]],[1281,1281],[1282,1282]]],[1561643239734,["GJX@GJXAIOU",[[1,1281,"执行用时 :3 ms, 在所有 Java 提交中击败了96.91%的用户\n\n内存消耗 :53.2 MB, 在所有 Java 提交中击败了5.57%的用户"]],[1281,1281],[1357,1357]]],[1561643242395,["GJX@GJXAIOU",[[-1,1318,"\n"]],[1318,1318],[1318,1318]]],[1561643244027,["GJX@GJXAIOU",[[1,1281,"\n"]],[1281,1281],[1282,1282]]]],null,"GJX@GJXAIOU"]]}