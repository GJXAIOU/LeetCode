{"compress":true,"commitItems":[["02e75e5a-0442-4163-b5ec-e8d72e2cb008",1560148511331,"",[[1560148492204,["GJX@GJXAIOU",[[1,0,"# 999.车的可用捕获量\n\n\n\n"]],[0,0],[16,16]]],[1560148495018,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1560148495161,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1560148495282,["GJX@GJXAIOU",[[1,2,"\n"]],[2,2],[3,3]]],[1560148497730,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1560148497852,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1560148498010,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1560148498033,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1560148501834,["GJX@GJXAIOU",[[1,4,"tags: "]],[4,4],[10,10]]],[1560148502275,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1560148504065,["GJX@GJXAIOU",[[1,11,"- jian"]],[11,11],[17,17]]],[1560148505175,["GJX@GJXAIOU",[[-1,13,"jian"]],[17,17],[13,13]]],[1560148506750,["GJX@GJXAIOU",[[1,13,"简单"]],[13,13],[15,15]]],[1560148507051,["GJX@GJXAIOU",[[1,16,"\n"]],[15,15],[16,16]]],[1560148507930,["GJX@GJXAIOU",[[1,16,"- "]],[16,16],[18,18]]],[1560148508241,["GJX@GJXAIOU",[[1,19,"\n"]],[18,18],[19,19]]],[1560148510222,["GJX@GJXAIOU",[[1,19,"- 数组"]],[19,19],[23,23]]],[1560148510602,["GJX@GJXAIOU",[[1,24,"\n"]],[23,23],[24,24]]],[1560148511649,["GJX@GJXAIOU",[[1,25,"\n"]],[24,24],[25,25]]],[1560148516139,["GJX@GJXAIOU",[[1,25,"flag："]],[25,25],[30,30]]],[1560148516979,["GJX@GJXAIOU",[[-1,29,"："]],[30,30],[29,29]]],[1560148517915,["GJX@GJXAIOU",[[1,29,"："]],[29,29],[30,30]]],[1560148518705,["GJX@GJXAIOU",[[-1,29,"："]],[30,30],[29,29]]],[1560148522370,["GJX@GJXAIOU",[[1,29,": green"]],[29,29],[36,36]]],[1560148523067,["GJX@GJXAIOU",[[1,37,"\n"]],[36,36],[37,37]]],[1560148529221,["GJX@GJXAIOU",[[1,38,"\n"]],[37,37],[38,38]]],[1560148546409,["GJX@GJXAIOU",[[1,38,"data: '2019-6-10'"]],[38,38],[55,55]]],[1560148554569,["GJX@GJXAIOU",[[1,78,"## yi"]],[78,78],[83,83]]],[1560148555209,["GJX@GJXAIOU",[[-1,81,"yi"]],[83,83],[81,81]]],[1560148557597,["GJX@GJXAIOU",[[1,81,"一、数组"]],[81,81],[85,85]]],[1560148557890,["GJX@GJXAIOU",[[1,87,"\n"]],[85,85],[86,86]]],[1560148558040,["GJX@GJXAIOU",[[1,88,"\n"]],[86,86],[87,87]]],[1560148558177,["GJX@GJXAIOU",[[1,89,"\n"]],[87,87],[88,88]]],[1560148558367,["GJX@GJXAIOU",[[1,90,"\n"]],[88,88],[89,89]]],[1560148561738,["GJX@GJXAIOU",[[1,89,"## 二、"]],[89,89],[94,94]]],[1560148572228,["GJX@GJXAIOU",[[1,94,"解答"]],[94,94],[96,96]]],[1560148575257,["GJX@GJXAIOU",[[-1,83,"数组"]],[85,85],[83,83]]],[1560148577150,["GJX@GJXAIOU",[[1,83,"题目"]],[83,83],[85,85]]],[1560148577850,["GJX@GJXAIOU",[[1,89,"\n"]],[85,85],[86,86]]],[1560148586630,["GJX@GJXAIOU",[[1,87,"在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。\n\n车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。\n\n返回车能够在一次移动中捕获到的卒的数量。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/available-captures-for-rook\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[87,87],[441,441]]],[1560148591099,["GJX@GJXAIOU",[[-1,327,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/available-captures-for-rook\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[327,441],[327,327]]],[1560148606634,["GJX@GJXAIOU",[[1,327,"示例 1：\n\n\n\n输入：[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n输出：3\n解释：\n在本例中，车能够捕获所有的卒。\n示例 2：\n\n\n\n输入：[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n输出：0\n解释：\n象阻止了车捕获任何卒。\n示例 3：\n\n\n\n输入：[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n输出：3\n解释： \n车可以捕获位置 b5，d6 和 f5 的卒。\n \n\n提示：\n\nboard.length == board[i].length == 8\nboard[i][j] 可以是 'R'，'.'，'B' 或 'p'\n只有一个格子上存在 board[i][j] == 'R'\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/available-captures-for-rook\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[327,327],[1487,1487]]],[1560148648861,["GJX@GJXAIOU",[[1,334,"![1253_example_1_improved]($resource/1253_example_1_improved.PNG)"]],[334,334],[400,400]]],[1560148655060,["GJX@GJXAIOU",[[1,703,"\n"]],[702,702],[703,703]]],[1560148655627,["GJX@GJXAIOU",[[1,704,"\n"]],[703,703],[704,704]]],[1560148661641,["GJX@GJXAIOU",[[1,712,"![1253_example_2_improved]($resource/1253_example_2_improved.PNG)"]],[712,712],[778,778]]],[1560148664892,["GJX@GJXAIOU",[[1,1077,"\n"]],[1076,1076],[1077,1077]]],[1560148672353,["GJX@GJXAIOU",[[1,1085,"![1253_example_3_improved]($resource/1253_example_3_improved.PNG)"]],[1085,1085],[1151,1151]]],[1560148675319,["GJX@GJXAIOU",[[1,1078,"-"],[-1,1462," "],[1,1463," "],[-1,1522," "],[1,1523," "],[-1,1534," 或 "],[1,1537," 或 "],[-1,1550," "],[1,1551," "]],[1078,1078],[1079,1079]]],[1560148675465,["GJX@GJXAIOU",[[1,1079," "]],[1079,1079],[1080,1080]]],[1560148679521,["GJX@GJXAIOU",[[1,705,"- "]],[705,705],[707,707]]],[1560148682523,["GJX@GJXAIOU",[[1,327,"- "]],[327,327],[329,329]]],[1560148695752,["GJX@GJXAIOU",[[1,406,"\n"]],[406,406],[407,407]]],[1560148699491,["GJX@GJXAIOU",[[1,442,"\n"]],[442,442],[443,443]]],[1560148702062,["GJX@GJXAIOU",[[1,477,"\n"]],[477,477],[478,478]]],[1560148703853,["GJX@GJXAIOU",[[1,512,"\n"]],[512,512],[513,513]]],[1560148710883,["GJX@GJXAIOU",[[1,547,"\n"]],[547,547],[548,548]]],[1560148712908,["GJX@GJXAIOU",[[1,582,"\n"]],[582,582],[583,583]]],[1560148715178,["GJX@GJXAIOU",[[1,617,"\n"]],[617,617],[618,618]]],[1560148717752,["GJX@GJXAIOU",[[1,652,"\n"]],[652,652],[653,653]]],[1560148720108,["GJX@GJXAIOU",[[1,688,"\n"]],[687,687],[688,688]]],[1560148729937,["GJX@GJXAIOU",[[1,1000,"\n"]],[1000,1000],[1001,1001]]],[1560148731751,["GJX@GJXAIOU",[[1,795,"\n"]],[795,795],[796,796]]],[1560148734472,["GJX@GJXAIOU",[[1,831,"\n"]],[831,831],[832,832]]],[1560148737173,["GJX@GJXAIOU",[[1,1037,"\n"]],[1037,1037],[1038,1038]]],[1560148742315,["GJX@GJXAIOU",[[1,1243,"\n"]],[1243,1243],[1244,1244]]],[1560148743410,["GJX@GJXAIOU",[[1,1174,"\n"]],[1174,1174],[1175,1175]]],[1560148745000,["GJX@GJXAIOU",[[1,1210,"\n"]],[1210,1210],[1211,1211]]],[1560148746654,["GJX@GJXAIOU",[[1,1280,"\n"]],[1280,1280],[1281,1281]]],[1560148748336,["GJX@GJXAIOU",[[1,1315,"\n"]],[1315,1315],[1316,1316]]],[1560148749474,["GJX@GJXAIOU",[[1,1350,"\n"]],[1350,1350],[1351,1351]]],[1560148750647,["GJX@GJXAIOU",[[1,1385,"\n"]],[1385,1385],[1386,1386]]],[1560148752321,["GJX@GJXAIOU",[[1,1420,"\n"]],[1420,1420],[1421,1421]]],[1560149112273,["GJX@GJXAIOU",[[-1,1598,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/available-captures-for-rook\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[1598,1712],[1598,1598]]],[1560149975397,["GJX@GJXAIOU",[[1,1610,"\n"]],[1609,1609],[1610,1610]]],[1560149975535,["GJX@GJXAIOU",[[1,1611,"\n"]],[1610,1610],[1611,1611]]],[1560149976538,["GJX@GJXAIOU",[[-1,1611,"\n"],[1,1612,"-"]],[1611,1611],[1612,1612]]],[1560149983817,["GJX@GJXAIOU",[[1,1612," 解答一：\n- 解答二："]],[1612,1612],[1624,1624]]],[1560149985375,["GJX@GJXAIOU",[[1,1620,"\n- "]],[1617,1617],[1620,1620]]],[1560149985513,["GJX@GJXAIOU",[[-1,1618,"- "]],[1620,1620],[1619,1619]]],[1560149987713,["GJX@GJXAIOU",[[1,1618,"···"]],[1618,1618],[1621,1621]]],[1560149989343,["GJX@GJXAIOU",[[-1,1618,"···"]],[1621,1621],[1618,1618]]],[1560149990127,["GJX@GJXAIOU",[[1,1618,"```"]],[1618,1618],[1621,1621]]],[1560149990154,["GJX@GJXAIOU",[[1,1621,"language\n```\n"]],[1621,1621],[1621,1629]]],[1560149991031,["GJX@GJXAIOU",[[-1,1621,"language"],[1,1629,"j"]],[1621,1629],[1622,1622]]],[1560149991447,["GJX@GJXAIOU",[[1,1622,"ava"]],[1622,1622],[1625,1625]]],[1560149991553,["GJX@GJXAIOU",[[1,1626,"\n"]],[1625,1625],[1626,1626]]],[1560149992851,["GJX@GJXAIOU",[[1,1626,"```\nclass Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}\n```"]],[1626,1626],[2942,2942]]],[1560149995663,["GJX@GJXAIOU",[[-1,1626,"```\nclass Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}\n```"]],[2942,2942],[1626,1626]]],[1560149997617,["GJX@GJXAIOU",[[1,1626,"```\nclass Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}\n```"]],[1626,1626],[2942,2942]]],[1560149999753,["GJX@GJXAIOU",[[-1,1626,"```\nclass Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}\n```"]],[2942,2942],[1626,1626]]],[1560150001677,["GJX@GJXAIOU",[[1,1627,"\n"]],[1626,1626],[1627,1627]]],[1560150003268,["GJX@GJXAIOU",[[1,1626,"```\nclass Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}\n```"]],[1626,1626],[2942,2942]]],[1560150008711,["GJX@GJXAIOU",[[-1,2939,"```\n\n```"]],[2939,2947],[2939,2939]]],[1560150013432,["GJX@GJXAIOU",[[-1,1630,"class Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}"]],[1630,2938],[1630,1630]]],[1560150015379,["GJX@GJXAIOU",[[1,1626,"\n"]],[1625,1625],[1626,1626]]],[1560150015782,["GJX@GJXAIOU",[[1,1626,"class Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}"]],[1626,1626],[2934,2934]]],[1560150020327,["GJX@GJXAIOU",[[-1,2941,"\n"]],[2941,2941],[2940,2940]]],[1560150023446,["GJX@GJXAIOU",[[1,2947,"\n- "]],[2947,2947],[2950,2950]]],[1560150023577,["GJX@GJXAIOU",[[-1,2948,"- "],[1,2950,"\n\n"]],[2950,2950],[2949,2949]]],[1560150025368,["GJX@GJXAIOU",[[-1,2949,"\n"],[1,2950,"·"]],[2949,2949],[2950,2950]]],[1560150025720,["GJX@GJXAIOU",[[1,2950,"··"]],[2950,2950],[2952,2952]]],[1560150026865,["GJX@GJXAIOU",[[-1,2950,"··"]],[2952,2952],[2950,2950]]],[1560150027035,["GJX@GJXAIOU",[[-1,2949,"·"],[1,2950,"\n"]],[2950,2950],[2949,2949]]],[1560150027531,["GJX@GJXAIOU",[[-1,2949,"\n"]],[2949,2949],[2948,2948]]],[1560150028359,["GJX@GJXAIOU",[[-1,2948,"\n"],[1,2949,"`"]],[2948,2948],[2949,2949]]],[1560150028735,["GJX@GJXAIOU",[[1,2949,"``"]],[2949,2949],[2951,2951]]],[1560150028762,["GJX@GJXAIOU",[[1,2951,"language\n```\n"]],[2951,2951],[2951,2959]]],[1560150030136,["GJX@GJXAIOU",[[-1,2951,"language"],[1,2959,"j"]],[2951,2959],[2952,2952]]],[1560150030575,["GJX@GJXAIOU",[[1,2952,"ava"]],[2952,2952],[2955,2955]]],[1560150031291,["GJX@GJXAIOU",[[1,2956,"\n"]],[2955,2955],[2956,2956]]],[1560150056078,["GJX@GJXAIOU",[[1,2957,"\n"]],[2956,2956],[2957,2957]]],[1560150057439,["GJX@GJXAIOU",[[1,2956,"```\npublic int numRookCaptures(char[][] board) {\n\t\tint ri = 0, rj = 0;\n\t\touter: for (int i = 0; i < board.length; i++) {\n\t\t\tfor (int j = 0; j < board.length; j++) {\n\t\t\t\tif (board[i][j] == 'R') {\n\t\t\t\t\tri = i;\n\t\t\t\t\trj = j;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tint[][] dir = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint x = ri + dir[i][0];\n\t\t\tint y = rj + dir[i][1];\n\t\t\twhile (x >= 0 && x < 8 && y >= 0 && y < 8) {\n\t\t\t\tif (board[x][y] != '.') {\n\t\t\t\t\tif (board[x][y] == 'p') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx += dir[i][0];\n                y += dir[i][1];\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}\n```"]],[2956,2956],[3604,3604]]],[1560150060742,["GJX@GJXAIOU",[[-1,3601,"```\n\n```"]],[3601,3609],[3601,3601]]],[1560150064767,["GJX@GJXAIOU",[[-1,2960,"public int numRookCaptures(char[][] board) {\n\t\tint ri = 0, rj = 0;\n\t\touter: for (int i = 0; i < board.length; i++) {\n\t\t\tfor (int j = 0; j < board.length; j++) {\n\t\t\t\tif (board[i][j] == 'R') {\n\t\t\t\t\tri = i;\n\t\t\t\t\trj = j;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tint[][] dir = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint x = ri + dir[i][0];\n\t\t\tint y = rj + dir[i][1];\n\t\t\twhile (x >= 0 && x < 8 && y >= 0 && y < 8) {\n\t\t\t\tif (board[x][y] != '.') {\n\t\t\t\t\tif (board[x][y] == 'p') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx += dir[i][0];\n                y += dir[i][1];\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}"]],[2960,3600],[2960,2960]]],[1560150066656,["GJX@GJXAIOU",[[1,2956,"\n"]],[2955,2955],[2956,2956]]],[1560150066790,["GJX@GJXAIOU",[[1,2957,"\n"]],[2956,2956],[2957,2957]]],[1560150067165,["GJX@GJXAIOU",[[1,2957,"public int numRookCaptures(char[][] board) {\n\t\tint ri = 0, rj = 0;\n\t\touter: for (int i = 0; i < board.length; i++) {\n\t\t\tfor (int j = 0; j < board.length; j++) {\n\t\t\t\tif (board[i][j] == 'R') {\n\t\t\t\t\tri = i;\n\t\t\t\t\trj = j;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tint[][] dir = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint x = ri + dir[i][0];\n\t\t\tint y = rj + dir[i][1];\n\t\t\twhile (x >= 0 && x < 8 && y >= 0 && y < 8) {\n\t\t\t\tif (board[x][y] != '.') {\n\t\t\t\t\tif (board[x][y] == 'p') {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tx += dir[i][0];\n                y += dir[i][1];\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}"]],[2957,2957],[3597,3597]]],[1560150133007,["GJX@GJXAIOU",[[1,18,"yousi"]],[18,18],[23,23]]],[1560150134264,["GJX@GJXAIOU",[[-1,18,"yousi"]],[23,23],[18,18]]],[1560150138754,["GJX@GJXAIOU",[[1,18,"有思路不会"]],[18,18],[23,23]]],[1560153331707,["GJX@GJXAIOU",[[1,2962,"class Solution {\n    "],[-1,3007,"\t\t"],[1,3009,"        //首先得到车的位置\n        "],[-1,3013,"ri"],[1,3015,"xR"],[-1,3020," rj"],[1,3023,"yR"],[-1,3029,"\t\touter:"],[1,3037,"        int N = board.length;\n\n       "],[-1,3058,"board.length"],[1,3070,"N"],[1,3075," "],[-1,3079,"\t\t\t"],[1,3082,"            "],[-1,3102,"board.length"],[1,3114,"N"],[-1,3123,"\t\t\t\t"],[1,3127,"                "],[-1,3153,"\t\t\t\t\tri"],[1,3160,"                    xR"],[-1,3166,"\t\t\t\t\trj"],[1,3173,"                    yR"],[-1,3179,"\t\t\t\t\t"],[1,3184,"                    "],[-1,3189," outer"],[-1,3197,"\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\t"],[1,3231,"                }\n            }\n        }\n\n\n        //使车可以上下左右移动\n        "],[-1,3239,"dir = { { "],[1,3249,"num = new int[][]{{"],[-1,3251," "],[-1,3253," "],[-1,3256," "],[-1,3258," "],[-1,3261," "],[-1,3263," "],[-1,3266," "],[-1,3268," "],[-1,3271," "],[-1,3274," "],[-1,3277," "],[-1,3279," "],[-1,3283," 0 } };\n\t\t"],[1,3293,"0}};\n        int count = 0;\n\n        "],[-1,3323,"\t\t\t"],[1,3326,"            "],[-1,3334,"ri + dir"],[1,3342,"xR + num"],[-1,3350,"\t\t\t"],[1,3353,"            "],[-1,3361,"rj + dir"],[1,3369,"yR + num"],[-1,3377,"\t\t\t"],[1,3380,"\n            "],[-1,3385," "],[-1,3390,"="],[-1,3409,"="],[-1,3422," "],[-1,3425,"\t\t\t\t"],[1,3429,"                "],[-1,3455,"\t\t\t\t\t"],[1,3460,"                    "],[-1,3486,"\t\t\t\t\t\tc"],[1,3493,"                        cou"],[-1,3499,"\t\t\t\t\t}\n\t\t\t\t\t"],[1,3511,"                    }\n                    "],[-1,3518,"\t\t\t\t}\n\t\t\t\t"],[1,3528,"                }else{\n                    "],[-1,3533,"dir"],[1,3536,"num"],[1,3560,"    "],[-1,3565,"dir"],[1,3568,"num"],[-1,3576,"\t\t\t}\n\t\t}\n\n\t\t"],[1,3588,"                }\n            }\n        }\n        \n        "],[1,3596,"ou"],[-1,3600,"\t"],[1,3601,"    }\n"]],[2962,3602],[3971,3971]]],[1560153341795,["GJX@GJXAIOU",[[1,2945,"个人解法同该方法："]],[2945,2945],[2954,2954]]],[1560153349422,["GJX@GJXAIOU",[[1,3987,"\n"]],[3984,3984],[3985,3985]]],[1560153349537,["GJX@GJXAIOU",[[1,3988,"\n"]],[3985,3985],[3986,3986]]],[1560153349901,["GJX@GJXAIOU",[[1,3986,"执行用时 : 1 ms, 在Available Captures for Rook的Java提交中击败了49.20% 的用户\n\n内存消耗 : 33.7 MB, 在Available Captures for Rook的Java提交中击败了79.00% 的用户"]],[3986,3986],[4115,4115]]]],null,"GJX@GJXAIOU"],["63abf41c-16a1-4e52-8582-d36528733101",1561359127889,"---\ntags: \n- 简单\n- 有思路不会\n- 数组\n\nflag: green\n\ndata: '2019-6-10'\n---\n\n\n\n# 999.车的可用捕获量\n\n## 一、题目\n\n在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。\n\n车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。\n\n返回车能够在一次移动中捕获到的卒的数量。\n\n- 示例 1：\n\n![1253_example_1_improved]($resource/1253_example_1_improved.PNG)\n\n输入：\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n输出：3\n解释：\n在本例中，车能够捕获所有的卒。\n\n\n- 示例 2：\n\n![1253_example_2_improved]($resource/1253_example_2_improved.PNG)\n\n输入：\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n输出：0\n解释：\n象阻止了车捕获任何卒。\n\n- 示例 3：\n\n![1253_example_3_improved]($resource/1253_example_3_improved.PNG)\n\n输入：\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],\n[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],\n[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n输出：3\n解释： \n车可以捕获位置 b5，d6 和 f5 的卒。\n \n\n提示：\n\nboard.length == board[i].length == 8\nboard[i][j] 可以是 'R'，'.'，'B' 或 'p'\n只有一个格子上存在 board[i][j] == 'R'\n\n\n\n\n## 二、解答\n\n\n- 解答一：\n```java\nclass Solution {\n    public int numRookCaptures(char[][] board) {\n        int xR = 0,yR = 0,count = 0;\n        for(int i = 0; i < board.length; i++){\n            for(int j = 0; j < board.length; j++){\n                if(board[i][j] == 'R'){\n                    xR = i;\n                    yR = j;\n                }\n            }\n        }\n        //扫描左边\n        for(int i = yR - 1; i >=0 ; i--){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描上边\n        for(int i = xR - 1; i >=0 ; i--){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        //扫描右边\n        for(int i = yR + 1; i < board.length; i++){\n            if(board[xR][i] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[xR][i] == 'B')\n                break;\n        }\n        //扫描下边\n        for(int i = xR + 1; i < board.length; i++){\n            if(board[i][yR] == 'p'){\n                count++;\n                break;\n            }\n            else if(board[i][yR] == 'B')\n                break;\n        }\n        return count;\n    }\n}\n```\n\n个人解法同该方法：\n- 解答二：\n```java\n\nclass Solution {\n    public int numRookCaptures(char[][] board) {\n        //首先得到车的位置\n        int xR = 0,yR = 0;\n        int N = board.length;\n\n        for (int i = 0; i < N; i++ ) {\n            for (int j = 0; j < N; j++) {\n                if (board[i][j] == 'R') {\n                    xR = i;\n                    yR = j;\n                    break;\n                }\n            }\n        }\n\n\n        //使车可以上下左右移动\n        int[][] num = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n        int count = 0;\n\n        for (int i = 0; i < 4; i++) {\n            int x = xR + num[i][0];\n            int y = yR + num[i][1];\n\n            while(x > 0 && x < 8 && y > 0 && y < 8){\n                if (board[x][y] != '.') {\n                    if (board[x][y] == 'p') {\n                        count++;\n                    }\n                    break;\n                }else{\n                    x += num[i][0];\n                    y += num[i][1];\n                }\n            }\n        }\n        \n        return count;\n    }\n}\n```\n\n执行用时 : 1 ms, 在Available Captures for Rook的Java提交中击败了49.20% 的用户\n\n内存消耗 : 33.7 MB, 在Available Captures for Rook的Java提交中击败了79.00% 的用户\n\n\n",[[1561359109860,["GJX@GJXAIOU",[[1,42,"s"],[-1,3992," "],[1,3993," "],[-1,4044," "],[1,4045," "],[-1,4056," "],[1,4057," "],[-1,4111," "],[1,4112," "]],[42,42],[43,43]]],[1561359113335,["GJX@GJXAIOU",[[1,43,"tyle: summer"]],[43,43],[55,55]]],[1561359123089,["GJX@GJXAIOU",[[-1,18,"有思路不会"]],[23,23],[18,18]]],[1561359125031,["GJX@GJXAIOU",[[1,18,"cankao"]],[18,18],[24,24]]],[1561359126496,["GJX@GJXAIOU",[[-1,17," cankao"]],[24,24],[17,17]]],[1561359127831,["GJX@GJXAIOU",[[1,17," ca"]],[17,17],[20,20]]],[1561359128407,["GJX@GJXAIOU",[[1,20,"nkao"]],[20,20],[24,24]]],[1561359129840,["GJX@GJXAIOU",[[-1,18,"cankao"]],[24,24],[18,18]]],[1561359133474,["GJX@GJXAIOU",[[1,18,"参考"]],[18,18],[20,20]]]],null,"GJX@GJXAIOU"]]}