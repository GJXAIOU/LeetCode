{"compress":true,"commitItems":[["f4593456-6145-449f-8726-34ba4d49ce01",1559897745297,"",[[1559897712883,["GJX@GJXAIOU",[[1,0,"# 9.移除元素\n\n\n\n"]],[0,0],[11,11]]],[1559897715576,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1559897715703,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1559897717960,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1559897718087,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1559897718202,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1559897718224,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1559897721314,["GJX@GJXAIOU",[[1,4,"taga"]],[4,4],[8,8]]],[1559897721975,["GJX@GJXAIOU",[[-1,7,"a"]],[8,8],[7,7]]],[1559897723399,["GJX@GJXAIOU",[[1,7,"s:"]],[7,7],[9,9]]],[1559897734799,["GJX@GJXAIOU",[[1,10,"\n"]],[9,9],[10,10]]],[1559897737158,["GJX@GJXAIOU",[[1,10,"-   "]],[10,10],[14,14]]],[1559897738520,["GJX@GJXAIOU",[[-1,13," "]],[14,14],[13,13]]],[1559897739240,["GJX@GJXAIOU",[[1,13,"sahgn"]],[13,13],[18,18]]],[1559897740455,["GJX@GJXAIOU",[[-1,13,"sahgn"]],[18,18],[13,13]]],[1559897749627,["GJX@GJXAIOU",[[1,13,"双指针"]],[13,13],[16,16]]],[1559897750031,["GJX@GJXAIOU",[[1,17,"\n"]],[16,16],[17,17]]],[1559897759188,["GJX@GJXAIOU",[[1,17,"- 快慢指针"]],[17,17],[23,23]]],[1559897760000,["GJX@GJXAIOU",[[1,24,"\n"]],[23,23],[24,24]]],[1559897762504,["GJX@GJXAIOU",[[1,24,"flaga"]],[24,24],[29,29]]],[1559897763127,["GJX@GJXAIOU",[[-1,28,"a"]],[29,29],[28,28]]],[1559897765960,["GJX@GJXAIOU",[[1,28,": green"]],[28,28],[35,35]]],[1559897767015,["GJX@GJXAIOU",[[1,36,"\n"]],[35,35],[36,36]]],[1559897767362,["GJX@GJXAIOU",[[1,37,"\n"]],[36,36],[37,37]]],[1559897770628,["GJX@GJXAIOU",[[1,37,"data"]],[37,37],[41,41]]],[1559897771351,["GJX@GJXAIOU",[[-1,40,"a"]],[41,41],[40,40]]],[1559897778328,["GJX@GJXAIOU",[[1,40,"e:'1029"]],[40,40],[47,47]]],[1559897779079,["GJX@GJXAIOU",[[-1,43,"1029"]],[47,47],[43,43]]],[1559897786689,["GJX@GJXAIOU",[[1,43,"2019-6-7"]],[43,43],[51,51]]],[1559897787479,["GJX@GJXAIOU",[[1,52,"\n"]],[51,51],[52,52]]],[1559897788256,["GJX@GJXAIOU",[[-1,52,"\n"]],[52,52],[51,51]]],[1559897789392,["GJX@GJXAIOU",[[1,51,"'"]],[51,51],[52,52]]],[1559897793808,["GJX@GJXAIOU",[[1,42," "]],[42,42],[43,43]]],[1559897797895,["GJX@GJXAIOU",[[1,71,"### "]],[71,71],[75,75]]],[1559897799334,["GJX@GJXAIOU",[[-1,71,"### "]],[75,75],[71,71]]],[1559897799446,["GJX@GJXAIOU",[[-1,71,"\n"]],[71,71],[70,70]]],[1559897802111,["GJX@GJXAIOU",[[1,70,"## yi"]],[70,70],[75,75]]],[1559897802807,["GJX@GJXAIOU",[[-1,73,"yi"]],[75,75],[73,73]]],[1559897804106,["GJX@GJXAIOU",[[1,73,"一、"]],[73,73],[75,75]]],[1559897805354,["GJX@GJXAIOU",[[1,75,"题目"]],[75,75],[77,77]]],[1559897805710,["GJX@GJXAIOU",[[1,78,"\n"]],[77,77],[78,78]]],[1559897805841,["GJX@GJXAIOU",[[1,79,"\n"]],[78,78],[79,79]]],[1559897806497,["GJX@GJXAIOU",[[1,80,"\n"]],[79,79],[80,80]]],[1559897809330,["GJX@GJXAIOU",[[1,80,"## 二/"]],[80,80],[85,85]]],[1559897810186,["GJX@GJXAIOU",[[-1,84,"/"]],[85,85],[84,84]]],[1559897810664,["GJX@GJXAIOU",[[1,84,"/"]],[84,84],[85,85]]],[1559897811207,["GJX@GJXAIOU",[[-1,84,"/"]],[85,85],[84,84]]],[1559897813844,["GJX@GJXAIOU",[[1,84,"、解答"]],[84,84],[87,87]]],[1559897815616,["GJX@GJXAIOU",[[1,88,"\n"]],[87,87],[88,88]]],[1559897816975,["GJX@GJXAIOU",[[1,89,"\n"]],[88,88],[89,89]]],[1559897818554,["GJX@GJXAIOU",[[-1,89,"\n"],[1,90,"-"]],[89,89],[90,90]]],[1559897825482,["GJX@GJXAIOU",[[1,90," 自己解答方案\n- "]],[90,90],[100,100]]],[1559897826311,["GJX@GJXAIOU",[[-1,99," "]],[100,100],[99,99]]],[1559897826456,["GJX@GJXAIOU",[[-1,98,"-"],[1,99,"\n"]],[99,99],[98,98]]],[1559897828017,["GJX@GJXAIOU",[[-1,98,"\n"],[1,99,"1"]],[98,98],[99,99]]],[1559897828385,["GJX@GJXAIOU",[[1,99,"11"]],[99,99],[101,101]]],[1559897829498,["GJX@GJXAIOU",[[-1,99,"11"]],[101,101],[99,99]]],[1559897829641,["GJX@GJXAIOU",[[-1,98,"1"],[1,99,"\n"]],[99,99],[98,98]]],[1559897831203,["GJX@GJXAIOU",[[-1,98,"\n"],[1,99,"`"]],[98,98],[99,99]]],[1559897831585,["GJX@GJXAIOU",[[1,99,"``"]],[99,99],[101,101]]],[1559897831608,["GJX@GJXAIOU",[[1,101,"language\n```\n"]],[101,101],[101,109]]],[1559897832760,["GJX@GJXAIOU",[[-1,101,"language"],[1,109,"j"]],[101,109],[102,102]]],[1559897833649,["GJX@GJXAIOU",[[1,102,"ava"]],[102,102],[105,105]]],[1559897833912,["GJX@GJXAIOU",[[1,106,"\n"]],[105,105],[106,106]]],[1559897834984,["GJX@GJXAIOU",[[1,106,"class Solution {\n    public int removeElement(int[] nums, int val) {\n    \tint i = 0;\n        if (nums.length == 0) {\n        \treturn 0;\n        }else{\n        \tfor (int j = 0; j < nums.length ; j++ ) {\n        \t\tif (nums[j] != val) {\n        \t\t\tnums[i] = nums[j];\n        \t\t\ti++;\n        \t\t}\n        \t}\n        }\n        return i ;\n    }\n}"]],[106,106],[445,445]]],[1559897839498,["GJX@GJXAIOU",[[1,80,"\n"]],[78,78],[79,79]]],[1559897839600,["GJX@GJXAIOU",[[1,81,"\n"]],[79,79],[80,80]]],[1559897850416,["GJX@GJXAIOU",[[1,79,"给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1:\n\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n示例 2:\n\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-element\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[79,79],[818,818]]],[1559897857256,["GJX@GJXAIOU",[[1,103,"**"],[1,107,"**"]],[103,107],[103,111]]],[1559897863163,["GJX@GJXAIOU",[[-1,90," "],[1,91," "],[-1,117," val "],[1,122," val "],[1,219,"-"],[-1,225,""],[-1,316," "],[1,317," "],[-1,698,"   "],[1,701,"   "]],[219,219],[220,220]]],[1559897863626,["GJX@GJXAIOU",[[1,220," "]],[220,220],[221,221]]],[1559897865088,["GJX@GJXAIOU",[[-1,227,"\n"]],[227,227],[227,227]]],[1559897865937,["GJX@GJXAIOU",[[-1,257,"\n"]],[257,257],[257,257]]],[1559897866648,["GJX@GJXAIOU",[[-1,292,"\n"]],[292,292],[292,292]]],[1559897868153,["GJX@GJXAIOU",[[1,313,"\n"]],[313,313],[314,314]]],[1559897870465,["GJX@GJXAIOU",[[1,314,"- "]],[314,314],[316,316]]],[1559897871848,["GJX@GJXAIOU",[[-1,322,"\n"]],[322,322],[322,322]]],[1559897872537,["GJX@GJXAIOU",[[-1,360,"\n"]],[360,360],[360,360]]],[1559897873567,["GJX@GJXAIOU",[[-1,406,"\n"]],[406,406],[406,406]]],[1559897877986,["GJX@GJXAIOU",[[-1,421,"\n"]],[421,421],[421,421]]],[1559897881407,["GJX@GJXAIOU",[[1,442,"\n"]],[442,442],[443,443]]],[1559897883521,["GJX@GJXAIOU",[[1,443,"- "]],[443,443],[445,445]]],[1559897891040,["GJX@GJXAIOU",[[1,533,"```java"]],[533,533],[540,540]]],[1559897894424,["GJX@GJXAIOU",[[1,728,"```"]],[728,728],[731,731]]],[1559897896906,["GJX@GJXAIOU",[[-1,732,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-element\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[732,833],[732,732]]],[1559897904503,["GJX@GJXAIOU",[[1,744,"\n"]],[742,742],[743,743]]],[1559897904625,["GJX@GJXAIOU",[[1,745,"\n"]],[743,743],[744,744]]],[1559897904776,["GJX@GJXAIOU",[[1,746,"\n"]],[744,744],[745,745]]],[1559897904874,["GJX@GJXAIOU",[[1,747,"\n"]],[745,745],[746,746]]],[1559897905008,["GJX@GJXAIOU",[[1,748,"\n"]],[746,746],[747,747]]],[1559897905136,["GJX@GJXAIOU",[[1,749,"\n"]],[747,747],[748,748]]],[1559897905258,["GJX@GJXAIOU",[[1,750,"\n"]],[748,748],[749,749]]],[1559897934802,["GJX@GJXAIOU",[[1,745,"方法一：双指针\n方法二：双指针 —— 当要删除的元素很少时\n概要\n这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。\n\n提示\n尝试双指针法。\n你是否使用“元素顺序可以更改”这一属性？\n当要删除的元素很少时会发生什么？\n解决方案\n方法一：双指针\n思路\n\n既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 ii 和 jj，其中 ii 是慢指针，jj 是快指针。\n\n算法\n\n当 nums[j]nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] \\neq valnums[j] \n\n​\t\n =val，我们就复制 nums[j]nums[j] 到 nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jj 到达数组的末尾，该数组的新长度为 ii。\n\n该解法与 删除排序数组中的重复项 的解法十分相似。\n\nJava\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)， 假设数组总共有 nn 个元素，ii 和 jj 至少遍历 2n2n 步。\n\n空间复杂度：O(1)O(1)。\n\n方法二：双指针 —— 当要删除的元素很少时\n思路\n\n现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。\n\n算法\n\n当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。\n\n请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。\n\nJava\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)，ii 和 nn 最多遍历 nn 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。\n\n空间复杂度：O(1)O(1)。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-chu-yuan-su-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[745,745],[2398,2398]]],[1559897938826,["GJX@GJXAIOU",[[1,745,"**"],[1,752,"**"]],[745,752],[745,756]]],[1559897941735,["GJX@GJXAIOU",[[1,757,"**"],[1,778,"**"]],[757,778],[757,782]]],[1559897943614,["GJX@GJXAIOU",[[1,783,"**"],[1,785,"**"]],[783,785],[783,789]]],[1559897945393,["GJX@GJXAIOU",[[1,783,"\n"]],[782,782],[783,783]]],[1559897949374,["GJX@GJXAIOU",[[1,850,"**"],[1,852,"**"]],[850,852],[850,856]]],[1559897952807,["GJX@GJXAIOU",[[1,857,"* "],[1,865,"* "],[1,886,"* "]],[857,902],[859,908]]],[1559897956334,["GJX@GJXAIOU",[[1,909,"**"],[1,913,"**"]],[909,913],[909,917]]],[1559897957792,["GJX@GJXAIOU",[[1,910," \n*"]],[908,908],[911,911]]],[1559897957919,["GJX@GJXAIOU",[[-1,909,"* "]],[911,911],[910,910]]],[1559897960007,["GJX@GJXAIOU",[[1,919,"\n"]],[918,918],[919,919]]],[1559897965889,["GJX@GJXAIOU",[[1,920,"**"],[1,927,"**"]],[920,927],[920,931]]],[1559897967480,["GJX@GJXAIOU",[[1,932,"**"],[1,934,"**"]],[932,934],[932,938]]],[1559897977247,["GJX@GJXAIOU",[[-1,972,"O(1)"]],[976,976],[972,972]]],[1559897979151,["GJX@GJXAIOU",[[-1,1005,"j"]],[1006,1006],[1005,1005]]],[1559897980711,["GJX@GJXAIOU",[[-1,1010,"i"]],[1010,1010],[1009,1009]]],[1559897983118,["GJX@GJXAIOU",[[-1,1017,"j"]],[1017,1017],[1016,1016]]],[1559897986722,["GJX@GJXAIOU",[[-1,1000,"i"]],[1001,1001],[1000,1000]]],[1559897990071,["GJX@GJXAIOU",[[1,1024,"**"],[1,1026,"**"]],[1024,1026],[1024,1030]]],[1559897995879,["GJX@GJXAIOU",[[-1,1041,"nums[j] "]],[1041,1049],[1041,1041]]],[1559897996991,["GJX@GJXAIOU",[[-1,1054,"j"]],[1054,1054],[1053,1053]]],[1559898005031,["GJX@GJXAIOU",[[-1,1081,"nums[j] \n\n​\t\n =val"]],[1081,1100],[1081,1081]]],[1559898008911,["GJX@GJXAIOU",[[1,1065,"$"]],[1065,1065],[1066,1066]]],[1559898010482,["GJX@GJXAIOU",[[1,1082,"$"]],[1082,1082],[1083,1083]]],[1559898016911,["GJX@GJXAIOU",[[-1,1091,"ums[j]n"]],[1097,1097],[1090,1090]]],[1559898019318,["GJX@GJXAIOU",[[-1,1101,"ums[i]n"]],[1107,1107],[1100,1100]]],[1559898023991,["GJX@GJXAIOU",[[-1,1149,"i"]],[1149,1149],[1148,1148]]],[1559898025270,["GJX@GJXAIOU",[[-1,1129,"j"]],[1130,1130],[1129,1129]]],[1559898032993,["GJX@GJXAIOU",[[1,1178,"```"]],[1178,1178],[1181,1181]]],[1559898037001,["GJX@GJXAIOU",[[1,1403,"\n"]],[1402,1402],[1403,1403]]],[1559898037920,["GJX@GJXAIOU",[[1,1403,"```"]],[1403,1403],[1406,1406]]],[1559898049858,["GJX@GJXAIOU",[[1,1407,"方法一：双指针\n方法二：双指针 —— 当要删除的元素很少时\n概要\n这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。\n\n提示\n尝试双指针法。\n你是否使用“元素顺序可以更改”这一属性？\n当要删除的元素很少时会发生什么？\n解决方案\n方法一：双指针\n思路\n\n既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 ii 和 jj，其中 ii 是慢指针，jj 是快指针。\n\n算法\n\n当 nums[j]nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] \\neq valnums[j] \n\n​\t\n =val，我们就复制 nums[j]nums[j] 到 nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jj 到达数组的末尾，该数组的新长度为 ii。\n\n该解法与 删除排序数组中的重复项 的解法十分相似。\n\nJava\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n"],[1,1412,"\n\n时间复杂度：O(n)O(n)， 假设数组总共有 nn 个元素，ii 和 jj 至少遍历 2n2n 步。\n\n空间复杂度：O(1)O(1)。\n\n方法二：双指针 —— 当要删除的元素很少时\n思路\n\n现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。\n\n算法\n\n当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。\n\n请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。\n\nJava\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)，ii 和 nn 最多遍历 nn 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。\n\n空间复杂度：O(1)O(1)。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-chu-yuan-su-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1407,1412],[3060,3060]]],[1559898052646,["GJX@GJXAIOU",[[-1,1407,"方法一：双指针\n方法二：双指针 —— 当要删除的元素很少时\n概要\n这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。\n\n提示\n尝试双指针法。\n你是否使用“元素顺序可以更改”这一属性？\n当要删除的元素很少时会发生什么？\n解决方案\n方法一：双指针\n思路\n\n既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 ii 和 jj，其中 ii 是慢指针，jj 是快指针。\n\n算法\n\n当 nums[j]nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] \\neq valnums[j] \n\n​\t\n =val，我们就复制 nums[j]nums[j] 到 nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jj 到达数组的末尾，该数组的新长度为 ii。\n\n该解法与 删除排序数组中的重复项 的解法十分相似。\n\nJava\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n"],[-1,2076,"\n\n时间复杂度：O(n)O(n)， 假设数组总共有 nn 个元素，ii 和 jj 至少遍历 2n2n 步。\n\n空间复杂度：O(1)O(1)。\n\n方法二：双指针 —— 当要删除的元素很少时\n思路\n\n现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。\n\n算法\n\n当我们遇到 nums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。\n\n请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。\n\nJava\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)，ii 和 nn 最多遍历 nn 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。\n\n空间复杂度：O(1)O(1)。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-chu-yuan-su-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[3060,3060],[1407,1412]]],[1559898053863,["GJX@GJXAIOU",[[1,1407,"**"],[1,1412,"**"]],[1407,1412],[1407,1416]]],[1559898056487,["GJX@GJXAIOU",[[1,1407,"\n"]],[1407,1407],[1408,1408]]],[1559898062983,["GJX@GJXAIOU",[[-1,1465,"2n"]],[1467,1467],[1465,1465]]],[1559898066222,["GJX@GJXAIOU",[[-1,1426,"(n)O"]],[1429,1429],[1425,1425]]],[1559898067951,["GJX@GJXAIOU",[[-1,1440,"n"]],[1440,1440],[1439,1439]]],[1559898068983,["GJX@GJXAIOU",[[-1,1446,"i"]],[1446,1446],[1445,1445]]],[1559898069926,["GJX@GJXAIOU",[[-1,1450,"j"]],[1450,1450],[1449,1449]]],[1559898072384,["GJX@GJXAIOU",[[1,1419,"-0 "]],[1419,1419],[1422,1422]]],[1559898073638,["GJX@GJXAIOU",[[-1,1420,"0 "]],[1422,1422],[1420,1420]]],[1559898074104,["GJX@GJXAIOU",[[1,1420," "]],[1420,1420],[1421,1421]]],[1559898075937,["GJX@GJXAIOU",[[1,1466,"- "]],[1466,1466],[1468,1468]]],[1559898077414,["GJX@GJXAIOU",[[-1,1466,"- "]],[1468,1468],[1466,1466]]],[1559898078875,["GJX@GJXAIOU",[[1,1465,"- "]],[1465,1465],[1467,1467]]],[1559898081873,["GJX@GJXAIOU",[[1,1484,"**"],[1,1505,"**"]],[1484,1505],[1484,1509]]],[1559898085854,["GJX@GJXAIOU",[[1,1510,"**"],[1,1512,"**"]],[1510,1512],[1510,1516]]],[1559898101127,["GJX@GJXAIOU",[[-1,1563,"num=[1，2，3，5，4]，Val=4"]],[1563,1584],[1563,1563]]],[1559898106920,["GJX@GJXAIOU",[[-1,1614,"num=[4，1，2，3，5]，Val=4"]],[1614,1635],[1614,1614]]],[1559898110218,["GJX@GJXAIOU",[[1,1542,"`"]],[1542,1542],[1543,1543]]],[1559898112186,["GJX@GJXAIOU",[[1,1564,"`"]],[1564,1564],[1565,1565]]],[1559898115391,["GJX@GJXAIOU",[[1,1595,"`"]],[1595,1595],[1596,1596]]],[1559898116896,["GJX@GJXAIOU",[[1,1617,"`"]],[1617,1617],[1618,1618]]],[1559898121827,["GJX@GJXAIOU",[[1,1627,"`"]],[1627,1627],[1628,1628]]],[1559898126624,["GJX@GJXAIOU",[[-1,1637,"[1，2，3，5]"]],[1646,1646],[1637,1637]]],[1559898126849,["GJX@GJXAIOU",[[1,1637,"`"]],[1637,1637],[1638,1638]]],[1559898130385,["GJX@GJXAIOU",[[1,1670,"**"],[1,1672,"**"]],[1670,1672],[1670,1676]]],[1559898139250,["GJX@GJXAIOU",[[-1,1697,"nums[i]=val"]],[1697,1708],[1697,1697]]],[1559898151131,["GJX@GJXAIOU",[[1,1803,"1`"]],[1803,1803],[1805,1805]]],[1559898152488,["GJX@GJXAIOU",[[-1,1803,"1`"]],[1805,1805],[1803,1803]]],[1559898153220,["GJX@GJXAIOU",[[1,1803,"```"]],[1803,1803],[1806,1806]]],[1559898156047,["GJX@GJXAIOU",[[1,2107,"\n"]],[2106,2106],[2107,2107]]],[1559898156745,["GJX@GJXAIOU",[[1,2107,"```"]],[2107,2107],[2110,2110]]],[1559898159320,["GJX@GJXAIOU",[[1,2111,"**"],[1,2116,"**"]],[2111,2116],[2111,2120]]],[1559898162305,["GJX@GJXAIOU",[[1,2122,"- "]],[2122,2122],[2124,2124]]],[1559898164315,["GJX@GJXAIOU",[[1,2205,"- "]],[2205,2205],[2207,2207]]],[1559898167287,["GJX@GJXAIOU",[[-1,2214,"(1)O"]],[2217,2217],[2213,2213]]],[1559898172626,["GJX@GJXAIOU",[[-1,2153,"n"]],[2153,2153],[2152,2152]]],[1559898173975,["GJX@GJXAIOU",[[-1,2145,"n"]],[2146,2146],[2145,2145]]],[1559898175015,["GJX@GJXAIOU",[[-1,2140,"i"]],[2141,2141],[2140,2140]]],[1559898177222,["GJX@GJXAIOU",[[-1,2134,"O(n)"]],[2138,2138],[2134,2134]]],[1559898180368,["GJX@GJXAIOU",[[1,2111,"\n"]],[2110,2110],[2111,2111]]],[1559898299822,["GJX@GJXAIOU",[[1,1678,"**"],[1,1747,"**"]],[1678,1747],[1678,1751]]],[1559898890939,["GJX@GJXAIOU",[[1,2078," 、、"]],[2078,2078],[2081,2081]]],[1559898891577,["GJX@GJXAIOU",[[-1,2079,"、、"]],[2081,2081],[2079,2079]]],[1559898893469,["GJX@GJXAIOU",[[1,2079,"//dia"]],[2079,2079],[2084,2084]]],[1559898894345,["GJX@GJXAIOU",[[-1,2081,"dia"]],[2084,2084],[2081,2081]]],[1559898895368,["GJX@GJXAIOU",[[1,2081,"pan"]],[2081,2081],[2084,2084]]],[1559898896176,["GJX@GJXAIOU",[[-1,2081,"pan"]],[2084,2084],[2081,2081]]],[1559898914339,["GJX@GJXAIOU",[[1,2081,"上面是将调换之后的数再次判断一下，不符合下"]],[2081,2081],[2102,2102]]],[1559898915095,["GJX@GJXAIOU",[[-1,2101,"下"]],[2102,2102],[2101,2101]]],[1559898918546,["GJX@GJXAIOU",[[1,2101,"才i++"]],[2101,2101],[2105,2105]]]],null,"GJX@GJXAIOU"],["65df0270-684d-4795-94f8-5520bf0c5f6c",1560058618448,"---\ntags:\n-  双指针\n- 快慢指针\nflag: green\n\ndate: '2019-6-7'\n---\n\n\n# 9.移除元素\n\n## 一、题目\n\n给定一个数组 nums 和一个值 val，你需要**原地移除**所有数值等于 val 的元素，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n- 示例 1:\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\n\n- 示例 2:\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n注意这五个元素可为任意顺序。\n你不需要考虑数组中超出新长度后面的元素。\n\n- 说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n```java\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n\n\n## 二、解答\n\n\n**方法一：双指针**\n**方法二：双指针 —— 当要删除的元素很少时**\n\n**概要**\n这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。\n\n**提示**\n* 尝试双指针法。\n* 你是否使用“元素顺序可以更改”这一属性？\n* 当要删除的元素很少时会发生什么？\n\n**解决方案**\n\n**方法一：双指针**\n**思路**\n\n既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。\n\n**算法**\n\n当 nums[j]与给定的值相等时，递增 j 以跳过该元素。只要 $nums[j] \\neq val$，我们就复制 nums[j] 到 nums[i] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。\n\n该解法与 删除排序数组中的重复项 的解法十分相似。\n\n```Java\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)， 假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。\n\n- 空间复杂度：O(1)O(1)。\n\n**方法二：双指针 —— 当要删除的元素很少时**\n**思路**\n\n现在考虑数组包含很少的要删除的元素的情况。例如，`num=[1，2，3，5，4]，Val=4`。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 `num=[4，1，2，3，5]，Val=4`。似乎没有必要将 `[1，2，3，5]` 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。\n\n**算法**\n\n**当我们遇到 nums[i] = val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。**\n\n请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。\n\n```Java\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++; //上面是将调换之后的数再次判断一下，不符合才i++\n        }\n    }\n    return n;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，i 和 n 最多遍历 n 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。\n\n- 空间复杂度：O(1)。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-chu-yuan-su-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n- 自己解答方案\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n    \tint i = 0;\n        if (nums.length == 0) {\n        \treturn 0;\n        }else{\n        \tfor (int j = 0; j < nums.length ; j++ ) {\n        \t\tif (nums[j] != val) {\n        \t\t\tnums[i] = nums[j];\n        \t\t\ti++;\n        \t\t}\n        \t}\n        }\n        return i ;\n    }\n}\n```\n",[[1560058569701,["GJX@GJXAIOU",[[1,10,"\n"]],[9,9],[10,10]]],[1560058575123,["GJX@GJXAIOU",[[1,10,"- 简单"]],[10,10],[14,14]]]],null,"GJX@GJXAIOU"]]}