{"compress":true,"commitItems":[["a2a5b94e-8474-452c-be28-e5c9a2b03b1b",1559722562817,"---\n\ntags:\n\n  - \n\nflag: green\n\ndate: '2019-06-05 09:38'\n\n---\n\n\n\n\n\n# 1.两数之和\n\n\n\n\n\n## 一、题目\n\n\n\n\n\n\n\n## 二、解答\n\n\n\n\n\n\n\n\n\n\n\n",[[1559722520702,["GJX@GJXAIOU",[[-1,68,"1.两数之和"],[1,74,"3"]],[68,74],[69,69]]],[1559722523519,["GJX@GJXAIOU",[[1,69,".回文数"]],[69,69],[73,73]]],[1559722526559,["GJX@GJXAIOU",[[1,88,"---\ntags:\n  - \nflag: green\ndate: '2019-06-05 09:38'\n---\n\n\n# 1.两数之和\n\n\n## 一、题目\n\n\n\n## 二、解答\n\n\n\n\n\n"]],[88,88],[181,181]]],[1559722529466,["GJX@GJXAIOU",[[-1,88,"---\ntags:\n  - \nflag: green\ndate: '2019-06-05 09:38'\n---\n\n\n# 1.两数之和\n\n\n## 一、题目\n\n\n\n## 二、解答\n\n\n\n\n\n"]],[181,181],[88,88]]],[1559722536489,["GJX@GJXAIOU",[[1,89,"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n示例 1:\n\n输入: 121\n输出: true\n示例 2:\n\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3:\n\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n进阶:\n\n你能不将整数转为字符串来解决这个问题吗？"]],[89,89],[310,310]]],[1559722543874,["GJX@GJXAIOU",[[-1,78,"\n"]],[77,77],[76,76]]],[1559722544004,["GJX@GJXAIOU",[[-1,77,"\n"]],[76,76],[75,75]]],[1559722546013,["GJX@GJXAIOU",[[-1,65,"\n"]],[64,64],[63,63]]],[1559722546151,["GJX@GJXAIOU",[[-1,64,"\n"]],[63,63],[62,62]]],[1559722546284,["GJX@GJXAIOU",[[-1,63,"\n"]],[62,62],[61,61]]],[1559722562673,["GJX@GJXAIOU",[[1,280,"\n"]],[279,279],[280,280]]],[1559723098648,["GJX@GJXAIOU",[[1,320,"个人解答："]],[320,320],[325,325]]],[1559723099133,["GJX@GJXAIOU",[[1,335,"\n"]],[325,325],[326,326]]],[1559723100614,["GJX@GJXAIOU",[[1,326,"```"]],[326,326],[329,329]]],[1559723100639,["GJX@GJXAIOU",[[1,329,"language\n```\n"]],[329,329],[329,337]]],[1559723101928,["GJX@GJXAIOU",[[-1,329,"language"],[1,337,"j"]],[329,337],[330,330]]],[1559723102279,["GJX@GJXAIOU",[[1,330,"ava"]],[330,330],[333,333]]],[1559723102452,["GJX@GJXAIOU",[[1,334,"\n"]],[333,333],[334,334]]],[1559723103411,["GJX@GJXAIOU",[[1,334,"class Solution {\n    public boolean isPalindrome(int x) {\n        int y = x;\n        if (x >= 0) {\n        \tint rev = 0;\n            while(x != 0){\n            int pop = x % 10;\n            rev = rev * 10 + pop;\n            x = x / 10;\n            }\n            if (y == rev) {\n            \treturn true;\n            }else return false;\n        }else{\n        \treturn false;\n        }   \n    }\n}"]],[334,334],[728,728]]],[1559723453206,["GJX@GJXAIOU",[[1,320,"\n"]],[319,319],[320,320]]],[1559723453707,["GJX@GJXAIOU",[[1,321,"\n"]],[320,320],[321,321]]],[1559723453738,["GJX@GJXAIOU",[[1,322,"\n"]],[321,321],[322,322]]],[1559723453772,["GJX@GJXAIOU",[[1,323,"\n"]],[322,322],[323,323]]],[1559723453805,["GJX@GJXAIOU",[[1,324,"\n"]],[323,323],[324,324]]],[1559723453838,["GJX@GJXAIOU",[[1,325,"\n"]],[324,324],[325,325]]],[1559723453873,["GJX@GJXAIOU",[[1,326,"\n"]],[325,325],[326,326]]],[1559723453906,["GJX@GJXAIOU",[[1,327,"\n"]],[326,326],[327,327]]],[1559723453939,["GJX@GJXAIOU",[[1,328,"\n"]],[327,327],[328,328]]],[1559723453972,["GJX@GJXAIOU",[[1,329,"\n"]],[328,328],[329,329]]],[1559723454004,["GJX@GJXAIOU",[[1,330,"\n"]],[329,329],[330,330]]],[1559723454038,["GJX@GJXAIOU",[[1,331,"\n"]],[330,330],[331,331]]],[1559723454070,["GJX@GJXAIOU",[[1,332,"\n"]],[331,331],[332,332]]],[1559723454103,["GJX@GJXAIOU",[[1,333,"\n"]],[332,332],[333,333]]],[1559723454140,["GJX@GJXAIOU",[[1,334,"\n"]],[333,333],[334,334]]],[1559723454177,["GJX@GJXAIOU",[[1,335,"\n"]],[334,334],[335,335]]],[1559723454200,["GJX@GJXAIOU",[[1,336,"\n"]],[335,335],[336,336]]],[1559723454234,["GJX@GJXAIOU",[[1,337,"\n"]],[336,336],[337,337]]],[1559723454267,["GJX@GJXAIOU",[[1,338,"\n"]],[337,337],[338,338]]],[1559723454299,["GJX@GJXAIOU",[[1,339,"\n"]],[338,338],[339,339]]],[1559723454334,["GJX@GJXAIOU",[[1,340,"\n"]],[339,339],[340,340]]],[1559723454367,["GJX@GJXAIOU",[[1,341,"\n"]],[340,340],[341,341]]],[1559723454400,["GJX@GJXAIOU",[[1,342,"\n"]],[341,341],[342,342]]],[1559723454433,["GJX@GJXAIOU",[[1,343,"\n"]],[342,342],[343,343]]],[1559723454467,["GJX@GJXAIOU",[[1,344,"\n"]],[343,343],[344,344]]],[1559723454497,["GJX@GJXAIOU",[[1,345,"\n"]],[344,344],[345,345]]],[1559723454530,["GJX@GJXAIOU",[[1,346,"\n"]],[345,345],[346,346]]],[1559723454564,["GJX@GJXAIOU",[[1,347,"\n"]],[346,346],[347,347]]],[1559723454597,["GJX@GJXAIOU",[[1,348,"\n"]],[347,347],[348,348]]],[1559723454630,["GJX@GJXAIOU",[[1,349,"\n"]],[348,348],[349,349]]],[1559723454662,["GJX@GJXAIOU",[[1,350,"\n"]],[349,349],[350,350]]],[1559723454697,["GJX@GJXAIOU",[[1,351,"\n"]],[350,350],[351,351]]],[1559723454732,["GJX@GJXAIOU",[[1,352,"\n"]],[351,351],[352,352]]],[1559723454767,["GJX@GJXAIOU",[[1,353,"\n"]],[352,352],[353,353]]],[1559723454798,["GJX@GJXAIOU",[[1,354,"\n"]],[353,353],[354,354]]],[1559723459320,["GJX@GJXAIOU",[[1,320,"解法一：普通解法\n最好理解的一种解法就是先将 整数转为字符串 ，然后将字符串分割为数组，只需要循环数组的一半长度进行判断对应元素是否相等即可。\n\n动画描述\n\n\n代码实现\nJava\n///简单粗暴，看看就行\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String reversedStr = (new StringBuilder(x + \"\")).reverse().toString();\n        return (x + \"\").equals(reversedStr);\n    }\n}\n解法二：进阶解法---数学解法\n通过取整和取余操作获取整数中对应的数字进行比较。\n\n举个例子：1221 这个数字。\n\n通过计算 1221 / 1000， 得首位1\n通过计算 1221 % 10， 可得末位 1\n进行比较\n再将 22 取出来继续比较\n动画描述\n\n\n代码实现\nJava\nclass Solution {\n    public boolean isPalindrome(int x) {\n        //边界判断\n        if (x < 0) return false;\n        int div = 1;\n        //\n        while (x / div >= 10) div *= 10;\n        while (x > 0) {\n            int left = x / div;\n            int right = x % 10;\n            if (left != right) return false;\n            x = (x % div) / 10;\n            div /= 100;\n        }\n        return true;\n    }\n}\n解法三：进阶解法---巧妙解法\n直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。\n\n所以这个解法的操作就是 取出后半段数字进行翻转。\n\n这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。\n\n具体做法如下：\n\n每次进行取余操作 （ %10），取出最低的数字：y = x % 10\n将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y\n每取一个最低位数字，x 都要自除以 10\n判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了\n最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n动画描述\n\n\n代码实现\nJava\nclass Solution {\n    public boolean isPalindrome(int x) {\n        //思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false\n        if (x < 0 || (x % 10 == 0 && x != 0)) return false;\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n}\n作者：MisterBooo\n链接：https://leetcode-cn.com/problems/two-sum/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[320,320],[2158,2158]]],[1559723465267,["GJX@GJXAIOU",[[1,406,"·"]],[406,406],[407,407]]],[1559723466410,["GJX@GJXAIOU",[[-1,406,"·"]],[407,407],[406,406]]],[1559723467862,["GJX@GJXAIOU",[[1,405,"```"]],[405,405],[408,408]]],[1559723474334,["GJX@GJXAIOU",[[1,616,"\n"]],[615,615],[616,616]]],[1559723475119,["GJX@GJXAIOU",[[1,616,"```"]],[616,616],[619,619]]],[1559723480504,["GJX@GJXAIOU",[[1,756,"```"]],[756,756],[759,759]]],[1559723483479,["GJX@GJXAIOU",[[1,1171,"\n"]],[1170,1170],[1171,1171]]],[1559723484087,["GJX@GJXAIOU",[[1,1171,"```"]],[1171,1171],[1174,1174]]],[1559723491454,["GJX@GJXAIOU",[[1,1602,"```"]],[1602,1602],[1605,1605]]],[1559723494814,["GJX@GJXAIOU",[[1,2006,"\n"]],[2005,2005],[2006,2006]]],[1559723495186,["GJX@GJXAIOU",[[1,2007,"\n"]],[2006,2006],[2007,2007]]],[1559723496503,["GJX@GJXAIOU",[[1,2007,"```"]],[2007,2007],[2010,2010]]],[1559723505543,["GJX@GJXAIOU",[[1,400,"\n"]],[398,398],[399,399]]],[1559723547159,["GJX@GJXAIOU",[[1,398,"![c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364]($resource/c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364.gif)"]],[398,398],[584,584]]],[1559723563200,["GJX@GJXAIOU",[[1,806,"\n"]],[805,805],[806,806]]],[1559723563312,["GJX@GJXAIOU",[[1,807,"\n"]],[806,806],[807,807]]],[1559723571803,["GJX@GJXAIOU",[[1,937,"![2]($resource/2.gif)"]],[937,937],[959,959]]],[1559723581049,["GJX@GJXAIOU",[[1,1805,"![3]($resource/3.png)"]],[1805,1805],[1827,1827]]],[1559723604710,["GJX@GJXAIOU",[[1,1447,"**"],[1,1458,"**"]],[1447,1458],[1447,1462]]],[1559723649975,["GJX@GJXAIOU",[[1,1569,"* "],[1,1604,"* "],[1,1650,"* "],[1,1671,"* "],[1,1715,"* "]],[1569,1802],[1571,1812]]],[1559723653920,["GJX@GJXAIOU",[[1,1560,"**"],[1,1567,"**"]],[1560,1567],[1560,1571]]],[1559723655889,["GJX@GJXAIOU",[[1,1817,"**"],[1,1821,"**"]],[1817,1821],[1817,1825]]],[1559723657598,["GJX@GJXAIOU",[[1,1849,"**"],[1,1853,"**"]],[1849,1853],[1849,1857]]],[1559723664284,["GJX@GJXAIOU",[[1,1817,"\n"]],[1817,1817],[1818,1818]]],[1559723668238,["GJX@GJXAIOU",[[1,1850,"\n"]],[1849,1849],[1850,1850]]],[1559723846820,["GJX@GJXAIOU",[[1,1868,"public "],[-1,1900,"ean i"],[1,1905," I"],[-1,1936,"思考：这里大家可以思考一下，为什么末尾为 0 就可以直接返回 false"],[1,1972," 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性"],[-1,1983," "],[1,2019,"{\n            "],[1,2032,"\n        }\n"],[-1,2078," "],[1,2192,"\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n"],[-1,2249," "],[-1,2251," "],[1,2263,"\n复杂度分析\n\n时间复杂度：O(\\log_{10}(n))O(log \n10\n​\t\n (n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(\\log_{10}(n))O(log \n10\n​\t\n (n))。\n空间复杂度：O(1)O(1)。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/hui-wen-shu-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1868,2263],[2831,2831]]],[1559723860192,["GJX@GJXAIOU",[[-1,2566,"复杂度分析\n\n时间复杂度：O(\\log_{10}(n))O(log \n10\n​\t\n (n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(\\log_{10}(n))O(log \n10\n​\t\n (n))。\n空间复杂度：O(1)O(1)。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/hui-wen-shu-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2566,2831],[2566,2566]]],[1559723863598,["GJX@GJXAIOU",[[1,2776,"\n"]],[2741,2741],[2742,2742]]],[1559723863704,["GJX@GJXAIOU",[[1,2777,"\n"]],[2742,2742],[2743,2743]]],[1559723864344,["GJX@GJXAIOU",[[1,2743,"复杂度分析\n\n时间复杂度：O(\\log_{10}(n))O(log \n10\n​\t\n (n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(\\log_{10}(n))O(log \n10\n​\t\n (n))。\n空间复杂度：O(1)O(1)。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/hui-wen-shu-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2743,2743],[3008,3008]]],[1559723868806,["GJX@GJXAIOU",[[-1,2743,"复杂度分析\n\n时间复杂度：O(\\log_{10}(n))O(log \n10\n​\t\n (n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(\\log_{10}(n))O(log \n10\n​\t\n (n))。\n空间复杂度：O(1)O(1)。"]],[2743,2867],[2743,2743]]],[1559723871062,["GJX@GJXAIOU",[[1,2572,"\n"]],[2571,2571],[2572,2572]]],[1559723871191,["GJX@GJXAIOU",[[1,2573,"\n"]],[2572,2572],[2573,2573]]],[1559723871329,["GJX@GJXAIOU",[[1,2574,"\n"]],[2573,2573],[2574,2574]]],[1559723873005,["GJX@GJXAIOU",[[1,2573,"复杂度分析\n\n时间复杂度：O(\\log_{10}(n))O(log \n10\n​\t\n (n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(\\log_{10}(n))O(log \n10\n​\t\n (n))。\n空间复杂度：O(1)O(1)。"]],[2573,2573],[2697,2697]]],[1559723882065,["GJX@GJXAIOU",[[-1,2602,"(log \n10\n​\t\n (n))"]],[2602,2619],[2602,2602]]],[1559723883830,["GJX@GJXAIOU",[[-1,2601,"O"]],[2602,2602],[2601,2601]]],[1559723887640,["GJX@GJXAIOU",[[1,2586,"$"]],[2586,2586],[2587,2587]]],[1559723893608,["GJX@GJXAIOU",[[1,2602,"$"]],[2602,2602],[2603,2603]]],[1559723900952,["GJX@GJXAIOU",[[-1,2646,"O(log \n10\n​\t\n (n))"]],[2646,2664],[2646,2646]]],[1559723903344,["GJX@GJXAIOU",[[1,2631,"$"]],[2631,2631],[2632,2632]]],[1559723906105,["GJX@GJXAIOU",[[1,2647,"$"]],[2647,2647],[2648,2648]]],[1559723909368,["GJX@GJXAIOU",[[1,2656,"$"]],[2656,2656],[2657,2657]]],[1559723911736,["GJX@GJXAIOU",[[1,2661,"$"]],[2661,2661],[2662,2662]]],[1559723914775,["GJX@GJXAIOU",[[-1,2662,"O(1)"]],[2666,2666],[2662,2662]]],[1559723923458,["GJX@GJXAIOU",[[-1,3011,"\n"]],[2999,2999],[2999,2999]]],[1559723923954,["GJX@GJXAIOU",[[-1,3010,"\n"]],[2999,2999],[2999,2999]]],[1559723924003,["GJX@GJXAIOU",[[-1,3009,"\n"]],[2999,2999],[2999,2999]]],[1559723924031,["GJX@GJXAIOU",[[-1,3008,"\n"]],[2999,2999],[2999,2999]]],[1559723924060,["GJX@GJXAIOU",[[-1,3007,"\n"]],[2999,2999],[2999,2999]]],[1559723924132,["GJX@GJXAIOU",[[-1,3006,"\n"]],[2999,2999],[2999,2999]]],[1559723924158,["GJX@GJXAIOU",[[-1,3005,"\n"]],[2999,2999],[2999,2999]]],[1559723924185,["GJX@GJXAIOU",[[-1,3004,"\n"]],[2999,2999],[2999,2999]]],[1559723924256,["GJX@GJXAIOU",[[-1,3003,"\n"]],[2999,2999],[2999,2999]]],[1559723924282,["GJX@GJXAIOU",[[-1,3002,"\n"]],[2999,2999],[2999,2999]]],[1559723924307,["GJX@GJXAIOU",[[-1,3001,"\n"]],[2999,2999],[2999,2999]]],[1559723924333,["GJX@GJXAIOU",[[-1,3000,"\n"]],[2999,2999],[2999,2999]]],[1559723924356,["GJX@GJXAIOU",[[-1,2999,"\n"]],[2999,2999],[2999,2999]]],[1559723925677,["GJX@GJXAIOU",[[-1,2998,"\n"]],[2979,2979],[2979,2979]]],[1559723926178,["GJX@GJXAIOU",[[-1,2997,"\n"]],[2979,2979],[2979,2979]]],[1559723926220,["GJX@GJXAIOU",[[-1,2996,"\n"]],[2979,2979],[2979,2979]]],[1559723926247,["GJX@GJXAIOU",[[-1,2995,"\n"]],[2979,2979],[2979,2979]]],[1559723926288,["GJX@GJXAIOU",[[-1,2994,"\n"]],[2979,2979],[2979,2979]]],[1559723926331,["GJX@GJXAIOU",[[-1,2993,"\n"]],[2979,2979],[2979,2979]]],[1559723926760,["GJX@GJXAIOU",[[-1,2992,"\n"]],[2979,2979],[2979,2979]]],[1559723927095,["GJX@GJXAIOU",[[-1,2991,"\n"]],[2979,2979],[2979,2979]]],[1559723927382,["GJX@GJXAIOU",[[-1,2990,"\n"]],[2979,2979],[2979,2979]]],[1559723927544,["GJX@GJXAIOU",[[-1,2989,"\n"]],[2979,2979],[2979,2979]]],[1559723927734,["GJX@GJXAIOU",[[-1,2988,"\n"]],[2979,2979],[2979,2979]]],[1559723927927,["GJX@GJXAIOU",[[-1,2987,"\n"]],[2979,2979],[2979,2979]]],[1559723928102,["GJX@GJXAIOU",[[-1,2986,"\n"]],[2979,2979],[2979,2979]]],[1559723928286,["GJX@GJXAIOU",[[-1,2985,"\n"]],[2979,2979],[2979,2979]]],[1559723928463,["GJX@GJXAIOU",[[-1,2984,"\n"]],[2979,2979],[2979,2979]]],[1559723928678,["GJX@GJXAIOU",[[-1,2983,"\n"]],[2979,2979],[2979,2979]]],[1559723928905,["GJX@GJXAIOU",[[-1,2982,"\n"]],[2979,2979],[2979,2979]]],[1559723931569,["GJX@GJXAIOU",[[1,2987,"zhegnf"]],[2987,2987],[2993,2993]]],[1559723932750,["GJX@GJXAIOU",[[-1,2987,"zhegnf"]],[2993,2993],[2987,2987]]],[1559723942084,["GJX@GJXAIOU",[[1,2987,"整体上是第二种"]],[2987,2987],[2994,2994]]],[1559723944564,["GJX@GJXAIOU",[[1,2994,"方案"]],[2994,2994],[2996,2996]]],[1559723961478,["GJX@GJXAIOU",[[1,1384,"\n"]],[1384,1384],[1385,1385]]],[1559723961609,["GJX@GJXAIOU",[[1,1385,"\n"]],[1385,1385],[1386,1386]]],[1559723968604,["GJX@GJXAIOU",[[1,823,"（）"]],[823,823],[825,825]]],[1559723973332,["GJX@GJXAIOU",[[1,824,"缺点：可以"]],[824,824],[829,829]]],[1559723974518,["GJX@GJXAIOU",[[-1,827,"可以"]],[829,829],[827,827]]],[1559723977402,["GJX@GJXAIOU",[[1,827,"肯能"]],[827,827],[829,829]]],[1559723977937,["GJX@GJXAIOU",[[-1,827,"肯能"]],[829,829],[827,827]]],[1559723987161,["GJX@GJXAIOU",[[1,827,"可能反转的数大于intMax"]],[827,827],[841,841]]]],null,"GJX@GJXAIOU"],["20c81593-e978-4f4d-b6aa-922fe845e3ca",1560058678161,"---\n\ntags:\n\n  - \n\nflag: green\n\ndate: '2019-06-05 09:38'\n\n---\n\n\n# 3.回文数\n\n\n\n## 一、题目\n\n\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n示例 1:\n\n输入: 121\n输出: true\n示例 2:\n\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3:\n\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n进阶:\n\n你能不将整数转为字符串来解决这个问题吗？\n\n\n\n\n## 二、解答\n\n解法一：普通解法\n最好理解的一种解法就是先将 整数转为字符串 ，然后将字符串分割为数组，只需要循环数组的一半长度进行判断对应元素是否相等即可。\n\n动画描述\n![c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364]($resource/c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364.gif)\n\n\n代码实现\n```Java\n///简单粗暴，看看就行\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String reversedStr = (new StringBuilder(x + \"\")).reverse().toString();\n        return (x + \"\").equals(reversedStr);\n    }\n}\n```\n\n\n解法二：进阶解法---数学解法（缺点：可能反转的数大于intMax）\n通过取整和取余操作获取整数中对应的数字进行比较。\n\n举个例子：1221 这个数字。\n\n通过计算 1221 / 1000， 得首位1\n通过计算 1221 % 10， 可得末位 1\n进行比较\n再将 22 取出来继续比较\n动画描述\n![2]($resource/2.gif)\n\n代码实现\n```Java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        //边界判断\n        if (x < 0) return false;\n        int div = 1;\n        //\n        while (x / div >= 10) div *= 10;\n        while (x > 0) {\n            int left = x / div;\n            int right = x % 10;\n            if (left != right) return false;\n            x = (x % div) / 10;\n            div /= 100;\n        }\n        return true;\n    }\n}\n```\n\n\n解法三：进阶解法---巧妙解法\n直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。\n\n所以这个解法的操作就是 **取出后半段数字进行翻转**。\n\n这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。\n\n**具体做法如下：**\n\n* 每次进行取余操作 （ %10），取出最低的数字：y = x % 10\n* 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y\n* 每取一个最低位数字，x 都要自除以 10\n* 判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了\n* 最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n\n**动画描述**\n\n![3]($resource/3.png)\n\n**代码实现**\n```Java\npublic class Solution {\n    public bool IsPalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while(x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n}\n\n\n```\n\n复杂度分析\n\n时间复杂度：$O(\\log_{10}(n))$，对于每次迭代，我们会将输入除以10，因此时间复杂度为 $O(\\log_{10}(n))$。\n空间复杂度：$O(1)$。\n\n作者：MisterBooo\n链接：https://leetcode-cn.com/problems/two-sum/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/hui-wen-shu-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n个人解答：整体上是第二种方案\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        int y = x;\n        if (x >= 0) {\n        \tint rev = 0;\n            while(x != 0){\n            int pop = x % 10;\n            rev = rev * 10 + pop;\n            x = x / 10;\n            }\n            if (y == rev) {\n            \treturn true;\n            }else return false;\n        }else{\n        \treturn false;\n        }   \n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n",[[1560058647364,["GJX@GJXAIOU",[[1,16,"简单"]],[16,16],[18,18]]]],null,"GJX@GJXAIOU"],["66c6c2db-a3d5-4eac-a5a9-d117bf117366",1560157722349,"---\n\ntags:\n\n  - 简单\n\nflag: green\n\ndate: '2019-06-05 09:38'\n\n---\n\n\n# 3.回文数\n\n\n\n## 一、题目\n\n\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n示例 1:\n\n输入: 121\n输出: true\n示例 2:\n\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3:\n\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n进阶:\n\n你能不将整数转为字符串来解决这个问题吗？\n\n\n\n\n## 二、解答\n\n解法一：普通解法\n最好理解的一种解法就是先将 整数转为字符串 ，然后将字符串分割为数组，只需要循环数组的一半长度进行判断对应元素是否相等即可。\n\n动画描述\n![c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364]($resource/c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364.gif)\n\n\n代码实现\n```Java\n///简单粗暴，看看就行\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String reversedStr = (new StringBuilder(x + \"\")).reverse().toString();\n        return (x + \"\").equals(reversedStr);\n    }\n}\n```\n\n\n解法二：进阶解法---数学解法（缺点：可能反转的数大于intMax）\n通过取整和取余操作获取整数中对应的数字进行比较。\n\n举个例子：1221 这个数字。\n\n通过计算 1221 / 1000， 得首位1\n通过计算 1221 % 10， 可得末位 1\n进行比较\n再将 22 取出来继续比较\n动画描述\n![2]($resource/2.gif)\n\n代码实现\n```Java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        //边界判断\n        if (x < 0) return false;\n        int div = 1;\n        //\n        while (x / div >= 10) div *= 10;\n        while (x > 0) {\n            int left = x / div;\n            int right = x % 10;\n            if (left != right) return false;\n            x = (x % div) / 10;\n            div /= 100;\n        }\n        return true;\n    }\n}\n```\n\n\n解法三：进阶解法---巧妙解法\n直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。\n\n所以这个解法的操作就是 **取出后半段数字进行翻转**。\n\n这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。\n\n**具体做法如下：**\n\n* 每次进行取余操作 （ %10），取出最低的数字：y = x % 10\n* 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y\n* 每取一个最低位数字，x 都要自除以 10\n* 判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了\n* 最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n\n**动画描述**\n\n![3]($resource/3.png)\n\n**代码实现**\n```Java\npublic class Solution {\n    public bool IsPalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while(x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n}\n\n\n```\n\n复杂度分析\n\n时间复杂度：$O(\\log_{10}(n))$，对于每次迭代，我们会将输入除以10，因此时间复杂度为 $O(\\log_{10}(n))$。\n空间复杂度：$O(1)$。\n\n作者：MisterBooo\n链接：https://leetcode-cn.com/problems/two-sum/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/hui-wen-shu-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n个人解答：整体上是第二种方案\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        int y = x;\n        if (x >= 0) {\n        \tint rev = 0;\n            while(x != 0){\n            int pop = x % 10;\n            rev = rev * 10 + pop;\n            x = x / 10;\n            }\n            if (y == rev) {\n            \treturn true;\n            }else return false;\n        }else{\n        \treturn false;\n        }   \n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n",[[1560157702506,["GJX@GJXAIOU",[[-1,67,"3"]],[68,68],[67,67]]],[1560157703642,["GJX@GJXAIOU",[[1,67,"9"]],[67,67],[68,68]]]],null,"GJX@GJXAIOU"],["7d3d67b8-1d89-4577-9310-446bff427918",1561422876995,"---\n\ntags:\n\n  - 简单\n\nflag: green\n\ndate: '2019-06-05 09:38'\n\n---\n\n\n# 9.回文数\n\n\n\n## 一、题目\n\n\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n示例 1:\n\n输入: 121\n输出: true\n示例 2:\n\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3:\n\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n进阶:\n\n你能不将整数转为字符串来解决这个问题吗？\n\n\n\n\n## 二、解答\n\n解法一：普通解法\n最好理解的一种解法就是先将 整数转为字符串 ，然后将字符串分割为数组，只需要循环数组的一半长度进行判断对应元素是否相等即可。\n\n动画描述\n![c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364]($resource/c61f710e3bca59da3e00034e9553cbd6036adc4cba9e667e98f788d54a9ca1be-file_1558924390364.gif)\n\n\n代码实现\n```Java\n///简单粗暴，看看就行\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String reversedStr = (new StringBuilder(x + \"\")).reverse().toString();\n        return (x + \"\").equals(reversedStr);\n    }\n}\n```\n\n\n解法二：进阶解法---数学解法（缺点：可能反转的数大于intMax）\n通过取整和取余操作获取整数中对应的数字进行比较。\n\n举个例子：1221 这个数字。\n\n通过计算 1221 / 1000， 得首位1\n通过计算 1221 % 10， 可得末位 1\n进行比较\n再将 22 取出来继续比较\n动画描述\n![2]($resource/2.gif)\n\n代码实现\n```Java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        //边界判断\n        if (x < 0) return false;\n        int div = 1;\n        //\n        while (x / div >= 10) div *= 10;\n        while (x > 0) {\n            int left = x / div;\n            int right = x % 10;\n            if (left != right) return false;\n            x = (x % div) / 10;\n            div /= 100;\n        }\n        return true;\n    }\n}\n```\n\n\n解法三：进阶解法---巧妙解法\n直观上来看待回文数的话，就感觉像是将数字进行对折后看能否一一对应。\n\n所以这个解法的操作就是 **取出后半段数字进行翻转**。\n\n这里需要注意的一个点就是由于回文数的位数可奇可偶，所以当它的长度是偶数时，它对折过来应该是相等的；当它的长度是奇数时，那么它对折过来后，有一个的长度需要去掉一位数（除以 10 并取整）。\n\n**具体做法如下：**\n\n* 每次进行取余操作 （ %10），取出最低的数字：y = x % 10\n* 将最低的数字加到取出数的末尾：revertNum = revertNum * 10 + y\n* 每取一个最低位数字，x 都要自除以 10\n* 判断 x 是不是小于 revertNum ，当它小于的时候，说明数字已经对半或者过半了\n* 最后，判断奇偶数情况：如果是偶数的话，revertNum 和 x 相等；如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n\n**动画描述**\n\n![3]($resource/3.png)\n\n**代码实现**\n```Java\npublic class Solution {\n    public bool IsPalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while(x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n}\n\n\n```\n\n复杂度分析\n\n时间复杂度：$O(\\log_{10}(n))$，对于每次迭代，我们会将输入除以10，因此时间复杂度为 $O(\\log_{10}(n))$。\n空间复杂度：$O(1)$。\n\n作者：MisterBooo\n链接：https://leetcode-cn.com/problems/two-sum/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/hui-wen-shu-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n个人解答：整体上是第二种方案\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        int y = x;\n        if (x >= 0) {\n        \tint rev = 0;\n            while(x != 0){\n            int pop = x % 10;\n            rev = rev * 10 + pop;\n            x = x / 10;\n            }\n            if (y == rev) {\n            \treturn true;\n            }else return false;\n        }else{\n        \treturn false;\n        }   \n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n",[[1561422822309,["GJX@GJXAIOU",[[-1,11,"\n"]],[11,11],[10,10]]],[1561422824527,["GJX@GJXAIOU",[[-1,4,"\n"]],[4,4],[3,3]]],[1561422832144,["GJX@GJXAIOU",[[1,17," - 完成"]],[17,17],[22,22]]],[1561422835543,["GJX@GJXAIOU",[[-1,11," "]],[12,12],[11,11]]],[1561422838637,["GJX@GJXAIOU",[[1,22," \n"]],[21,21],[23,23]]],[1561422840313,["GJX@GJXAIOU",[[1,23,"- 数组"]],[23,23],[27,27]]],[1561422845208,["GJX@GJXAIOU",[[1,40,"style："]],[40,40],[46,46]]],[1561422846182,["GJX@GJXAIOU",[[-1,45,"："]],[46,46],[45,45]]],[1561422849191,["GJX@GJXAIOU",[[1,45,": summer"]],[45,45],[53,53]]]],null,"GJX@GJXAIOU"]]}