{"compress":true,"commitItems":[["8b08be58-b298-43cf-b080-33f1b42055f9",1562850437001,"",[[1562850405490,["GJX@GJXAIOU",[[1,0,"# 914.卡牌分组\n\n\n\n"]],[0,0],[13,13]]],[1562850419555,["GJX@GJXAIOU",[[1,12,"## 一、题解"]],[12,12],[19,19]]],[1562850419815,["GJX@GJXAIOU",[[1,21,"\n"]],[19,19],[20,20]]],[1562850420768,["GJX@GJXAIOU",[[-1,21,"\n"]],[20,20],[19,19]]],[1562850421169,["GJX@GJXAIOU",[[-1,17,"题解"]],[19,19],[17,17]]],[1562850422786,["GJX@GJXAIOU",[[1,17,"题目"]],[17,17],[19,19]]],[1562850423047,["GJX@GJXAIOU",[[1,21,"\n"]],[19,19],[20,20]]],[1562850424483,["GJX@GJXAIOU",[[1,20,"给定一副牌，每张牌上都写着一个整数。\n\n此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：\n\n每组都有 X 张牌。\n组内所有的牌上都写着相同的整数。\n仅当你可选的 X >= 2 时返回 true。\n\n \n\n示例 1：\n\n输入：[1,2,3,4,4,3,2,1]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]\n示例 2：\n\n输入：[1,1,1,2,2,2,3,3]\n输出：false\n解释：没有满足要求的分组。\n示例 3：\n\n输入：[1]\n输出：false\n解释：没有满足要求的分组。\n示例 4：\n\n输入：[1,1]\n输出：true\n解释：可行的分组是 [1,1]\n示例 5：\n\n输入：[1,1,2,2,2,2]\n输出：true\n解释：可行的分组是 [1,1]，[2,2]，[2,2]\n\n提示：\n\n1 <= deck.length <= 10000\n0 <= deck[i] < 10000\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[20,20],[567,567]]],[1562850427438,["GJX@GJXAIOU",[[1,569,"\n"]],[567,567],[568,568]]],[1562850427552,["GJX@GJXAIOU",[[1,570,"\n"]],[568,568],[569,569]]],[1562850427665,["GJX@GJXAIOU",[[1,571,"\n"]],[569,569],[570,570]]],[1562850428171,["GJX@GJXAIOU",[[1,570,"## "]],[570,570],[573,573]]],[1562850431045,["GJX@GJXAIOU",[[-1,86," X "],[1,89," X "],[-1,127," "],[1,128," "],[-1,135," "],[1,136," "],[-1,442," "],[1,443," "],[1,573,"二、解答"]],[573,573],[577,577]]],[1562850435391,["GJX@GJXAIOU",[[-1,144,"\n"]],[144,144],[143,143]]],[1562850436344,["GJX@GJXAIOU",[[-1,213,"\n"]],[213,213],[212,212]]],[1562850437400,["GJX@GJXAIOU",[[1,207,"\n"]],[207,207],[208,208]]],[1562850441073,["GJX@GJXAIOU",[[1,138,"- "]],[138,138],[140,140]]],[1562850442203,["GJX@GJXAIOU",[[1,210,"- "]],[210,210],[212,212]]],[1562850444172,["GJX@GJXAIOU",[[1,262,"- "]],[262,262],[264,264]]],[1562850445336,["GJX@GJXAIOU",[[-1,270,"\n"]],[270,270],[269,269]]],[1562850447784,["GJX@GJXAIOU",[[1,262,"\n"]],[262,262],[263,263]]],[1562850449842,["GJX@GJXAIOU",[[1,301,"\n"]],[301,301],[302,302]]],[1562850450865,["GJX@GJXAIOU",[[1,302,"- "]],[302,302],[304,304]]],[1562850451812,["GJX@GJXAIOU",[[1,310,"-"]],[310,310],[311,311]]],[1562850452858,["GJX@GJXAIOU",[[-1,310,"-"]],[311,311],[310,310]]],[1562850453096,["GJX@GJXAIOU",[[-1,310,"\n"]],[310,310],[309,309]]],[1562850454808,["GJX@GJXAIOU",[[1,343,"\n"]],[343,343],[344,344]]],[1562850456657,["GJX@GJXAIOU",[[1,344,"- "]],[344,344],[346,346]]],[1562850457858,["GJX@GJXAIOU",[[-1,352,"\n"]],[352,352],[351,351]]],[1562850459608,["GJX@GJXAIOU",[[-1,410,"\n"]],[410,410],[409,409]]],[1562850461176,["GJX@GJXAIOU",[[1,406,"- "]],[406,406],[408,408]]],[1562850463079,["GJX@GJXAIOU",[[-1,406,"- "]],[408,408],[406,406]]],[1562850473905,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1562850476712,["GJX@GJXAIOU",[[1,0,"---\ntags: \n- 简单\n- 参考\n- 数组\nflag: green\nstyle: summer\ndate: '2019-7-11'\n---"]],[0,0],[73,73]]],[1562850589263,["GJX@GJXAIOU",[[1,26,"\n"]],[25,25],[26,26]]],[1562850591291,["GJX@GJXAIOU",[[1,26,"- 属性"]],[26,26],[30,30]]],[1562850592450,["GJX@GJXAIOU",[[-1,28,"属性"]],[30,30],[28,28]]],[1562850593635,["GJX@GJXAIOU",[[1,28,"数学"]],[28,28],[30,30]]],[1562851662393,["GJX@GJXAIOU",[[1,666,"\n"]],[665,665],[666,666]]],[1562851662734,["GJX@GJXAIOU",[[-1,666,"\n"],[1,667,"-"]],[666,666],[667,667]]],[1562851667500,["GJX@GJXAIOU",[[1,667," 解法一；\n- "]],[667,667],[675,675]]],[1562851668162,["GJX@GJXAIOU",[[-1,674," "]],[675,675],[674,674]]],[1562851668289,["GJX@GJXAIOU",[[-1,673,"-"],[1,674,"\n"]],[674,674],[673,673]]],[1562851669394,["GJX@GJXAIOU",[[-1,673,"\n"],[1,674,"`"]],[673,673],[674,674]]],[1562851669763,["GJX@GJXAIOU",[[1,674,"``"]],[674,674],[676,676]]],[1562851669788,["GJX@GJXAIOU",[[1,676,"language\n```\n"]],[676,676],[676,684]]],[1562851670738,["GJX@GJXAIOU",[[-1,676,"language"],[1,684,"j"]],[676,684],[677,677]]],[1562851671146,["GJX@GJXAIOU",[[1,677,"ava"]],[677,677],[680,680]]],[1562851671217,["GJX@GJXAIOU",[[1,681,"\n"]],[680,680],[681,681]]],[1562851672330,["GJX@GJXAIOU",[[1,681,"class Solution {\n   public static boolean hasGroupsSizeX(int[] deck) {\n        if (deck == null || deck.length == 0) return false;\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        for (int i : deck) {\n            hashMap.put(i, hashMap.getOrDefault(i, 0) + 1);\n        }\n        List<Integer> list = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {\n            list.add(entry.getValue());\n        }\n        Collections.sort(list);\n        int min = list.get(0);\n        boolean isX = false;\n        for (int i = 2; i <= min; i++) {\n            for (Integer j : list) {\n                if (j % i != 0) {\n                    isX = false;\n                    break;\n                }\n                isX = true;\n            }\n            if (isX) return true;\n        }\n        return false;\n    }\n}"]],[681,681],[1538,1538]]],[1562851684345,["GJX@GJXAIOU",[[1,1543,"\n"]],[1542,1542],[1543,1543]]],[1562851684473,["GJX@GJXAIOU",[[1,1544,"\n"]],[1543,1543],[1544,1544]]],[1562851684843,["GJX@GJXAIOU",[[1,1544,"执行用时 :26 ms, 在所有 Java 提交中击败了54.06%的用户\n\n内存消耗 :47.5 MB, 在所有 Java 提交中击败了66.06%的用户"]],[1544,1544],[1622,1622]]],[1562851739569,["GJX@GJXAIOU",[[1,666,"\n"]],[665,665],[666,666]]],[1562851739713,["GJX@GJXAIOU",[[1,667,"\n"]],[666,666],[667,667]]],[1562851740035,["GJX@GJXAIOU",[[1,667,"-"],[-1,1562," "],[1,1563," "],[-1,1567," "],[1,1568," "],[-1,1603," "],[1,1604," "],[-1,1608," "],[1,1609," "]],[667,667],[668,668]]],[1562851741769,["GJX@GJXAIOU",[[1,668," jiefa "]],[668,668],[675,675]]],[1562851743107,["GJX@GJXAIOU",[[-1,669,"jiefa "]],[675,675],[669,669]]],[1562851745140,["GJX@GJXAIOU",[[1,669,"解法一；"]],[669,669],[673,673]]],[1562851745408,["GJX@GJXAIOU",[[1,676,"\n- "]],[673,673],[676,676]]],[1562851746392,["GJX@GJXAIOU",[[-1,674,"- "]],[676,676],[674,674]]],[1562851749025,["GJX@GJXAIOU",[[1,674,"```java"]],[674,674],[681,681]]],[1562851749220,["GJX@GJXAIOU",[[1,682,"\n"]],[681,681],[682,682]]],[1562851749616,["GJX@GJXAIOU",[[1,683,"\n"]],[682,682],[683,683]]],[1562851749810,["GJX@GJXAIOU",[[1,684,"\n"]],[683,683],[684,684]]],[1562851750765,["GJX@GJXAIOU",[[1,684,"```"]],[684,684],[687,687]]],[1562851752747,["GJX@GJXAIOU",[[1,682,"class Solution { public boolean hasGroupsSizeX(int[] deck) { if (deck.length<=1){ return  false; } if (deck.length==2){ return deck[0]==deck[1]; } int max = Integer.MIN_VALUE; for (int i=0;i<deck.length;i++){ max = max<deck[i] ? deck[i] : max; } int[] ints = new  int[max+1]; Arrays.fill(ints,0); max = Integer.MAX_VALUE; for (int i=0;i<deck.length;i++){ ints[deck[i]]++; } for (int i=0;i<ints.length;i++){ if (ints[i] == 0){ continue; } if (ints[i] == 1){ return  false; } max = max<ints[i]?max:ints[i]; } for (int i=0;i<ints.length;i++){ if (ints[i] == 0){ continue; } if (ints[i]%max!=0){ int b = ints[i]; int a = max; while(b!=0) { int r=a%b; a=b; b=r; } if (a>=2){ continue; } return  false; } } return  true; } }"]],[682,682],[1400,1400]]],[1562851757086,["GJX@GJXAIOU",[[1,698,"\n   "],[1,742,"\n               "],[1,763,"\n           "],[-1,771," "],[1,778,"\n       "],[1,780,"\n       "],[1,801,"\n           "],[1,826,"\n       "],[1,828,"\n       "],[1,857,"\n       "],[1,890,"\n           "],[1,925,"\n       "],[1,927,"\n\n       "],[-1,945," "],[1,957,"\n       "],[1,978,"\n       "],[1,1003,"\n       "],[1,1036,"\n           "],[1,1053,"\n       "],[1,1055,"\n       "],[1,1088,"\n           "],[1,1107,"\n               "],[1,1117,"\n           "],[1,1119,"\n           "],[1,1138,"\n               "],[-1,1145," "],[1,1153,"\n           "],[1,1155,"\n           "],[1,1186,"\n       "],[1,1188,"\n       "],[1,1221,"\n           "],[1,1240,"\n               "],[1,1250,"\n           "],[1,1252,"\n           "],[1,1273,"\n               "],[1,1290,"\n               "],[1,1303,"\n               "],[1,1315,"\n               "],[1,1317,"\n                   "],[1,1328,"\n                   "],[1,1333,"\n                   "],[1,1338,"\n               "],[1,1340,"\n               "],[1,1351,"\n                   "],[1,1361,"\n               "],[1,1363,"\n               "],[-1,1370," "],[1,1378,"\n           "],[1,1380,"\n       "],[1,1382,"\n       "],[-1,1389," "],[1,1396,"\n"],[-1,1397,"}"],[1,1399,"  }\n"]],[682,1400],[1960,1960]]],[1562851760368,["GJX@GJXAIOU",[[1,1966,"\n"]],[1965,1965],[1966,1966]]],[1562851760499,["GJX@GJXAIOU",[[1,1967,"\n"]],[1966,1966],[1967,1967]]],[1562851762713,["GJX@GJXAIOU",[[1,1967,"- jiefa"]],[1967,1967],[1974,1974]]],[1562851763584,["GJX@GJXAIOU",[[-1,1969,"jiefa"]],[1974,1974],[1969,1969]]],[1562851765861,["GJX@GJXAIOU",[[1,1969,"解法二："]],[1969,1969],[1973,1973]]],[1562851766144,["GJX@GJXAIOU",[[1,1976,"\n- "]],[1973,1973],[1976,1976]]],[1562851767352,["GJX@GJXAIOU",[[-1,1974,"- "]],[1976,1976],[1974,1974]]],[1562851768626,["GJX@GJXAIOU",[[1,1974,"```"]],[1974,1974],[1977,1977]]],[1562851769521,["GJX@GJXAIOU",[[1,1978,"\n"]],[1977,1977],[1978,1978]]],[1562851769671,["GJX@GJXAIOU",[[1,1979,"\n"]],[1978,1978],[1979,1979]]],[1562851770370,["GJX@GJXAIOU",[[1,1979,"```"]],[1979,1979],[1982,1982]]],[1562851800324,["GJX@GJXAIOU",[[1,1978,"class Solution { public boolean hasGroupsSizeX(int[] deck) { if(deck == null || deck.length<=1) return  false; //sort the array Arrays.sort(deck); //calculate the number of every digit  int current = 1; int count = 1; int preRest = -1; for(int i=1; i<deck.length; i++) { if(deck[i] == deck[i-1]) count++; else { if(preRest == -1) preRest = count; else preRest = getRest(count, preRest); if(preRest < 2) return  false; count = 1; current = deck[i]; } } if(preRest == -1) return count>=2; else  return getRest(preRest, count) >= 2; } private int getRest(int x, int y) { if(y == 0) { return x; } return getRest(y, x%y); } }"]],[1978,1978],[2598,2598]]],[1562851802241,["GJX@GJXAIOU",[[-1,1978,"class Solution { public boolean hasGroupsSizeX(int[] deck) { if(deck == null || deck.length<=1) return  false; //sort the array Arrays.sort(deck); //calculate the number of every digit  int current = 1; int count = 1; int preRest = -1; for(int i=1; i<deck.length; i++) { if(deck[i] == deck[i-1]) count++; else { if(preRest == -1) preRest = count; else preRest = getRest(count, preRest); if(preRest < 2) return  false; count = 1; current = deck[i]; } } if(preRest == -1) return count>=2; else  return getRest(preRest, count) >= 2; } private int getRest(int x, int y) { if(y == 0) { return x; } return getRest(y, x%y); } }"]],[2598,2598],[1978,1978]]],[1562851804290,["GJX@GJXAIOU",[[1,1978,"class Solution {\n    public boolean hasGroupsSizeX(int[] deck) {\n        if(deck == null || deck.length<=1) return false;\n        \n        //sort the array\n        Arrays.sort(deck);\n        //calculate the number of every digit\n        int current = 1;\n        int count = 1;\n        int preRest = -1;\n        for(int i=1; i<deck.length; i++) {\n            if(deck[i] == deck[i-1]) count++;\n            else {\n                if(preRest == -1) preRest = count;\n                else preRest = getRest(count, preRest);\n                if(preRest < 2) return false;\n                count = 1;\n                current = deck[i];\n            }\n        }\n        if(preRest == -1) return count>=2;\n        else return getRest(preRest, count) >= 2;\n    }\n    \n    private int getRest(int x, int y) {\n        if(y == 0) {\n            return x;\n        }\n        return getRest(y, x%y);\n    }\n}"]],[1978,1978],[2864,2864]]],[1562851807467,["GJX@GJXAIOU",[[-1,2873,"一"]],[2874,2874],[2873,2873]]],[1562851808002,["GJX@GJXAIOU",[[1,2873,"s"]],[2873,2873],[2874,2874]]],[1562851808029,["GJX@GJXAIOU",[[1,2873," "]],[2874,2874],[2875,2875]]],[1562851808291,["GJX@GJXAIOU",[[1,2875,"an"]],[2875,2875],[2877,2877]]],[1562851809769,["GJX@GJXAIOU",[[-1,2873," san"]],[2877,2877],[2873,2873]]],[1562851810706,["GJX@GJXAIOU",[[1,2873,"s"]],[2873,2873],[2874,2874]]],[1562851810733,["GJX@GJXAIOU",[[1,2873," "]],[2874,2874],[2875,2875]]],[1562851810970,["GJX@GJXAIOU",[[1,2875,"an"]],[2875,2875],[2877,2877]]],[1562851812416,["GJX@GJXAIOU",[[-1,2874,"san"]],[2877,2877],[2874,2874]]],[1562851814206,["GJX@GJXAIOU",[[1,2874,"三"]],[2874,2874],[2875,2875]]],[1562851849585,["GJX@GJXAIOU",[[1,2869,"\n"]],[2868,2868],[2869,2869]]],[1562851849752,["GJX@GJXAIOU",[[1,2870,"\n"]],[2869,2869],[2870,2870]]],[1562851850177,["GJX@GJXAIOU",[[1,2870,"的用户\n\n内存消耗 :46.5 MB, 在所有 Java 提交中击败了73.85%的用户"]],[2870,2870],[2914,2914]]],[1562851856877,["GJX@GJXAIOU",[[-1,2870,"的用户\n\n内存消耗 :46.5 MB, 在所有 Java 提交中击败了73.85%的用户"]],[2914,2914],[2870,2870]]],[1562851866721,["GJX@GJXAIOU",[[1,2869,"执行用时 :6 ms, 在所有 Java 提交中击败了94.40%的用户\n\n内存消耗 :46.5 MB, 在所有 Java 提交中击败了73.85%的用户"]],[2869,2869],[2946,2946]]],[1562851895585,["GJX@GJXAIOU",[[1,1966,"执行用时 :2 ms, 在所有 Java 提交中击败了100.00%的用户\n\n内存消耗 :39 MB, 在所有 Java 提交中击败了91.28%的用户"]],[1966,1966],[2042,2042]]],[1562851897593,["GJX@GJXAIOU",[[1,2043,"\n"]],[2042,2042],[2043,2043]]],[1562851901155,["GJX@GJXAIOU",[[-1,672,"；"]],[673,673],[672,672]]],[1562851907422,["GJX@GJXAIOU",[[1,666,"整体"],[-1,1980," "],[1,1981," "],[-1,1985," "],[1,1986," "],[-1,2020," "],[1,2021," "],[-1,2025," "],[1,2026," "],[-1,2960," "],[1,2961," "],[-1,2965," "],[1,2966," "],[-1,3001," "],[1,3002," "],[-1,3006," "],[1,3007," "]],[666,666],[668,668]]],[1562851914707,["GJX@GJXAIOU",[[1,668,"思路：最大公约数"]],[668,668],[676,676]]],[1562851921499,["GJX@GJXAIOU",[[1,3042,"- \n"]],[3041,3041],[3044,3044]]],[1562851922392,["GJX@GJXAIOU",[[-1,3042,"- "]],[3044,3044],[3042,3042]]],[1562851935521,["GJX@GJXAIOU",[[1,3042,"### 利用数组下标法找元素，利用TreeSet去重排序，然后找所有相同的个数是否有最小公约数"]],[3042,3042],[3089,3089]]],[1562851937610,["GJX@GJXAIOU",[[-1,3042,"### "]],[3042,3046],[3042,3042]]],[1562852043805,["GJX@GJXAIOU",[[1,2063,"Java"]],[2063,2063],[2067,2067]]],[1562854278355,["GJX@GJXAIOU",[[1,691,"import java.util.Arrays;\n\n"],[-1,764,"    "],[1,768,"//特殊情况\n"],[1,772,"\t"],[1,793," "],[1,905,"        \n        //寻找数组中最大值\n"],[-1,1001,"max<"],[1,1012," > max"],[1,1106," //将指定的int值(这里为0)分配给指定的int数组的每个元素：Arrays.fill(int[] a , int val);\n        \n        \n        //将ints数组中，下标等于deck[]数组值的元素置为1；"],[1,1220,"        \n        //相当于ints[i]值为每个元素出现的数目，只能是>=2或者 = 0\n"],[1,1407,"            //返回元素出现最多的次数\n"],[1,1460,"        \n"],[-1,1969,"\n"],[1,1970,""]],[691,1970],[2242,2242]]]],null,"GJX@GJXAIOU"]]}