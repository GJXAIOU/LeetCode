{"compress":true,"commitItems":[["e59e7702-9456-451c-81ed-f698fe2e9671",1561295934541,"",[[1561295884470,["GJX@GJXAIOU",[[1,0,"# 283.移动零\n\n\n\n"]],[0,0],[12,12]]],[1561295887268,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1561295887392,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1561295889322,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1561295889452,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1561295889586,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1561295889608,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1561295894113,["GJX@GJXAIOU",[[1,4,"tags: "]],[4,4],[10,10]]],[1561295894392,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1561295897513,["GJX@GJXAIOU",[[1,11,"- jian"]],[11,11],[17,17]]],[1561295898288,["GJX@GJXAIOU",[[-1,13,"jian"]],[17,17],[13,13]]],[1561295899820,["GJX@GJXAIOU",[[1,13,"简答"]],[13,13],[15,15]]],[1561295900090,["GJX@GJXAIOU",[[1,16,"\n"]],[15,15],[16,16]]],[1561295901512,["GJX@GJXAIOU",[[1,16,"- "]],[16,16],[18,18]]],[1561295901968,["GJX@GJXAIOU",[[1,19,"\n"]],[18,18],[19,19]]],[1561295904965,["GJX@GJXAIOU",[[1,19,"- 数组"]],[19,19],[23,23]]],[1561295905764,["GJX@GJXAIOU",[[1,24,"\n"]],[23,23],[24,24]]],[1561295909644,["GJX@GJXAIOU",[[1,24,"fa"]],[24,24],[26,26]]],[1561295910402,["GJX@GJXAIOU",[[-1,25,"a"]],[26,26],[25,25]]],[1561295918624,["GJX@GJXAIOU",[[1,25,"lag: summer"]],[25,25],[36,36]]],[1561295919155,["GJX@GJXAIOU",[[1,37,"\n"]],[36,36],[37,37]]],[1561295921768,["GJX@GJXAIOU",[[1,37,"stu"]],[37,37],[40,40]]],[1561295922229,["GJX@GJXAIOU",[[-1,39,"u"]],[40,40],[39,39]]],[1561295927275,["GJX@GJXAIOU",[[1,39,"yle: "]],[39,39],[44,44]]],[1561295937881,["GJX@GJXAIOU",[[-1,30,"summer"],[1,36,"g"]],[30,36],[31,31]]],[1561295938937,["GJX@GJXAIOU",[[1,31,"reen"]],[31,31],[35,35]]],[1561295942001,["GJX@GJXAIOU",[[1,43,"summer"]],[43,43],[49,49]]],[1561295942460,["GJX@GJXAIOU",[[1,50,"\n"]],[49,49],[50,50]]],[1561295957673,["GJX@GJXAIOU",[[1,50,"date: '2019-6-23'"]],[50,50],[67,67]]],[1561295964011,["GJX@GJXAIOU",[[1,85,"## y"]],[85,85],[89,89]]],[1561295964314,["GJX@GJXAIOU",[[-1,88,"y"]],[89,89],[88,88]]],[1561295965684,["GJX@GJXAIOU",[[1,88,"题目"]],[88,88],[90,90]]],[1561295965988,["GJX@GJXAIOU",[[1,92,"\n"]],[90,90],[91,91]]],[1561295966595,["GJX@GJXAIOU",[[1,93,"\n"]],[91,91],[92,92]]],[1561295975762,["GJX@GJXAIOU",[[1,93,"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组。\n尽量减少操作次数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/move-zeroes\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[93,93],[316,316]]],[1561295987253,["GJX@GJXAIOU",[[1,181,"\n"]],[181,181],[182,182]]],[1561295989080,["GJX@GJXAIOU",[[-1,146,"\n"]],[146,146],[145,145]]],[1561295991146,["GJX@GJXAIOU",[[-1,185,"\n"]],[185,185],[184,184]]],[1561295992980,["GJX@GJXAIOU",[[1,142,"- "]],[142,142],[144,144]]],[1561295998128,["GJX@GJXAIOU",[[1,183,"* "],[1,187,"* "],[1,208,"* "]],[183,216],[185,222]]],[1561296004244,["GJX@GJXAIOU",[[1,189,"  "]],[189,189],[191,191]]],[1561296004944,["GJX@GJXAIOU",[[1,214,"  "]],[215,215],[217,217]]],[1561296018613,["GJX@GJXAIOU",[[1,328,"\n"]],[327,327],[328,328]]],[1561296018752,["GJX@GJXAIOU",[[1,329,"\n"]],[328,328],[329,329]]],[1561296019922,["GJX@GJXAIOU",[[-1,329,"\n"],[1,330,"#"]],[329,329],[330,330]]],[1561296020968,["GJX@GJXAIOU",[[-1,329,"#"],[1,330,"\n"]],[330,330],[329,329]]],[1561296022442,["GJX@GJXAIOU",[[-1,329,"\n"],[1,330,"@"]],[329,329],[330,330]]],[1561296023256,["GJX@GJXAIOU",[[-1,329,"@"],[1,330,"\n"]],[330,330],[329,329]]],[1561296026078,["GJX@GJXAIOU",[[1,329,"## 解答"]],[329,329],[334,334]]],[1561296026709,["GJX@GJXAIOU",[[1,335,"\n"]],[334,334],[335,335]]],[1561296026895,["GJX@GJXAIOU",[[1,336,"\n"]],[335,335],[336,336]]],[1561296027029,["GJX@GJXAIOU",[[1,337,"\n"]],[336,336],[337,337]]],[1561296028794,["GJX@GJXAIOU",[[1,329,"\n"]],[328,328],[329,329]]],[1561296028909,["GJX@GJXAIOU",[[1,330,"\n"]],[329,329],[330,330]]],[1561297425976,["GJX@GJXAIOU",[[1,340,"\n"]],[338,338],[339,339]]],[1561297426105,["GJX@GJXAIOU",[[1,341,"\n"]],[339,339],[340,340]]],[1561297429484,["GJX@GJXAIOU",[[1,340,"- 自己解答"]],[340,340],[346,346]]],[1561297431032,["GJX@GJXAIOU",[[1,347,"- \n"]],[346,346],[349,349]]],[1561297432442,["GJX@GJXAIOU",[[-1,347,"- "]],[349,349],[347,347]]],[1561297433971,["GJX@GJXAIOU",[[1,347,"```"]],[347,347],[350,350]]],[1561297433996,["GJX@GJXAIOU",[[1,350,"language\n```\n"]],[350,350],[350,358]]],[1561297435433,["GJX@GJXAIOU",[[-1,350,"language"],[1,358,"j"]],[350,358],[351,351]]],[1561297435892,["GJX@GJXAIOU",[[1,351,"ava"]],[351,351],[354,354]]],[1561297435913,["GJX@GJXAIOU",[[1,355,"\n"]],[354,354],[355,355]]],[1561297437369,["GJX@GJXAIOU",[[1,355,"//将一个数组中的0移动到数组尾部，保持其他非零元素相对位置不变；本地操作\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        //合法性判断\n        if (nums == null) {\n\n        }\n        //思路：双指针\n        int front = 0;\n        int after = 0;\n\n        //得到第一个不为0元素的下标\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                front = i;\n                after = i+1;\n                break;\n            }\n\n        }\n\n        //从该元素开始，逐个遍历替换\n        while (after < nums.length) {            \n            if (nums[after] != 0) {\n                int temp = nums[front];\n                nums[front] = nums[after];\n                nums[after] = temp;\n\n                front++;\n            }\n            after++;\n\n        }\n\n    }\n}"]],[355,355],[1088,1088]]],[1561297439168,["GJX@GJXAIOU",[[1,347,"- \n"]],[346,346],[349,349]]],[1561297440201,["GJX@GJXAIOU",[[-1,347,"- "]],[349,349],[347,347]]],[1561297457013,["GJX@GJXAIOU",[[1,1096,"\n"]],[1093,1093],[1094,1094]]],[1561297457531,["GJX@GJXAIOU",[[1,1097,"\n"]],[1094,1094],[1095,1095]]],[1561297458733,["GJX@GJXAIOU",[[1,1095,"执行用时 :1 ms, 在所有 Java 提交中击败了96.23%的用户\n\n内存消耗 :41.3 MB, 在所有 Java 提交中击败了43.09%的用户"]],[1095,1095],[1172,1172]]],[1561297463493,["GJX@GJXAIOU",[[1,1095,"-"],[-1,1110," "],[1,1111," "],[-1,1115," "],[1,1116," "],[-1,1151," "],[1,1152," "],[-1,1156," "],[1,1157," "]],[1095,1095],[1096,1096]]],[1561297463642,["GJX@GJXAIOU",[[1,1096," "]],[1096,1096],[1097,1097]]],[1561297466261,["GJX@GJXAIOU",[[1,1135,"- "]],[1135,1135],[1137,1137]]],[1561297469301,["GJX@GJXAIOU",[[1,340,"\n"]],[337,337],[338,338]]],[1561297469434,["GJX@GJXAIOU",[[1,341,"\n"]],[338,338],[339,339]]],[1561297475092,["GJX@GJXAIOU",[[1,18,"wan"]],[18,18],[21,21]]],[1561297475871,["GJX@GJXAIOU",[[-1,18,"wan"]],[21,21],[18,18]]],[1561297477508,["GJX@GJXAIOU",[[1,18,"完成"]],[18,18],[20,20]]],[1561297574445,["GJX@GJXAIOU",[[1,340,"- 解法一：双指针，"]],[340,340],[350,350]]],[1561297593172,["GJX@GJXAIOU",[[1,350,"将非零的逐个移到前面，后面全部补0"]],[350,350],[367,367]]],[1561297593750,["GJX@GJXAIOU",[[1,368,"- \n"]],[367,367],[370,370]]],[1561297594813,["GJX@GJXAIOU",[[-1,368,"- "]],[370,370],[368,368]]],[1561297601441,["GJX@GJXAIOU",[[1,368,"思路：可以先把所有非0的元素移到前面，然后将后面的位置补0。 使用指针i，指向需要插入的下标，使用指针j指向遍历的下标。遍历一遍，如果j指向的位置为0，则i不变，j++后移；如果j指向的位置不为0，则将j位置的元素值赋值到i位置，然后i++。\n\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        //i:插入位置下标 ; j:查找位置下标\n        int i = 0; \n        for(int j = 0; j < nums.length; j++){\n            if(nums[j] != 0){\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        //将后面的位置补0\n        for(int p = i; p < nums.length; p++){\n            nums[p] = 0;\n        }\n    }\n}\n\n作者：stonewang-2\n链接：https://leetcode-cn.com/problems/two-sum/solution/javashi-yong-2ge-xia-biao-zhi-zhen-fu-zhi-zui-shao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[368,368],[1034,1034]]],[1561297606322,["GJX@GJXAIOU",[[1,449,"`"]],[449,449],[450,450]]],[1561297608997,["GJX@GJXAIOU",[[1,453,"`"]],[453,453],[454,454]]],[1561297609955,["GJX@GJXAIOU",[[1,487,"`"]],[487,487],[488,488]]],[1561297610867,["GJX@GJXAIOU",[[1,491,"`"]],[491,491],[492,492]]],[1561297615020,["GJX@GJXAIOU",[[1,494,"```java"]],[494,494],[501,501]]],[1561297618218,["GJX@GJXAIOU",[[1,874,"```"]],[874,874],[877,877]]],[1561297650947,["GJX@GJXAIOU",[[-1,998,"来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[998,1047],[998,998]]],[1561297652969,["GJX@GJXAIOU",[[1,878,"\n"]],[877,877],[878,878]]],[1561297653108,["GJX@GJXAIOU",[[1,879,"\n"]],[878,878],[879,879]]],[1561297654207,["GJX@GJXAIOU",[[1,879,"执行用时 :1 ms, 在所有 Java 提交中击败了96.23%的用户\n\n内存消耗 :41 MB, 在所有 Java 提交中击败了46.43%的用户"]],[879,879],[954,954]]],[1561297656281,["GJX@GJXAIOU",[[1,955,"\n"]],[954,954],[955,955]]],[1561297658698,["GJX@GJXAIOU",[[1,879,"-"],[-1,894," "],[1,895," "],[-1,899," "],[1,900," "],[-1,933," "],[1,934," "],[-1,938," "],[1,939," "]],[879,879],[880,880]]],[1561297658825,["GJX@GJXAIOU",[[1,880," "]],[880,880],[881,881]]],[1561297660714,["GJX@GJXAIOU",[[1,919,"- "]],[919,919],[921,921]]],[1561297673145,["GJX@GJXAIOU",[[-1,918,"\n"]],[918,918],[917,917]]],[1561297677729,["GJX@GJXAIOU",[[1,368,"**"],[1,370,"**"]],[368,370],[368,374]]],[1561297793729,["GJX@GJXAIOU",[[1,340,"\n"]],[339,339],[340,340]]],[1561297793890,["GJX@GJXAIOU",[[1,341,"\n"]],[340,340],[341,341]]],[1561297794050,["GJX@GJXAIOU",[[1,342,"\n"]],[341,341],[342,342]]],[1561297794544,["GJX@GJXAIOU",[[1,343,"\n"]],[342,342],[343,343]]],[1561297794575,["GJX@GJXAIOU",[[1,344,"\n"]],[343,343],[344,344]]],[1561297794602,["GJX@GJXAIOU",[[1,345,"\n"]],[344,344],[345,345]]],[1561297794641,["GJX@GJXAIOU",[[1,346,"\n"]],[345,345],[346,346]]],[1561297794671,["GJX@GJXAIOU",[[1,347,"\n"]],[346,346],[347,347]]],[1561297794704,["GJX@GJXAIOU",[[1,348,"\n"]],[347,347],[348,348]]],[1561297794743,["GJX@GJXAIOU",[[1,349,"\n"]],[348,348],[349,349]]],[1561297794770,["GJX@GJXAIOU",[[1,350,"\n"]],[349,349],[350,350]]],[1561297798120,["GJX@GJXAIOU",[[1,340,"- gaung"]],[340,340],[347,347]]],[1561297799152,["GJX@GJXAIOU",[[-1,342,"gaung"]],[347,347],[342,342]]],[1561297803482,["GJX@GJXAIOU",[[1,342,"官方题解："]],[342,342],[347,347]]],[1561297803798,["GJX@GJXAIOU",[[1,348,"- \n"]],[347,347],[350,350]]],[1561297804903,["GJX@GJXAIOU",[[-1,348,"- "]],[350,350],[348,348]]],[1561297805610,["GJX@GJXAIOU",[[1,348,"这个问题属于 “数组变换” 的一个广泛范畴。这一类是技术面试的重点。主要是因为数组是如此简单和易于使用的数据结构。遍历或表示不需要任何样板代码，而且大多数代码将看起来像伪代码本身。\n\n问题的两个要求是：\n\n将所有 0 移动到数组末尾。\n所有非零元素必须保持其原始顺序。\n这里很好地认识到这两个需求是相互排斥的，也就是说，你可以解决单独的子问题，然后将它们组合在一起以得到最终的解决方案。\n\n方法一：空间局部优化\nC++\nvoid moveZeroes(vector<int>& nums) {\n    int n = nums.size();\n\n    // Count the zeroes\n    int numZeroes = 0;\n    for (int i = 0; i < n; i++) {\n        numZeroes += (nums[i] == 0);\n    }\n\n    // Make all the non-zero elements retain their original order.\n    vector<int> ans;\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            ans.push_back(nums[i]);\n        }\n    }\n\n    // Move all zeroes to the end\n    while (numZeroes--) {\n        ans.push_back(0);\n    }\n\n    // Combine the result\n    for (int i = 0; i < n; i++) {\n        nums[i] = ans[i];\n    }\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)。但是，操作总数是局部优化的。我们可以在更少的操作中实现相同的结果。\n空间复杂度：O(n)O(n)，我们创建 “ans” 数组来存储结果。\n方法二：空间最优，操作局部优化（双指针）\n这种方法与上面的工作方式相同，即先满足一个需求，然后满足另一个需求。它以一种巧妙的方式做到了这一点。上述问题也可以用另一种方式描述，“将所有非 0 元素置于数组前面，保持它们的相对顺序相同”。\n这是双指针的方法。由变量 “cur” 表示的快速指针负责处理新元素。如果新找到的元素不是 0，我们就在最后找到的非 0 元素之后记录它。最后找到的非 0 元素的位置由慢指针 “lastnonzerofoundat” 变量表示。当我们不断发现新的非 0 元素时，我们只是在 “lastnonzerofoundat+1” 第个索引处覆盖它们。此覆盖不会导致任何数据丢失，因为我们已经处理了其中的内容（如果它是非 0 的，则它现在已经写入了相应的索引，或者如果它是 0，则稍后将进行处理）。\n在 “cur” 索引到达数组的末尾之后，我们现在知道所有非 0 元素都已按原始顺序移动到数组的开头。现在是时候满足其他要求了，“将所有 0 移动到末尾”。我们现在只需要在 “lastnonzerofoundat” 索引之后用 0 填充所有索引。\nC++\nvoid moveZeroes(vector<int>& nums) {\n    int lastNonZeroFoundAt = 0;\n    // If the current element is not 0, then we need to\n    // append it just in front of last non 0 element we found. \n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[lastNonZeroFoundAt++] = nums[i];\n        }\n    }\n    // After we have finished processing new elements,\n    // all the non-zero elements are already at beginning of array.\n    // We just need to fill remaining array with 0's.\n    for (int i = lastNonZeroFoundAt; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)。但是，操作仍然是局部优化的。代码执行的总操作（数组写入）为 nn（元素总数）。\n空间复杂度：O(1)O(1)，只使用常量空间。\n方法三：最优解\n前一种方法的操作是局部优化的。例如，所有（除最后一个）前导零的数组：[0，0，0，…，0，1]。对数组执行多少写操作？对于前面的方法，它写 0 n-1n−1 次，这是不必要的。我们本可以只写一次。怎么用？… 只需固定非 0 元素。\n\n最优方法也是上述解决方案的一个细微扩展。一个简单的实现是，如果当前元素是非 0 的，那么它的正确位置最多可以是当前位置或者更早的位置。如果是后者，则当前位置最终将被非 0 或 0 占据，该非 0 或 0 位于大于 “cur” 索引的索引处。我们马上用 0 填充当前位置，这样不像以前的解决方案，我们不需要在下一个迭代中回到这里。\n\n换句话说，代码将保持以下不变：\n\n慢指针（lastnonzerofoundat）之前的所有元素都是非零的。\n当前指针和慢速指针之间的所有元素都是零。\n因此，当我们遇到一个非零元素时，我们需要交换当前指针和慢速指针指向的元素，然后前进两个指针。如果它是零元素，我们只前进当前指针。\nC++\nvoid moveZeroes(vector<int>& nums) {\n    for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {\n        if (nums[cur] != 0) {\n            swap(nums[lastNonZeroFoundAt++], nums[cur]);\n        }\n    }\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)。但是，操作是最优的。代码执行的总操作（数组写入）是非 0 元素的数量。这比上一个解决方案的复杂性（当大多数元素为 0 时）要好得多。但是，两种算法的最坏情况（当所有元素都为非 0 时）复杂性是相同的。\n空间复杂度：O(1)O(1)，只使用了常量空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-dong-ling-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[348,348],[3336,3336]]],[1561297810306,["GJX@GJXAIOU",[[1,440,"- "]],[440,440],[442,442]]],[1561297814529,["GJX@GJXAIOU",[[1,342,"**"],[1,346,"**"]],[342,346],[342,350]]],[1561297817198,["GJX@GJXAIOU",[[-1,456,"\n"]],[456,456],[455,455]]],[1561297820802,["GJX@GJXAIOU",[[1,456,"- "],[1,471,"- "]],[456,487],[458,491]]],[1561297821187,["GJX@GJXAIOU",[[1,456,"  "],[1,473,"  "]],[458,491],[460,495]]],[1561297823769,["GJX@GJXAIOU",[[1,496,"  - \n"]],[495,495],[500,500]]],[1561297825457,["GJX@GJXAIOU",[[-1,498,"- "]],[500,500],[498,498]]],[1561297829751,["GJX@GJXAIOU",[[1,559,"**"],[1,569,"**"]],[559,569],[559,573]]],[1561297847723,["GJX@GJXAIOU",[[-1,574,"C++"]],[574,577],[574,574]]],[1561297853411,["GJX@GJXAIOU",[[1,574,"```cpp"]],[574,574],[580,580]]],[1561297856869,["GJX@GJXAIOU",[[1,1159,"\n"]],[1158,1158],[1159,1159]]],[1561297857473,["GJX@GJXAIOU",[[1,1159,"```"]],[1159,1159],[1162,1162]]],[1561297860102,["GJX@GJXAIOU",[[1,1254,"\n"]],[1253,1253],[1254,1254]]],[1561297863928,["GJX@GJXAIOU",[[-1,1180,"O(n)"]],[1184,1184],[1180,1180]]],[1561297866666,["GJX@GJXAIOU",[[-1,1222,"(n)O"]],[1225,1225],[1221,1221]]],[1561297869939,["GJX@GJXAIOU",[[-1,1169,"\n"]],[1169,1169],[1168,1168]]],[1561297872638,["GJX@GJXAIOU",[[1,1163,"\n"]],[1163,1163],[1164,1164]]],[1561297873128,["GJX@GJXAIOU",[[1,1164,"- "]],[1164,1164],[1166,1166]]],[1561297886998,["GJX@GJXAIOU",[[1,1249,"**"],[1,1269,"**"]],[1249,1269],[1249,1273]]],[1561297891687,["GJX@GJXAIOU",[[1,1274,"\n"]],[1273,1273],[1274,1274]]],[1561297893996,["GJX@GJXAIOU",[[1,1249,"\n"]],[1248,1248],[1249,1249]]],[1561297894152,["GJX@GJXAIOU",[[1,1250,"\n"]],[1249,1249],[1250,1250]]],[1561297896483,["GJX@GJXAIOU",[[1,1251,"- "]],[1251,1251],[1253,1253]]],[1561297940298,["GJX@GJXAIOU",[[1,1742,"```"]],[1742,1742],[1745,1745]]],[1561297940327,["GJX@GJXAIOU",[[1,1745,"language\n```\n"]],[1745,1745],[1745,1753]]],[1561297942491,["GJX@GJXAIOU",[[-1,1745,"language"],[1,1753,"c"]],[1745,1753],[1746,1746]]],[1561297942794,["GJX@GJXAIOU",[[1,1746,"pp"]],[1746,1746],[1748,1748]]],[1561297946950,["GJX@GJXAIOU",[[-1,1749,"```\nC++"]],[1749,1756],[1749,1749]]],[1561297949564,["GJX@GJXAIOU",[[1,2344,"\n"]],[2343,2343],[2344,2344]]],[1561297949699,["GJX@GJXAIOU",[[1,2345,"\n"]],[2344,2344],[2345,2345]]],[1561297950034,["GJX@GJXAIOU",[[1,2345,"```\nC++"]],[2345,2345],[2352,2352]]],[1561297952271,["GJX@GJXAIOU",[[-1,2349,"C++"]],[2349,2352],[2349,2349]]],[1561297953962,["GJX@GJXAIOU",[[1,2350,"- "]],[2350,2350],[2352,2352]]],[1561297956909,["GJX@GJXAIOU",[[1,2359,"* "],[1,2414,"* "]],[2359,2437],[2361,2441]]],[1561297958788,["GJX@GJXAIOU",[[1,2359,"  "],[1,2416,"  "]],[2361,2441],[2363,2445]]],[1561297961850,["GJX@GJXAIOU",[[-1,2370,"(n)O"]],[2373,2373],[2369,2369]]],[1561297963921,["GJX@GJXAIOU",[[-1,2405,"n"]],[2406,2406],[2405,2405]]],[1561297966098,["GJX@GJXAIOU",[[-1,2424,"(1)O"]],[2427,2427],[2423,2423]]],[1561297967313,["GJX@GJXAIOU",[[1,2437,"  * \n"]],[2436,2436],[2441,2441]]],[1561297967765,["GJX@GJXAIOU",[[-1,2437,"  * "]],[2441,2441],[2438,2438]]],[1561297970206,["GJX@GJXAIOU",[[1,2438,"**"],[1,2445,"**"]],[2438,2445],[2438,2449]]],[1561297973330,["GJX@GJXAIOU",[[1,2438,"- "]],[2438,2438],[2440,2440]]],[1561297981277,["GJX@GJXAIOU",[[1,2438,"\n"]],[2437,2437],[2438,2438]]],[1561297981464,["GJX@GJXAIOU",[[1,2439,"\n"]],[2438,2438],[2439,2439]]],[1561297999685,["GJX@GJXAIOU",[[-1,2529,"n−1 "]],[2533,2533],[2529,2529]]],[1561298038516,["GJX@GJXAIOU",[[1,2873,"`"],[1,2876,"`"]],[2873,2876],[2873,2878]]],[1561298038690,["GJX@GJXAIOU",[[-1,2873,"`"],[-1,2877,"`"]],[2873,2878],[2873,2876]]],[1561298038872,["GJX@GJXAIOU",[[1,2873,"`"],[1,2876,"`"]],[2873,2876],[2873,2878]]],[1561298040029,["GJX@GJXAIOU",[[-1,2873,"`C++`"]],[2873,2878],[2873,2873]]],[1561298041938,["GJX@GJXAIOU",[[1,2873,"```cpp"]],[2873,2873],[2879,2879]]],[1561298044986,["GJX@GJXAIOU",[[1,3096,"\n"]],[3095,3095],[3096,3096]]],[1561298045121,["GJX@GJXAIOU",[[1,3097,"\n"]],[3096,3096],[3097,3097]]],[1561298045821,["GJX@GJXAIOU",[[1,3097,"```"]],[3097,3097],[3100,3100]]],[1561298048929,["GJX@GJXAIOU",[[-1,3237,")"]],[3238,3238],[3237,3237]]],[1561298048968,["GJX@GJXAIOU",[[1,3237,"="]],[3237,3237],[3238,3238]]],[1561298050043,["GJX@GJXAIOU",[[-1,3234,"O(1="]],[3238,3238],[3234,3234]]],[1561298052063,["GJX@GJXAIOU",[[-1,3118,"O(n)"]],[3122,3122],[3118,3118]]],[1561298057684,["GJX@GJXAIOU",[[1,3108,"- "]],[3108,3108],[3110,3110]]],[1561298058850,["GJX@GJXAIOU",[[1,3222,"="]],[3222,3222],[3223,3223]]],[1561298060264,["GJX@GJXAIOU",[[-1,3222,"="]],[3223,3223],[3222,3222]]],[1561298060746,["GJX@GJXAIOU",[[1,3222,"- "]],[3222,3222],[3224,3224]]],[1561298062776,["GJX@GJXAIOU",[[-1,3107,"\n"]],[3107,3107],[3106,3106]]],[1561298064989,["GJX@GJXAIOU",[[1,3101,"\n"]],[3101,3101],[3102,3102]]],[1561298065594,["GJX@GJXAIOU",[[1,3102,"- "]],[3102,3102],[3104,3104]]],[1561298068328,["GJX@GJXAIOU",[[1,3110,"  "],[1,3224,"  "]],[3112,3245],[3114,3249]]],[1561298072150,["GJX@GJXAIOU",[[-1,3403,"\n"]],[3401,3401],[3400,3400]]],[1561298072273,["GJX@GJXAIOU",[[-1,3402,"\n"]],[3400,3400],[3399,3399]]],[1561298072409,["GJX@GJXAIOU",[[-1,3401,"\n"]],[3399,3399],[3398,3398]]],[1561298416294,["GJX@GJXAIOU",[[1,2808,"=="],[1,2872,"=="]],[2808,2872],[2808,2876]]],[1561298439966,["GJX@GJXAIOU",[[1,2876," ()"]],[2876,2876],[2879,2879]]],[1561298441923,["GJX@GJXAIOU",[[1,2878,"zheli"]],[2878,2878],[2883,2883]]],[1561298442966,["GJX@GJXAIOU",[[-1,2878,"zheli"]],[2883,2883],[2878,2878]]],[1561298456664,["GJX@GJXAIOU",[[1,2878,"这里的他指哪一个元素"]],[2878,2878],[2888,2888]]],[1561298464266,["GJX@GJXAIOU",[[-1,32,"green"]],[37,37],[32,32]]],[1561298467418,["GJX@GJXAIOU",[[1,32,"yellow"]],[32,32],[38,38]]],[1561298696512,["GJX@GJXAIOU",[[-1,232,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/move-zeroes\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n"]],[232,331],[232,232]]],[1561298715937,["GJX@GJXAIOU",[[1,232,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/move-zeroes\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n"]],[232,232],[232,331]]]],null,"GJX@GJXAIOU"],["c3414399-017a-4a45-b73b-1a0937a48c4c",1561341252692,"---\ntags: \n- 简答\n- 完成\n- 数组\nflag: yellow\nstyle: summer\ndate: '2019-6-23'\n---\n\n\n# 283.移动零\n\n## 题目\n\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n- 示例:\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n* 说明:\n  * 必须在原数组上操作，不能拷贝额外的数组。\n  * 尽量减少操作次数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/move-zeroes\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n\n## 解答\n\n- **官方题解**：\n这个问题属于 “数组变换” 的一个广泛范畴。这一类是技术面试的重点。主要是因为数组是如此简单和易于使用的数据结构。遍历或表示不需要任何样板代码，而且大多数代码将看起来像伪代码本身。\n\n- 问题的两个要求是：\n  - 将所有 0 移动到数组末尾。\n  - 所有非零元素必须保持其原始顺序。\n  \n这里很好地认识到这两个需求是相互排斥的，也就是说，你可以解决单独的子问题，然后将它们组合在一起以得到最终的解决方案。\n\n**方法一：空间局部优化**\n```cpp\nvoid moveZeroes(vector<int>& nums) {\n    int n = nums.size();\n\n    // Count the zeroes\n    int numZeroes = 0;\n    for (int i = 0; i < n; i++) {\n        numZeroes += (nums[i] == 0);\n    }\n\n    // Make all the non-zero elements retain their original order.\n    vector<int> ans;\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            ans.push_back(nums[i]);\n        }\n    }\n\n    // Move all zeroes to the end\n    while (numZeroes--) {\n        ans.push_back(0);\n    }\n\n    // Combine the result\n    for (int i = 0; i < n; i++) {\n        nums[i] = ans[i];\n    }\n}\n```\n\n- 复杂度分析\n时间复杂度：O(n)。但是，操作总数是局部优化的。我们可以在更少的操作中实现相同的结果。\n空间复杂度：O(n)，我们创建 “ans” 数组来存储结果。\n\n\n\n- **方法二：空间最优，操作局部优化（双指针）**\n\n这种方法与上面的工作方式相同，即先满足一个需求，然后满足另一个需求。它以一种巧妙的方式做到了这一点。上述问题也可以用另一种方式描述，“将所有非 0 元素置于数组前面，保持它们的相对顺序相同”。\n这是双指针的方法。由变量 “cur” 表示的快速指针负责处理新元素。如果新找到的元素不是 0，我们就在最后找到的非 0 元素之后记录它。最后找到的非 0 元素的位置由慢指针 “lastnonzerofoundat” 变量表示。当我们不断发现新的非 0 元素时，我们只是在 “lastnonzerofoundat+1” 第个索引处覆盖它们。此覆盖不会导致任何数据丢失，因为我们已经处理了其中的内容（如果它是非 0 的，则它现在已经写入了相应的索引，或者如果它是 0，则稍后将进行处理）。\n在 “cur” 索引到达数组的末尾之后，我们现在知道所有非 0 元素都已按原始顺序移动到数组的开头。现在是时候满足其他要求了，“将所有 0 移动到末尾”。我们现在只需要在 “lastnonzerofoundat” 索引之后用 0 填充所有索引。\n```cpp\n\nvoid moveZeroes(vector<int>& nums) {\n    int lastNonZeroFoundAt = 0;\n    // If the current element is not 0, then we need to\n    // append it just in front of last non 0 element we found. \n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[lastNonZeroFoundAt++] = nums[i];\n        }\n    }\n    // After we have finished processing new elements,\n    // all the non-zero elements are already at beginning of array.\n    // We just need to fill remaining array with 0's.\n    for (int i = lastNonZeroFoundAt; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}\n\n```\n\n- 复杂度分析\n\n  * 时间复杂度：O(n)。但是，操作仍然是局部优化的。代码执行的总操作（数组写入）为 n（元素总数）。\n  * 空间复杂度：O(1)，只使用常量空间。\n\n\n\n- **方法三：最优解**\n前一种方法的操作是局部优化的。例如，所有（除最后一个）前导零的数组：[0，0，0，…，0，1]。对数组执行多少写操作？对于前面的方法，它写 0 n-1次，这是不必要的。我们本可以只写一次。怎么用？… 只需固定非 0 元素。\n\n最优方法也是上述解决方案的一个细微扩展。一个简单的实现是，如果当前元素是非 0 的，那么它的正确位置最多可以是当前位置或者更早的位置。如果是后者，则当前位置最终将被非 0 或 0 占据，该非 0 或 0 位于大于 “cur” 索引的索引处。我们马上用 0 填充当前位置，这样不像以前的解决方案，我们不需要在下一个迭代中回到这里。\n\n换句话说，代码将保持以下不变：\n\n慢指针（lastnonzerofoundat）之前的所有元素都是非零的。\n当前指针和慢速指针之间的所有元素都是零。\n==因此，当我们遇到一个非零元素时，我们需要交换当前指针和慢速指针指向的元素，然后前进两个指针。如果它是零元素，我们只前进当前指针。== (这里的他指哪一个元素)\n```cpp\nvoid moveZeroes(vector<int>& nums) {\n    for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {\n        if (nums[cur] != 0) {\n            swap(nums[lastNonZeroFoundAt++], nums[cur]);\n        }\n    }\n}\n\n```\n\n- 复杂度分析\n  - 时间复杂度：O(n)。但是，操作是最优的。代码执行的总操作（数组写入）是非 0 元素的数量。这比上一个解决方案的复杂性（当大多数元素为 0 时）要好得多。但是，两种算法的最坏情况（当所有元素都为非 0 时）复杂性是相同的。\n  - 空间复杂度：O(1)，只使用了常量空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-dong-ling-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n- 解法一：双指针，将非零的逐个移到前面，后面全部补0\n**思路**：可以先把所有非0的元素移到前面，然后将后面的位置补0。 使用指针i，指向需要插入的下标，使用指针j指向遍历的下标。遍历一遍，如果j指向的位置为0，则i不变，`j++`后移；如果j指向的位置不为0，则将j位置的元素值赋值到i位置，然后`i++`。\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        //i:插入位置下标 ; j:查找位置下标\n        int i = 0; \n        for(int j = 0; j < nums.length; j++){\n            if(nums[j] != 0){\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        //将后面的位置补0\n        for(int p = i; p < nums.length; p++){\n            nums[p] = 0;\n        }\n    }\n}\n```\n\n- 执行用时 :1 ms, 在所有 Java 提交中击败了96.23%的用户\n- 内存消耗 :41 MB, 在所有 Java 提交中击败了46.43%的用户\n\n作者：stonewang-2\n链接：https://leetcode-cn.com/problems/two-sum/solution/javashi-yong-2ge-xia-biao-zhi-zhen-fu-zhi-zui-shao/\n\n\n\n\n- 自己解答\n\n```java\n//将一个数组中的0移动到数组尾部，保持其他非零元素相对位置不变；本地操作\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        //合法性判断\n        if (nums == null) {\n\n        }\n        //思路：双指针\n        int front = 0;\n        int after = 0;\n\n        //得到第一个不为0元素的下标\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) {\n                front = i;\n                after = i+1;\n                break;\n            }\n\n        }\n\n        //从该元素开始，逐个遍历替换\n        while (after < nums.length) {            \n            if (nums[after] != 0) {\n                int temp = nums[front];\n                nums[front] = nums[after];\n                nums[after] = temp;\n\n                front++;\n            }\n            after++;\n\n        }\n\n    }\n}\n```\n\n- 执行用时 :1 ms, 在所有 Java 提交中击败了96.23%的用户\n\n- 内存消耗 :41.3 MB, 在所有 Java 提交中击败了43.09%的用户\n\n\n",[[1561341242012,["GJX@GJXAIOU",[[-1,14,"答"]],[15,15],[14,14]]],[1561341244290,["GJX@GJXAIOU",[[1,14,"单"]],[14,14],[15,15]]]],null,"GJX@GJXAIOU"]]}