{"compress":true,"commitItems":[["33a15bc1-9cd3-453a-9657-f561e5aea973",1562840784814,"",[[1562840745256,["GJX@GJXAIOU",[[1,0,"# 1010.总持续时间可被60整除的歌曲\n\n\n\n"]],[0,0],[24,24]]],[1562840756390,["GJX@GJXAIOU",[[1,25,"\n"]],[22,22],[23,23]]],[1562840759968,["GJX@GJXAIOU",[[1,23,"## 一、题目"]],[23,23],[30,30]]],[1562840760236,["GJX@GJXAIOU",[[1,33,"\n"]],[30,30],[31,31]]],[1562840760860,["GJX@GJXAIOU",[[1,34,"\n"]],[31,31],[32,32]]],[1562840764801,["GJX@GJXAIOU",[[1,32,"## 二、解答"]],[32,32],[39,39]]],[1562840765181,["GJX@GJXAIOU",[[1,42,"\n"]],[39,39],[40,40]]],[1562840766781,["GJX@GJXAIOU",[[1,32,"\n"]],[31,31],[32,32]]],[1562840766908,["GJX@GJXAIOU",[[1,33,"\n"]],[32,32],[33,33]]],[1562840768423,["GJX@GJXAIOU",[[1,31,"在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。\n\n返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。\n\n \n\n示例 1：\n\n输入：[30,20,150,100,40]\n输出：3\n解释：这三对的总持续时间可被 60 整数：\n(time[0] = 30, time[2] = 150): 总持续时间 180\n(time[1] = 20, time[3] = 100): 总持续时间 120\n(time[1] = 20, time[4] = 40): 总持续时间 60\n示例 2：\n\n输入：[60,60,60]\n输出：3\n解释：所有三对的总持续时间都是 120，可以被 60 整数。\n \n\n提示：\n\n1 <= time.length <= 60000\n1 <= time[i] <= 500\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[31,31],[581,581]]],[1562840802724,["GJX@GJXAIOU",[[-1,160,"\n"]],[160,160],[159,159]]],[1562840806917,["GJX@GJXAIOU",[[1,330,"\n"]],[330,330],[331,331]]],[1562840807966,["GJX@GJXAIOU",[[-1,337,"\n"]],[337,337],[336,336]]],[1562840810174,["GJX@GJXAIOU",[[-1,108,"  "],[1,110,"  "],[-1,118," "],[1,119," "],[-1,151," "],[1,152," "],[1,331,"-"],[-1,387," "],[1,388," "]],[331,331],[332,332]]],[1562840810365,["GJX@GJXAIOU",[[1,332," "]],[332,332],[333,333]]],[1562840812869,["GJX@GJXAIOU",[[1,154,"- "]],[154,154],[156,156]]],[1562840815718,["GJX@GJXAIOU",[[-1,151," "]],[152,152],[151,151]]],[1562840815843,["GJX@GJXAIOU",[[-1,152,"\n"]],[151,151],[150,150]]],[1562840816719,["GJX@GJXAIOU",[[-1,151,"\n"]],[150,150],[149,149]]],[1562840821140,["GJX@GJXAIOU",[[-1,390,"\n"]],[390,390],[389,389]]],[1562840823005,["GJX@GJXAIOU",[[1,390,"- "]],[390,390],[392,392]]],[1562840824212,["GJX@GJXAIOU",[[-1,396,"\n"]],[396,396],[395,395]]],[1562840832923,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1562840834158,["GJX@GJXAIOU",[[1,0,"---\ntags: \n- 简单\n- 参考\n- 数组\nflag: green\nstyle: summer\ndate: '2019-7-11'\n---"]],[0,0],[73,73]]],[1562842283841,["GJX@GJXAIOU",[[1,667,"- 自我"]],[667,667],[671,671]]],[1562842287813,["GJX@GJXAIOU",[[1,671,"解答：超时"]],[671,671],[676,676]]],[1562842288278,["GJX@GJXAIOU",[[1,677,"- \n"]],[676,676],[679,679]]],[1562842289085,["GJX@GJXAIOU",[[-1,677,"- "]],[679,679],[677,677]]],[1562842290572,["GJX@GJXAIOU",[[1,677,"```"]],[677,677],[680,680]]],[1562842290598,["GJX@GJXAIOU",[[1,680,"language\n```\n"]],[680,680],[680,688]]],[1562842291590,["GJX@GJXAIOU",[[-1,680,"language"],[1,688,"j"]],[680,688],[681,681]]],[1562842292037,["GJX@GJXAIOU",[[1,681,"ava"]],[681,681],[684,684]]],[1562842292116,["GJX@GJXAIOU",[[1,685,"\n"]],[684,684],[685,685]]],[1562842293132,["GJX@GJXAIOU",[[1,685,"class Solution {\n    public int numPairsDivisibleBy60(int[] time) {\n        \n        int length = time.length;\n\n        if (length == 1) {            \n            return 0;\n        }\n\n\n        int i = 0, num = 0;\n        while(i < length - 1){\n            int j = i + 1;\n            for (; j < length; ++j) {\n                if ((time[i] + time[j]) % 60 == 0) {\n                    num++;\n                }\n            }\n            ++i;\n        }\n\n        return num;\n    }\n}"]],[685,685],[1161,1161]]],[1562843684062,["GJX@GJXAIOU",[[1,667,"\n"]],[666,666],[667,667]]],[1562843684174,["GJX@GJXAIOU",[[1,668,"\n"]],[667,667],[668,668]]],[1562843684312,["GJX@GJXAIOU",[[1,669,"\n"]],[668,668],[669,669]]],[1562843686159,["GJX@GJXAIOU",[[1,670,"\n"]],[666,666],[667,667]]],[1562843691878,["GJX@GJXAIOU",[[1,667,"- tijie"]],[667,667],[674,674]]],[1562843693094,["GJX@GJXAIOU",[[-1,669,"tijie"]],[674,674],[669,669]]],[1562843695689,["GJX@GJXAIOU",[[1,669,"题解一："]],[669,669],[673,673]]],[1562843696190,["GJX@GJXAIOU",[[1,674,"- \n"]],[673,673],[676,676]]],[1562843697158,["GJX@GJXAIOU",[[-1,674,"- "]],[676,676],[674,674]]],[1562843703673,["GJX@GJXAIOU",[[1,674,"- "]],[674,674],[676,676]]],[1562843704845,["GJX@GJXAIOU",[[1,674,"  "]],[676,676],[678,678]]],[1562843705906,["GJX@GJXAIOU",[[1,678,"数组"]],[678,678],[680,680]]],[1562843708198,["GJX@GJXAIOU",[[-1,676,"- 数组"]],[680,680],[676,676]]],[1562843716643,["GJX@GJXAIOU",[[1,676,"tag：数组、哈细胞"]],[676,676],[686,686]]],[1562843717719,["GJX@GJXAIOU",[[-1,683,"哈细胞"]],[686,686],[683,683]]],[1562843719975,["GJX@GJXAIOU",[[1,683,"哈希表"]],[683,683],[686,686]]],[1562843720526,["GJX@GJXAIOU",[[1,687,"  \n"]],[686,686],[689,689]]],[1562843729878,["GJX@GJXAIOU",[[1,689,"思路分析：\n\n思路有点像 「力扣」第 1 题： 两个数之和和「力扣」第 454 题：四数相加 II。\n\n1、题目要求找整数对，并且是“总持续时间”，即两首歌曲之和，“可被 60 整除”，因此我们做预处理，把数组里所有的数处理成模 60 的余数；\n\n说明：这个思路来自「力扣」第 1 题： 两数之和。\n\n2、做计数统计是必要的，因此需要使用哈希表，键是当前遍历的秒数，值是这个秒数出现的次数，在遍历的过程中，统计 “60 - 当前遍历的秒数”，这个秒数已经出现了几次，那么当前遍历的数就能够和之前的若干次组成“歌曲对”；\n\n说明：这个思路来自「力扣」第 18 题： 四数之和。\n\n3、针对整一分钟，例如 [60, 60, 60] 这样的测试用例，预处理完成以后就是 [0, 0, 0]，所以 “60 - 当前遍历的秒数” 也要模 60。\n\n说明：这是在提交测试用例的时候发现的。\n\n参考代码：\n\nPythonJava\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n    public int numPairsDivisibleBy60(int[] time) {\n        // 预处理：把数组中的元素全都模 60\n        int len = time.length;\n        for (int i = 0; i < len; i++) {\n            time[i] = time[i] % 60;\n        }\n        // 注意：[60, 60, 60] 会被处理成 [0, 0, 0]\n        Map<Integer, Integer> map = new HashMap<>();\n        int res = 0;\n        for (int i = 0; i < len; i++) {\n            // 注意：要记得模 60\n            int residue = (60 - time[i]) % 60;\n\n            Integer preCount = map.get(residue);\n            if (preCount != null) {\n                res += preCount;\n            }\n\n            // 计数，应该放在统计之后做，因为后面的参考前面的\n            Integer curCount = map.get(time[i]);\n            if (curCount == null) {\n                map.put(time[i], 1);\n            } else {\n                map.put(time[i], curCount + 1);\n            }\n        }\n        return res;\n    }\n\n}\n复杂度分析：\n\n时间复杂度：O(N)O(N)，这里 NN 是数组的长度，算法把数组看了两次。\n空间复杂度：O(N)O(N)，使用了长度为 NN 的哈希表。\n\n作者：liweiwei1419\n链接：https://leetcode-cn.com/problems/two-sum/solution/shu-zu-ha-xi-biao-python-dai-ma-java-dai-ma-by-liw/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[689,689],[2265,2265]]],[1562843733125,["GJX@GJXAIOU",[[1,689,"**"],[1,694,"**"]],[689,694],[689,698]]],[1562843770685,["GJX@GJXAIOU",[[1,689,"++"],[1,690,"++"]],[689,690],[689,694]]],[1562843770748,["GJX@GJXAIOU",[[-1,689,"++*++"],[1,694,"\n  "]],[689,694],[692,692]]],[1562843776937,["GJX@GJXAIOU",[[1,692,"\n  "]],[692,692],[695,695]]],[1562843785287,["GJX@GJXAIOU",[[1,696,"*"]],[695,695],[696,696]]],[1562843787328,["GJX@GJXAIOU",[[-1,694," "]],[694,694],[693,693]]],[1562843787445,["GJX@GJXAIOU",[[-1,692,"\n"]],[693,693],[692,692]]],[1562843788333,["GJX@GJXAIOU",[[-1,691,"  "]],[692,692],[690,690]]],[1562843807005,["GJX@GJXAIOU",[[1,793,"**"],[1,816,"**"]],[793,816],[793,820]]],[1562843810031,["GJX@GJXAIOU",[[-1,822,"\n"]],[823,823],[822,822]]],[1562843813381,["GJX@GJXAIOU",[[-1,958,"\n"]],[958,958],[957,957]]],[1562843816757,["GJX@GJXAIOU",[[-1,1065,"\n"]],[1065,1065],[1064,1064]]],[1562843820642,["GJX@GJXAIOU",[[-1,1093,"Python"],[1,1099,"·"]],[1093,1093],[1094,1094]]],[1562843821023,["GJX@GJXAIOU",[[1,1094,"··"]],[1094,1094],[1096,1096]]],[1562843822261,["GJX@GJXAIOU",[[-1,1093,"···"]],[1096,1096],[1093,1093]]],[1562843823502,["GJX@GJXAIOU",[[1,1093,"```"]],[1093,1093],[1096,1096]]],[1562843826687,["GJX@GJXAIOU",[[1,2019,"\n"]],[2018,2018],[2019,2019]]],[1562843827334,["GJX@GJXAIOU",[[1,2019,"```"]],[2019,2019],[2022,2022]]],[1562844008516,["GJX@GJXAIOU",[[-1,2050,"N"]],[2051,2051],[2050,2050]]],[1562844010301,["GJX@GJXAIOU",[[-1,2041,"O(N)"]],[2045,2045],[2041,2041]]],[1562844011908,["GJX@GJXAIOU",[[-1,2075,"O(N)"]],[2079,2079],[2075,2075]]],[1562844013396,["GJX@GJXAIOU",[[-1,2084,"N"]],[2084,2084],[2083,2083]]],[1562844091422,["GJX@GJXAIOU",[[-1,2030,"\n"]],[2030,2030],[2029,2029]]],[1562844096807,["GJX@GJXAIOU",[[-1,2212,"来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2212,2262],[2212,2212]]],[1562844098838,["GJX@GJXAIOU",[[-1,2091,"作者：liweiwei1419\n链接：https://leetcode-cn.com/problems/two-sum/solution/shu-zu-ha-xi-biao-python-dai-ma-java-dai-ma-by-liw/"]],[2091,2211],[2091,2091]]],[1562844116630,["GJX@GJXAIOU",[[1,2063,"42ms"]],[2063,2063],[2067,2067]]],[1562844124876,["GJX@GJXAIOU",[[1,2093,"51MB"]],[2093,2093],[2097,2097]]],[1562844204103,["GJX@GJXAIOU",[[1,2099,"- "]],[2099,2099],[2101,2101]]],[1562844206751,["GJX@GJXAIOU",[[1,2101,"解法二："]],[2101,2101],[2105,2105]]],[1562844207413,["GJX@GJXAIOU",[[1,2106,"- \n"]],[2105,2105],[2108,2108]]],[1562844208085,["GJX@GJXAIOU",[[-1,2106,"- "]],[2108,2108],[2106,2106]]],[1562844210543,["GJX@GJXAIOU",[[1,2106,"```java"]],[2106,2106],[2113,2113]]],[1562844210671,["GJX@GJXAIOU",[[1,2118,"\n"]],[2113,2113],[2114,2114]]],[1562844211252,["GJX@GJXAIOU",[[1,2119,"\n"]],[2114,2114],[2115,2115]]],[1562844211405,["GJX@GJXAIOU",[[1,2120,"\n"]],[2115,2115],[2116,2116]]],[1562844212328,["GJX@GJXAIOU",[[1,2116,"```"]],[2116,2116],[2119,2119]]],[1562844219702,["GJX@GJXAIOU",[[1,2120,"执行用时 :4 ms, 在所有 Java 提交中击败了95.03%的用户\n\n内存消耗 :51.6 MB, 在所有 Java 提交中击败了42.79%的用户"]],[2120,2120],[2197,2197]]],[1562844223935,["GJX@GJXAIOU",[[1,2114,"class Solution {\n    public int numPairsDivisibleBy60(int[] time) {\n        if (time.length < 2)\n            return 0;\n        int count = 0;\n        int[] arr = new int[60];\n        for (int i : time) {\n            arr[i % 60]++;\n        }\n        count += (arr[0] * (arr[0] - 1)) >> 1;\n        count += (arr[30] * (arr[30] - 1)) >> 1;\n        for (int i = 1; i < 30; i++) {\n            count += arr[i] * arr[60 - i];\n        }\n        return count;\n    }\n}"]],[2114,2114],[2572,2572]]]],null,"GJX@GJXAIOU"],["9fa783bc-0223-4c10-a87c-a2ba0364b4c7",1562847393920,"---\ntags: \n- 简单\n- 参考\n- 数组\nflag: green\nstyle: summer\ndate: '2019-7-11'\n---\n# 1010.总持续时间可被60整除的歌曲\n\n## 一、题目\n在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。\n\n返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。\n\n- 示例 1：\n输入：[30,20,150,100,40]\n输出：3\n解释：这三对的总持续时间可被 60 整数：\n(time[0] = 30, time[2] = 150): 总持续时间 180\n(time[1] = 20, time[3] = 100): 总持续时间 120\n(time[1] = 20, time[4] = 40): 总持续时间 60\n\n- 示例 2：\n输入：[60,60,60]\n输出：3\n解释：所有三对的总持续时间都是 120，可以被 60 整数。\n \n- 提示：\n1 <= time.length <= 60000\n1 <= time[i] <= 500\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/pairs-of-songs-with-total-durations-divisible-by-60\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n## 二、解答\n\n- 题解一：\n  tag：数组、哈希表\n  \n **思路分析：**\n\n思路有点像 「力扣」第 1 题： 两个数之和和「力扣」第 454 题：四数相加 II。\n\n1、题目要求找整数对，并且是“总持续时间”，即两首歌曲之和，“可被 60 整除”，因此我们做**预处理，把数组里所有的数处理成模 60 的余数**；\n说明：这个思路来自「力扣」第 1 题： 两数之和。\n\n2、做计数统计是必要的，因此需要使用哈希表，键是当前遍历的秒数，值是这个秒数出现的次数，在遍历的过程中，统计 “60 - 当前遍历的秒数”，这个秒数已经出现了几次，那么当前遍历的数就能够和之前的若干次组成“歌曲对”；\n说明：这个思路来自「力扣」第 18 题： 四数之和。\n\n3、针对整一分钟，例如 [60, 60, 60] 这样的测试用例，预处理完成以后就是 [0, 0, 0]，所以 “60 - 当前遍历的秒数” 也要模 60。\n说明：这是在提交测试用例的时候发现的。\n\n参考代码：\n\n```Java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n    public int numPairsDivisibleBy60(int[] time) {\n        // 预处理：把数组中的元素全都模 60\n        int len = time.length;\n        for (int i = 0; i < len; i++) {\n            time[i] = time[i] % 60;\n        }\n        // 注意：[60, 60, 60] 会被处理成 [0, 0, 0]\n        Map<Integer, Integer> map = new HashMap<>();\n        int res = 0;\n        for (int i = 0; i < len; i++) {\n            // 注意：要记得模 60\n            int residue = (60 - time[i]) % 60;\n\n            Integer preCount = map.get(residue);\n            if (preCount != null) {\n                res += preCount;\n            }\n\n            // 计数，应该放在统计之后做，因为后面的参考前面的\n            Integer curCount = map.get(time[i]);\n            if (curCount == null) {\n                map.put(time[i], 1);\n            } else {\n                map.put(time[i], curCount + 1);\n            }\n        }\n        return res;\n    }\n\n}\n```\n复杂度分析：\n时间复杂度：O(N)，这里 N 是数组的长度，算法把数组看了两次。42ms\n空间复杂度：O(N)，使用了长度为 N 的哈希表。51MB\n\n- 解法二：\n```java\nclass Solution {\n    public int numPairsDivisibleBy60(int[] time) {\n        if (time.length < 2)\n            return 0;\n        int count = 0;\n        int[] arr = new int[60];\n        for (int i : time) {\n            arr[i % 60]++;\n        }\n        count += (arr[0] * (arr[0] - 1)) >> 1;\n        count += (arr[30] * (arr[30] - 1)) >> 1;\n        for (int i = 1; i < 30; i++) {\n            count += arr[i] * arr[60 - i];\n        }\n        return count;\n    }\n}\n\n```\n执行用时 :4 ms, 在所有 Java 提交中击败了95.03%的用户\n\n内存消耗 :51.6 MB, 在所有 Java 提交中击败了42.79%的用户\n\n\n\n- 自我解答：超时\n```java\nclass Solution {\n    public int numPairsDivisibleBy60(int[] time) {\n        \n        int length = time.length;\n\n        if (length == 1) {            \n            return 0;\n        }\n\n\n        int i = 0, num = 0;\n        while(i < length - 1){\n            int j = i + 1;\n            for (; j < length; ++j) {\n                if ((time[i] + time[j]) % 60 == 0) {\n                    num++;\n                }\n            }\n            ++i;\n        }\n\n        return num;\n    }\n}\n```\n\n\n",[[1562847356664,["GJX@GJXAIOU",[[-1,32,"green"],[1,37,"y"],[-1,2593," "],[1,2594," "],[-1,2598," "],[1,2599," "],[-1,2634," "],[1,2635," "],[-1,2639," "],[1,2640," "]],[32,37],[33,33]]],[1562847357648,["GJX@GJXAIOU",[[1,33,"ellow"]],[33,33],[38,38]]]],null,"GJX@GJXAIOU"]]}