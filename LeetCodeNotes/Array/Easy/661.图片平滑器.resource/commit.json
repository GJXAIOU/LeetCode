{"compress":true,"commitItems":[["4195f8c5-a052-4866-b3f9-c6296a1c450d",1561471712697,"",[[1561471663291,["GJX@GJXAIOU",[[1,0,"# 661.图片平滑器\n\n\n\n"]],[0,0],[14,14]]],[1561471669875,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1561471669987,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1561471677700,["GJX@GJXAIOU",[[1,0,"---\ntags: \n- 简单\n- 完成\n- 数组\n\nflag: green\nstyle: summer\ndate: '2019-6-25'\n---"]],[0,0],[74,74]]],[1561471682662,["GJX@GJXAIOU",[[1,89,"### "]],[89,89],[93,93]]],[1561471684291,["GJX@GJXAIOU",[[-1,91,"# "]],[93,93],[91,91]]],[1561471686710,["GJX@GJXAIOU",[[1,91," 二、题目"]],[91,91],[96,96]]],[1561471686957,["GJX@GJXAIOU",[[1,98,"\n"]],[96,96],[97,97]]],[1561471687074,["GJX@GJXAIOU",[[1,99,"\n"]],[97,97],[98,98]]],[1561471687191,["GJX@GJXAIOU",[[1,100,"\n"]],[98,98],[99,99]]],[1561471687325,["GJX@GJXAIOU",[[1,101,"\n"]],[99,99],[100,100]]],[1561471687441,["GJX@GJXAIOU",[[1,102,"\n"]],[100,100],[101,101]]],[1561471693470,["GJX@GJXAIOU",[[1,101,"## 二、加大"]],[101,101],[108,108]]],[1561471694031,["GJX@GJXAIOU",[[-1,106,"加大"]],[108,108],[106,106]]],[1561471695126,["GJX@GJXAIOU",[[1,106,"解答"]],[106,106],[108,108]]],[1561471698838,["GJX@GJXAIOU",[[-1,92,"二"]],[93,93],[92,92]]],[1561471699699,["GJX@GJXAIOU",[[1,92,"一"]],[92,92],[93,93]]],[1561471729598,["GJX@GJXAIOU",[[1,98,"包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。\n\n示例 1:\n\n输入:\n[[1,1,1],\n [1,0,1],\n [1,1,1]]\n输出:\n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n解释:\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n注意:\n\n给定矩阵中的整数范围为 [0, 255]。\n矩阵的长和宽的范围均为 [1, 150]。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/image-smoother\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[98,98],[598,598]]],[1561471750308,["GJX@GJXAIOU",[[1,447,"\n"]],[447,447],[448,448]]],[1561471750855,["GJX@GJXAIOU",[[-1,146," "],[1,147," "],[1,448,"-"],[-1,486," "],[1,487," "]],[448,448],[449,449]]],[1561471751127,["GJX@GJXAIOU",[[1,449," "]],[449,449],[450,450]]],[1561471752643,["GJX@GJXAIOU",[[-1,454,"\n"]],[454,454],[453,453]]],[1561471754625,["GJX@GJXAIOU",[[-1,212,"\n"]],[212,212],[211,211]]],[1561471757214,["GJX@GJXAIOU",[[1,206,"- "]],[206,206],[208,208]]],[1561471775572,["GJX@GJXAIOU",[[1,236,";"]],[236,236],[237,237]]],[1561471795531,["GJX@GJXAIOU",[[-1,236,";"]],[237,237],[236,236]]]],null,"GJX@GJXAIOU"],["24da4793-9987-41cd-9abc-3ceb1bad2fab",1561511254598,"---\ntags: \n- 简单\n- 完成\n- 数组\n\nflag: green\nstyle: summer\ndate: '2019-6-25'\n---\n\n# 661.图片平滑器\n\n## 一、题目\n\n包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。\n\n- 示例 1:\n输入:\n[[1,1,1],\n [1,0,1],\n [1,1,1]]\n输出:\n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n解释:\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n\n- 注意:\n给定矩阵中的整数范围为 [0, 255]。\n矩阵的长和宽的范围均为 [1, 150]。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/image-smoother\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n## 二、解答\n\n",[[1561511244136,["GJX@GJXAIOU",[[1,613,"\n"]],[612,612],[613,613]]],[1561511244267,["GJX@GJXAIOU",[[1,614,"\n"]],[613,613],[614,614]]],[1561511245598,["GJX@GJXAIOU",[[-1,614,"\n"],[1,615,"-"]],[614,614],[615,615]]],[1561511252725,["GJX@GJXAIOU",[[1,615," 自我解答（）"]],[615,615],[622,622]]],[1561511257975,["GJX@GJXAIOU",[[1,621,"有点问题"]],[621,621],[625,625]]],[1561527952367,["GJX@GJXAIOU",[[1,626,"\n- "]],[626,626],[629,629]]],[1561527952699,["GJX@GJXAIOU",[[-1,628," "]],[629,629],[628,628]]],[1561527952854,["GJX@GJXAIOU",[[-1,627,"-"],[1,628,"\n"]],[628,628],[627,627]]],[1561527953892,["GJX@GJXAIOU",[[-1,627,"\n"],[1,628,"`"]],[627,627],[628,628]]],[1561527954269,["GJX@GJXAIOU",[[1,628,"``"]],[628,628],[630,630]]],[1561527954293,["GJX@GJXAIOU",[[1,630,"language\n```\n"]],[630,630],[630,638]]],[1561527963564,["GJX@GJXAIOU",[[-1,630,"language"],[1,638,"j"]],[630,638],[631,631]]],[1561527964003,["GJX@GJXAIOU",[[1,631,"ava"]],[631,631],[634,634]]],[1561527964145,["GJX@GJXAIOU",[[1,635,"\n"]],[634,634],[635,635]]],[1561527975750,["GJX@GJXAIOU",[[1,635,"class Solution {\n    public int[][] imageSmoother(int[][] M) {\n        //因为矩阵的长和宽的范围为1-150\n        //输入合法性判断\n        if (M == null ) {\n            return M;\n        }\n\n        //每个元素取整值为它所在行and上一行and下一行的所在列本列和前后列\n        //判断该元素的前后左右是否存在，如果存在就加进去，然后求平均\n        //对于实际存在几个元素，可以使用num进行计数；\n        int cow = M.length;\n        int column = M[0].length;\n        int sum = 0;\n        int [][] ans = new int[cow][column];\n        //System.arraycopy(M, 0, M_copy, 0, cow*column);\n        int count = 0;\n\n        for (int i = 0; i < cow; i++ ) {\n            for (int j = 0; j < column; j++ ) {\n                //判断上方是否存在\n                if (i - 1 >= 0) {\n                    sum += M[i - 1][j]; \n                    count++;           \n                }\n\n                //判断下方是否存在\n                if (i + 1 <= cow - 1) {\n                    sum += M[i + 1][j];\n                    count++;\n                }\n\n                //判断左面是否存在\n                if (j - 1 >= 0) {\n                    sum += M[i][j - 1];\n                    count++;\n                }\n\n                //判断右面是否存在\n                if (j + 1 <= column - 1) {\n                    sum += M[i][j + 1];\n                    count++;\n                }\n\n\n                //判断左上是否存在\n                if ((i - 1 >= 0) && (j - 1 >= 0)) {\n                    sum += M[i - 1][j - 1];\n                    count++;\n                }\n\n                //判断右上是否存在\n                if ((i - 1 >= 0) && (j + 1 <= column - 1)) {\n                    sum += M[i - 1][j + 1];\n                    count++;\n                }\n\n\n                //判断左下是否存在\n                 if ((i + 1 <= cow - 1) && (j - 1 >= 0)) {\n                    sum += M[i + 1][j - 1];\n                    count++;\n                }\n\n\n                //判断右下是否存在\n                if ((i + 1 <= cow -1) && (j + 1 <= column -1)) {\n                    sum += M[i + 1][j + 1];\n                    count++;\n                }\n\n\n                sum += M[i][j];\n                count++;\n\n                //求平均值\n                int avg = sum / count;\n                //赋值        \n                ans[i][j] = avg;\n\n            }\n        }\n        return ans;\n    }\n}"]],[635,635],[2794,2794]]],[1561527982091,["GJX@GJXAIOU",[[1,614,"\n"]],[612,612],[613,613]]],[1561527986483,["GJX@GJXAIOU",[[1,613,"- tijie"]],[613,613],[620,620]]],[1561527987639,["GJX@GJXAIOU",[[-1,615,"tijie"]],[620,620],[615,615]]],[1561527990983,["GJX@GJXAIOU",[[1,615,"题解一"]],[615,615],[618,618]]],[1561527991585,["GJX@GJXAIOU",[[1,619,"- \n"]],[618,618],[621,621]]],[1561527992251,["GJX@GJXAIOU",[[-1,619,"- "]],[621,621],[619,619]]],[1561528065674,["GJX@GJXAIOU",[[1,619,"题解思路：暴力破解：左、右、正上、正下、左上、左下、右上、右下，看是否有这个元素，有则加进去，最后求平均\n\nclass Solution {\npublic:\n    vector<vector<int>> imageSmoother(vector<vector<int>>& M) \n    {\n        vector<vector<int>> nums(M);\n        int size_1 = M.size();\n        for(int i = 0;i<size_1;i++)\n        {         \n            for(int j = 0;j < M[i].size();j++)\n            {\n                int temp = 0;\n                int count = 1;  \n                temp += M[i][j];\n                if(i-1 >= 0)\n                {\n                    temp += M[i-1][j]; \n                    count++;\n                }\n                if(i+1 < size_1)\n                {\n                    temp += M[i+1][j];  \n                    count++;\n                }\n                if(j-1 >= 0)\n                {\n                    temp += M[i][j-1];\n                    count++;\n                }\n                if(j+1 < M[i].size())\n                {\n                    temp += M[i][j+1];\n                    count++;\n                }\n                if(i-1 >= 0 && j-1 >= 0)\n                {\n                    temp += M[i-1][j-1];\n                    count++;\n                }\n                if(i-1 >= 0 && j+1 < M[i].size())\n                {\n                    temp += M[i-1][j+1];\n                    count++;\n                }\n                if(i+1 < size_1 && j-1 >= 0)\n                {\n                    temp += M[i+1][j-1];\n                    count++;\n                }\n                if(i+1 < size_1 && j+1 < M[i].size())\n                {\n                    temp += M[i+1][j+1];\n                    count++;\n                }\n                nums[i][j]=temp/count;\n            }\n        }\n        return nums;\n    }\n};\n\n作者：gui-dao\n链接：https://leetcode-cn.com/problems/two-sum/solution/tu-pian-ping-hua-qi-by-gui-dao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[619,619],[2449,2449]]],[1561528068783,["GJX@GJXAIOU",[[1,672,"·"]],[672,672],[673,673]]],[1561528069866,["GJX@GJXAIOU",[[-1,672,"·"]],[673,673],[672,672]]],[1561528072181,["GJX@GJXAIOU",[[1,672,"```java"]],[672,672],[679,679]]],[1561528077558,["GJX@GJXAIOU",[[1,2309,"```"]],[2309,2309],[2312,2312]]],[1561528079814,["GJX@GJXAIOU",[[1,2461,"\n"]],[2460,2460],[2461,2461]]],[1561528079949,["GJX@GJXAIOU",[[1,2462,"\n"]],[2461,2461],[2462,2462]]],[1561528080081,["GJX@GJXAIOU",[[1,2463,"\n"]],[2462,2462],[2463,2463]]],[1561528080183,["GJX@GJXAIOU",[[1,2464,"\n"]],[2463,2463],[2464,2464]]],[1561528102476,["GJX@GJXAIOU",[[1,2462,"- ### 八个方向都用if判断太麻烦了，设置偏移标志数组显得简单很多——Java\n\n子墨\n\n发布于 1 个月前\n\n132 阅读\n\nJava\n\n思路：遍历，直接计算周围的8个单元和它本身的值求平均即可。 \n\n代码：\n\n```\nclass Solution {\n    int row = 0;\n    int col = 0;\n\n    public int[][] imageSmoother(int[][] M) {\n        if (M == null || M.length < 1 || M[0] == null || M[0].length < 1) {\n            return null;\n        }\n\n        row = M.length;\n        col = M[row - 1].length;\n\n        int ans[][] = new int[row][col];\n\n        for (int i = 0;i < row;i++) {\n            for (int j = 0;j < col;j++) {\n                ans[i][j] = calcul(M,i,j);\n            }\n        }\n\n        return ans;\n    }\n\n    // 上、下、左、右，上左，上右，下左，下右\n    int dirR[] = {-1,1,0,0,-1,-1,1,1};\n    int dirC[] = {0,0,-1,1,-1,1,-1,1};\n\n    private int calcul(int arr[][],int i,int j) {\n        int count = 1;\n        int sum = arr[i][j];\n\n        for (int k = 0;k < dirR.length;k++) {\n            int nextR = i + dirR[k];\n            int nextC = j + dirC[k];\n\n            if (nextR >= 0 && nextR < row && nextC >= 0 && nextC < col) {\n                count++;\n                sum += arr[nextR][nextC];\n            }\n        }\n\n        return sum / count;\n    }\n}\n\n```\n\n![image.png](https://pic.leetcode-cn.com/06f6e2ecf2a8a2b525822d90f261a7d838b211d4a9f92de270feb187064d0766-image.png)"]],[2462,2462],[3714,3714]]],[1561528105394,["GJX@GJXAIOU",[[-1,2464,"### "]],[2464,2468],[2464,2464]]],[1561528105822,["GJX@GJXAIOU",[[1,2464,"f"],[-1,2508," "],[1,2509," "],[-1,2519," "],[1,2520," "],[-1,2559," "],[1,2560," "]],[2464,2464],[2465,2465]]],[1561528106607,["GJX@GJXAIOU",[[1,2465,"anger"]],[2465,2465],[2470,2470]]],[1561528108476,["GJX@GJXAIOU",[[-1,2464,"fanger"]],[2470,2470],[2464,2464]]],[1561528113221,["GJX@GJXAIOU",[[1,2464,"方案二："]],[2464,2464],[2468,2468]]],[1561528113658,["GJX@GJXAIOU",[[1,2468,"\n"]],[2468,2468],[2469,2469]]],[1561528118367,["GJX@GJXAIOU",[[-1,2498,"——Java"]],[2498,2504],[2498,2498]]],[1561528122701,["GJX@GJXAIOU",[[-1,2500,"子墨\n\n发布于 1 个月前\n\n132 阅读\n\nJava\n"]],[2499,2527],[2499,2499]]],[1561528123539,["GJX@GJXAIOU",[[-1,2500,"\n"]],[2499,2499],[2498,2498]]],[1561528129022,["GJX@GJXAIOU",[[1,2540,"java"]],[2540,2540],[2544,2544]]],[1561528139213,["GJX@GJXAIOU",[[1,3687,"\n"]],[3685,3685],[3686,3686]]],[1561528139373,["GJX@GJXAIOU",[[1,3688,"\n"]],[3686,3686],[3687,3687]]],[1561528428885,["GJX@GJXAIOU",[[-1,18,"完成"]],[20,20],[18,18]]],[1561528431703,["GJX@GJXAIOU",[[1,18,"参考"]],[18,18],[20,20]]],[1561528465428,["GJX@GJXAIOU",[[-1,68,"5"]],[69,69],[68,68]]],[1561528466282,["GJX@GJXAIOU",[[1,68,"6"]],[68,68],[69,69]]]],null,"GJX@GJXAIOU"]]}