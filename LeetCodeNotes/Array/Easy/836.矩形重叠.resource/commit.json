{"compress":true,"commitItems":[["6ee68b36-4812-4d94-a927-a8fb90a2ac6e",1560064850421,"",[[1560064802040,["GJX@GJXAIOU",[[1,0,"# 836.矩形重叠\n\n\n\n"]],[0,0],[13,13]]],[1560064804664,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1560064806162,["GJX@GJXAIOU",[[1,0,"`"]],[0,0],[1,1]]],[1560064806337,["GJX@GJXAIOU",[[1,0,"`"]],[1,1],[2,2]]],[1560064807302,["GJX@GJXAIOU",[[-1,0,"``"]],[2,2],[0,0]]],[1560064807658,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1560064807929,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1560064809304,["GJX@GJXAIOU",[[-1,0,"--"]],[2,2],[0,0]]],[1560064810376,["GJX@GJXAIOU",[[1,0,"---\ntags: \n  - 简单\n  - 完成\n  - 数组\n  - \n\nflag: green\ndate: '2019-6-9'\n---"]],[0,0],[70,70]]],[1560064816800,["GJX@GJXAIOU",[[1,85,"\n"]],[82,82],[83,83]]],[1560064824256,["GJX@GJXAIOU",[[1,86,"\n"]],[83,83],[84,84]]],[1560064826426,["GJX@GJXAIOU",[[1,84,"## yi "]],[84,84],[90,90]]],[1560064827520,["GJX@GJXAIOU",[[-1,87,"yi "]],[90,90],[87,87]]],[1560064830068,["GJX@GJXAIOU",[[1,87,"一、题目"]],[87,87],[91,91]]],[1560064830569,["GJX@GJXAIOU",[[1,94,"\n"]],[91,91],[92,92]]],[1560064830920,["GJX@GJXAIOU",[[1,95,"\n"]],[92,92],[93,93]]],[1560064834523,["GJX@GJXAIOU",[[1,93,"矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n\n给出两个矩形，判断它们是否重叠并返回结果。\n\n示例 1：\n\n输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n输出：true\n示例 2：\n\n输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n输出：false\n说明：\n\n两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。\n矩形中的所有坐标都处于 -10^9 和 10^9 之间。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rectangle-overlap\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[93,93],[510,510]]],[1560064842159,["GJX@GJXAIOU",[[-1,406,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/rectangle-overlap\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[406,510],[406,406]]],[1560066805974,["GJX@GJXAIOU",[[1,409,"\n"]],[406,406],[407,407]]],[1560066806102,["GJX@GJXAIOU",[[1,410,"\n"]],[407,407],[408,408]]],[1560066806224,["GJX@GJXAIOU",[[1,411,"\n"]],[408,408],[409,409]]],[1560066807728,["GJX@GJXAIOU",[[1,376,"### "]],[401,401],[408,408]]],[1560066809899,["GJX@GJXAIOU",[[-1,376,"### "]],[408,408],[401,401]]],[1560066816099,["GJX@GJXAIOU",[[1,410,"## 二、解答"]],[410,410],[417,417]]],[1560066816430,["GJX@GJXAIOU",[[1,419,"\n"]],[417,417],[418,418]]],[1560066816534,["GJX@GJXAIOU",[[1,420,"\n"]],[418,418],[419,419]]],[1560066816678,["GJX@GJXAIOU",[[1,421,"\n"]],[419,419],[420,420]]],[1560066816800,["GJX@GJXAIOU",[[1,422,"\n"]],[420,420],[421,421]]],[1560066816909,["GJX@GJXAIOU",[[1,423,"\n"]],[421,421],[422,422]]],[1560066817249,["GJX@GJXAIOU",[[1,424,"\n"]],[422,422],[423,423]]],[1560066817752,["GJX@GJXAIOU",[[1,425,"\n"]],[423,423],[424,424]]],[1560066817786,["GJX@GJXAIOU",[[1,426,"\n"]],[424,424],[425,425]]],[1560066817816,["GJX@GJXAIOU",[[1,427,"\n"]],[425,425],[426,426]]],[1560066817852,["GJX@GJXAIOU",[[1,428,"\n"]],[426,426],[427,427]]],[1560066817892,["GJX@GJXAIOU",[[1,429,"\n"]],[427,427],[428,428]]],[1560066817916,["GJX@GJXAIOU",[[1,430,"\n"]],[428,428],[429,429]]],[1560066817952,["GJX@GJXAIOU",[[1,431,"\n"]],[429,429],[430,430]]],[1560066817984,["GJX@GJXAIOU",[[1,432,"\n"]],[430,430],[431,431]]],[1560066818567,["GJX@GJXAIOU",[[1,431,"-0 "]],[431,431],[434,434]]],[1560066819086,["GJX@GJXAIOU",[[-1,432,"0 "]],[434,434],[432,432]]],[1560066822682,["GJX@GJXAIOU",[[1,432," 自我解答："]],[432,432],[438,438]]],[1560066823102,["GJX@GJXAIOU",[[1,439,"- \n"]],[438,438],[441,441]]],[1560066824246,["GJX@GJXAIOU",[[-1,439,"- "]],[441,441],[439,439]]],[1560066826810,["GJX@GJXAIOU",[[1,439,"··"]],[439,439],[441,441]]],[1560066827790,["GJX@GJXAIOU",[[-1,439,"··"]],[441,441],[439,439]]],[1560066829006,["GJX@GJXAIOU",[[1,439,"```"]],[439,439],[442,442]]],[1560066829029,["GJX@GJXAIOU",[[1,442,"language\n```\n"]],[442,442],[442,450]]],[1560066830321,["GJX@GJXAIOU",[[-1,442,"language"],[1,450,"j"]],[442,450],[443,443]]],[1560066830526,["GJX@GJXAIOU",[[1,443,"a"]],[443,443],[444,444]]],[1560066830846,["GJX@GJXAIOU",[[1,444,"va"]],[444,444],[446,446]]],[1560066831119,["GJX@GJXAIOU",[[1,447,"\n"]],[446,446],[447,447]]],[1560066832274,["GJX@GJXAIOU",[[1,447,"class Solution {\n    //这里默认的是两个矩形均与坐标轴平行\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        int length = 0 ;\n        int width = 0;\n        if (rec1[0] < rec2[0]) {\n            length = Math.abs(rec1[2] - rec1[0]) ;\n        }else{\n            length = Math.abs(rec2[2] - rec2[0]) ;\n        }\n        if (rec1[1] < rec2[1]) {\n            width = Math.abs(rec1[3] - rec1[1]);\n        }else{\n            width = Math.abs(rec2[3] - rec2[1]);\n        }\n        \n        boolean a = (Math.abs(rec1[0] - rec2[0]) >= length ) || (Math.abs(rec1[1] - rec2[1]) >= width);   \n        return !a;\n    }\n\n}"]],[447,447],[1059,1059]]],[1560066835838,["GJX@GJXAIOU",[[1,439,"- \n"]],[438,438],[441,441]]],[1560066835998,["GJX@GJXAIOU",[[-1,439,"- "]],[441,441],[440,440]]],[1560066838725,["GJX@GJXAIOU",[[1,440,"\n"]],[439,439],[440,440]]],[1560066855158,["GJX@GJXAIOU",[[1,440,"执行用时 : 1 ms, 在Rectangle Overlap的Java提交中击败了83.41% 的用户\n\n内存消耗 : 33.4 MB, 在Rectangle Overlap的Java提交中击败了95.83% 的用户"]],[440,440],[549,549]]],[1560067338066,["GJX@GJXAIOU",[[-1,29,"数组"]],[31,31],[29,29]]],[1560067339085,["GJX@GJXAIOU",[[1,29,"s"],[-1,444," "],[1,445," "],[-1,486," "],[1,487," "],[-1,498," "],[1,499," "],[-1,543," "],[1,544," "]],[29,29],[30,30]]],[1560067339692,["GJX@GJXAIOU",[[1,30,"huxe"]],[30,30],[34,34]]],[1560067340651,["GJX@GJXAIOU",[[-1,29,"shuxe"]],[34,34],[29,29]]],[1560067342223,["GJX@GJXAIOU",[[1,29,"数学"]],[29,29],[31,31]]]],null,"GJX@GJXAIOU"],["18ba9197-5fe7-40be-9482-f12ed0f4c7f4",1561361095914,"---\ntags: \n  - 简单\n  - 完成\n  - 数学\n  - \n\nflag: green\ndate: '2019-6-9'\n---\n# 836.矩形重叠\n\n\n## 一、题目\n\n矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。\n\n如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。\n\n给出两个矩形，判断它们是否重叠并返回结果。\n\n示例 1：\n\n输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n输出：true\n示例 2：\n\n输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n输出：false\n说明：\n\n两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。\n矩形中的所有坐标都处于 -10^9 和 10^9 之间。\n\n\n\n\n\n## 二、解答\n\n\n\n\n\n\n\n\n\n\n\n\n\n- 自我解答：\n\n执行用时 : 1 ms, 在Rectangle Overlap的Java提交中击败了83.41% 的用户\n\n内存消耗 : 33.4 MB, 在Rectangle Overlap的Java提交中击败了95.83% 的用户\n```java\nclass Solution {\n    //这里默认的是两个矩形均与坐标轴平行\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        int length = 0 ;\n        int width = 0;\n        if (rec1[0] < rec2[0]) {\n            length = Math.abs(rec1[2] - rec1[0]) ;\n        }else{\n            length = Math.abs(rec2[2] - rec2[0]) ;\n        }\n        if (rec1[1] < rec2[1]) {\n            width = Math.abs(rec1[3] - rec1[1]);\n        }else{\n            width = Math.abs(rec2[3] - rec2[1]);\n        }\n        \n        boolean a = (Math.abs(rec1[0] - rec2[0]) >= length ) || (Math.abs(rec1[1] - rec2[1]) >= width);   \n        return !a;\n    }\n\n}\n```\n\n\n",[[1561361066567,["GJX@GJXAIOU",[[1,50,"\n"]],[49,49],[50,50]]],[1561361072007,["GJX@GJXAIOU",[[1,50,"style: summer"]],[50,50],[63,63]]]],null,"GJX@GJXAIOU"]]}