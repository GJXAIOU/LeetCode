{"compress":true,"commitItems":[["d6384b6a-decf-4aa1-ace6-79169745632d",1559804820842,"",[[1559804772158,["GJX@GJXAIOU",[[1,0,"# 5.最长公共前缀\n\n\n\n"]],[0,0],[13,13]]],[1559804775113,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1559804775255,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1559804775359,["GJX@GJXAIOU",[[1,2,"\n"]],[2,2],[3,3]]],[1559804777199,["GJX@GJXAIOU",[[1,0,"·"]],[0,0],[1,1]]],[1559804778200,["GJX@GJXAIOU",[[-1,0,"·"]],[1,1],[0,0]]],[1559804778497,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1559804778642,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1559804779154,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1559804779178,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1559804783337,["GJX@GJXAIOU",[[1,4,"tags: "]],[4,4],[10,10]]],[1559804984520,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1559804985417,["GJX@GJXAIOU",[[1,11,"-"]],[11,11],[12,12]]],[1559804986680,["GJX@GJXAIOU",[[-1,11,"-"]],[12,12],[11,11]]],[1559804986890,["GJX@GJXAIOU",[[-1,11,"\n"]],[11,11],[10,10]]],[1559804988483,["GJX@GJXAIOU",[[1,10," - "]],[10,10],[13,13]]],[1559804989379,["GJX@GJXAIOU",[[1,14,"\n"]],[13,13],[14,14]]],[1559804990152,["GJX@GJXAIOU",[[1,15,"\n"]],[14,14],[15,15]]],[1559804994057,["GJX@GJXAIOU",[[1,15,"gla"]],[15,15],[18,18]]],[1559804994610,["GJX@GJXAIOU",[[-1,15,"gla"]],[18,18],[15,15]]],[1559805000553,["GJX@GJXAIOU",[[1,15,"flag: gr"]],[15,15],[23,23]]],[1559805001281,["GJX@GJXAIOU",[[1,23,"een"]],[23,23],[26,26]]],[1559805003442,["GJX@GJXAIOU",[[1,27,"\n"]],[26,26],[27,27]]],[1559805006769,["GJX@GJXAIOU",[[1,27,"data"]],[27,27],[31,31]]],[1559805007423,["GJX@GJXAIOU",[[-1,30,"a"]],[31,31],[30,30]]],[1559805011579,["GJX@GJXAIOU",[[1,30,"e: ··"]],[30,30],[35,35]]],[1559805013208,["GJX@GJXAIOU",[[-1,33,"··"]],[35,35],[33,33]]],[1559805013443,["GJX@GJXAIOU",[[1,33,"·"]],[33,33],[34,34]]],[1559805014529,["GJX@GJXAIOU",[[-1,33,"·"]],[34,34],[33,33]]],[1559805015186,["GJX@GJXAIOU",[[1,33,"``"]],[33,33],[35,35]]],[1559805024473,["GJX@GJXAIOU",[[1,34,"2019-6-6"]],[34,34],[42,42]]],[1559805037571,["GJX@GJXAIOU",[[1,11,"\n"]],[11,11],[12,12]]],[1559805040505,["GJX@GJXAIOU",[[1,12,"     "]],[12,12],[17,17]]],[1559805042305,["GJX@GJXAIOU",[[1,19," "]],[18,18],[19,19]]],[1559805042881,["GJX@GJXAIOU",[[1,19,"ha"]],[19,19],[21,21]]],[1559805043552,["GJX@GJXAIOU",[[-1,19,"ha"]],[21,21],[19,19]]],[1559805047251,["GJX@GJXAIOU",[[1,34,"\n"]],[33,33],[34,34]]],[1559805049576,["GJX@GJXAIOU",[[-1,21,"\n"]],[21,21],[20,20]]],[1559805053215,["GJX@GJXAIOU",[[-1,25,": "]],[27,27],[25,25]]],[1559805055112,["GJX@GJXAIOU",[[1,25,"： "]],[25,25],[27,27]]],[1559805055794,["GJX@GJXAIOU",[[-1,25,"： "]],[27,27],[25,25]]],[1559805057345,["GJX@GJXAIOU",[[1,25,": "]],[25,25],[27,27]]],[1559805062712,["GJX@GJXAIOU",[[1,20,"dd"]],[20,20],[22,22]]],[1559805082801,["GJX@GJXAIOU",[[-1,14,"   "]],[16,16],[13,13]]],[1559805088967,["GJX@GJXAIOU",[[1,20,"  \n"]],[19,19],[22,22]]],[1559805101021,["GJX@GJXAIOU",[[-1,42,"`"]],[43,43],[42,42]]],[1559805101531,["GJX@GJXAIOU",[[1,42,"'"]],[42,42],[43,43]]],[1559805104202,["GJX@GJXAIOU",[[-1,51,"`"]],[52,52],[51,51]]],[1559805104536,["GJX@GJXAIOU",[[1,51,"'"]],[51,51],[52,52]]],[1559805116434,["GJX@GJXAIOU",[[1,74,"\n"]],[72,72],[73,73]]],[1559805116936,["GJX@GJXAIOU",[[1,75,"\n"]],[73,73],[74,74]]],[1559805116969,["GJX@GJXAIOU",[[1,76,"\n"]],[74,74],[75,75]]],[1559805117002,["GJX@GJXAIOU",[[1,77,"\n"]],[75,75],[76,76]]],[1559805117035,["GJX@GJXAIOU",[[1,78,"\n"]],[76,76],[77,77]]],[1559805117066,["GJX@GJXAIOU",[[1,79,"\n"]],[77,77],[78,78]]],[1559805117100,["GJX@GJXAIOU",[[1,80,"\n"]],[78,78],[79,79]]],[1559805117132,["GJX@GJXAIOU",[[1,81,"\n"]],[79,79],[80,80]]],[1559805117166,["GJX@GJXAIOU",[[1,82,"\n"]],[80,80],[81,81]]],[1559805117200,["GJX@GJXAIOU",[[1,83,"\n"]],[81,81],[82,82]]],[1559805117233,["GJX@GJXAIOU",[[1,84,"\n"]],[82,82],[83,83]]],[1559805117266,["GJX@GJXAIOU",[[1,85,"\n"]],[83,83],[84,84]]],[1559805117297,["GJX@GJXAIOU",[[1,86,"\n"]],[84,84],[85,85]]],[1559805117330,["GJX@GJXAIOU",[[1,87,"\n"]],[85,85],[86,86]]],[1559805117364,["GJX@GJXAIOU",[[1,88,"\n"]],[86,86],[87,87]]],[1559805117397,["GJX@GJXAIOU",[[1,89,"\n"]],[87,87],[88,88]]],[1559805117429,["GJX@GJXAIOU",[[1,90,"\n"]],[88,88],[89,89]]],[1559805117462,["GJX@GJXAIOU",[[1,91,"\n"]],[89,89],[90,90]]],[1559805117497,["GJX@GJXAIOU",[[1,92,"\n"]],[90,90],[91,91]]],[1559805117530,["GJX@GJXAIOU",[[1,93,"\n"]],[91,91],[92,92]]],[1559805117563,["GJX@GJXAIOU",[[1,94,"\n"]],[92,92],[93,93]]],[1559805117594,["GJX@GJXAIOU",[[1,95,"\n"]],[93,93],[94,94]]],[1559805117627,["GJX@GJXAIOU",[[1,96,"\n"]],[94,94],[95,95]]],[1559805117661,["GJX@GJXAIOU",[[1,97,"\n"]],[95,95],[96,96]]],[1559805117694,["GJX@GJXAIOU",[[1,98,"\n"]],[96,96],[97,97]]],[1559805117727,["GJX@GJXAIOU",[[1,99,"\n"]],[97,97],[98,98]]],[1559805117760,["GJX@GJXAIOU",[[1,100,"\n"]],[98,98],[99,99]]],[1559805117793,["GJX@GJXAIOU",[[1,101,"\n"]],[99,99],[100,100]]],[1559805124203,["GJX@GJXAIOU",[[1,74,"## yi"]],[74,74],[79,79]]],[1559805124928,["GJX@GJXAIOU",[[-1,77,"yi"]],[79,79],[77,77]]],[1559805127424,["GJX@GJXAIOU",[[1,77,"一、题目"]],[77,77],[81,81]]],[1559805128243,["GJX@GJXAIOU",[[1,109,"\n"]],[81,81],[82,82]]],[1559805144461,["GJX@GJXAIOU",[[1,84,"编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1:**\n\n**输入:** [\"flower\",\"flow\",\"flight\"]\n**输出:** \"fl\"\n\n**示例 2:**\n\n**输入:** [\"dog\",\"racecar\",\"car\"]\n**输出:** \"\"\n**解释:** 输入不存在公共前缀。\n\n**说明:**\n\n所有输入只包含小写字母 `a-z` 。"]],[84,84],[295,295]]],[1559808485654,["GJX@GJXAIOU",[[1,300,"### "]],[300,300],[304,304]]],[1559808487732,["GJX@GJXAIOU",[[-1,302,"# "]],[304,304],[302,302]]],[1559808491137,["GJX@GJXAIOU",[[-1,125," "],[1,126," "],[-1,137," "],[1,138," "],[-1,197," "],[1,198," "],[-1,287," "],[1,288," "],[-1,293," "],[1,294," "],[1,302," 二、解答"]],[302,302],[307,307]]],[1559808492309,["GJX@GJXAIOU",[[1,328,"\n"]],[307,307],[308,308]]],[1559808493691,["GJX@GJXAIOU",[[1,329,"\n"]],[308,308],[309,309]]],[1559808493820,["GJX@GJXAIOU",[[1,330,"\n"]],[309,309],[310,310]]],[1559808503275,["GJX@GJXAIOU",[[1,310,"自己代码：有问题"]],[310,310],[318,318]]],[1559808504608,["GJX@GJXAIOU",[[1,339,"\n"]],[318,318],[319,319]]],[1559808521229,["GJX@GJXAIOU",[[1,319,"[显示详情 ](https://leetcode-cn.com/submissions/detail/20208609/)\n\n输入\n\n[\"dog\",\"racecar\",\"car\"]\n\n输出\n\n\"d\"\n\n预期结果\n\n\"\""]],[319,319],[428,428]]],[1559808526860,["GJX@GJXAIOU",[[-1,319,"[显示详情 ](https://leetcode-cn.com/submissions/detail/20208609/)"]],[319,380],[319,319]]],[1559808527453,["GJX@GJXAIOU",[[-1,320,"\n"]],[319,319],[318,318]]],[1559808531131,["GJX@GJXAIOU",[[1,387,"\n"]],[366,366],[367,367]]],[1559808531267,["GJX@GJXAIOU",[[1,388,"\n"]],[367,367],[368,368]]],[1559808532247,["GJX@GJXAIOU",[[1,368,"~·"]],[368,368],[370,370]]],[1559808533171,["GJX@GJXAIOU",[[-1,368,"~·"]],[370,370],[368,368]]],[1559808534262,["GJX@GJXAIOU",[[1,368,"·"]],[368,368],[369,369]]],[1559808535129,["GJX@GJXAIOU",[[-1,368,"·"]],[369,369],[368,368]]],[1559808536022,["GJX@GJXAIOU",[[1,368,"```"]],[368,368],[371,371]]],[1559808536046,["GJX@GJXAIOU",[[1,371,"language\n```\n"]],[371,371],[371,379]]],[1559808537063,["GJX@GJXAIOU",[[-1,371,"language"],[1,379,"j"]],[371,379],[372,372]]],[1559808537499,["GJX@GJXAIOU",[[1,372,"ava"]],[372,372],[375,375]]],[1559808537678,["GJX@GJXAIOU",[[1,376,"\n"]],[375,375],[376,376]]],[1559808544618,["GJX@GJXAIOU",[[1,376,"class Solution {\n    public String longestCommonPrefix(String[] strs) {\n\n    \tif (strs.length == 0) {\n    \t\treturn \"\";\n    \t}else if (strs.length == 1) {\n    \t\treturn strs[0];\n    \t}else{\n    \t\t\n    \t\n    \t//获取数组中最短字符串的长度\n        int lowLength = strs[0].length();\n        for (int i = 1; i < strs.length; i++ ) {\n        \tif (lowLength > strs[i].length()) {\n           \t\tlowLength = strs[i].length();\n        \t}\n        }\n\n        int longFront = 0;\n        for (int i = 0; i < lowLength; i++) {\n        \tfor (int j = 0; j < strs.length - 1 ; j++ ) {\n        \t\tif (strs[j].charAt(i) != strs[j + 1].charAt(i)) {\n                    if(i == 0){\n                        longFront = 0;\n                    }else{\n                        longFront = i -1;\n                    }\n        \t\t\t\n                    break;\n        \t\t}\n        \t}\n        }\n\n        String  ans = new String(\"\");\n        \n        if(longFront == 0){\n            return \"\";\n        }else{\n        \tfor (int i = 0;i < longFront ;i++ ) {\n            \tans = ans + strs[0].charAt(i);\n            }\n        }\n        \t    \n             return ans;\n\n        }\n\n       \n    }\n}"]],[376,376],[1516,1516]]],[1559808549431,["GJX@GJXAIOU",[[1,310,"\n"]],[308,308],[309,309]]],[1559808549556,["GJX@GJXAIOU",[[1,311,"\n"]],[309,309],[310,310]]],[1559808549664,["GJX@GJXAIOU",[[1,312,"\n"]],[310,310],[311,311]]],[1559808549780,["GJX@GJXAIOU",[[1,313,"\n"]],[311,311],[312,312]]],[1559808549909,["GJX@GJXAIOU",[[1,314,"\n"]],[312,312],[313,313]]],[1559808550027,["GJX@GJXAIOU",[[1,315,"\n"]],[313,313],[314,314]]],[1559808553164,["GJX@GJXAIOU",[[1,314,"---"]],[314,314],[317,317]]],[1559808554675,["GJX@GJXAIOU",[[1,314,"\n"]],[313,313],[314,314]]],[1559808555177,["GJX@GJXAIOU",[[1,315,"\n"]],[314,314],[315,315]]],[1559808555208,["GJX@GJXAIOU",[[1,316,"\n"]],[315,315],[316,316]]],[1559808555241,["GJX@GJXAIOU",[[1,317,"\n"]],[316,316],[317,317]]],[1559808555275,["GJX@GJXAIOU",[[1,318,"\n"]],[317,317],[318,318]]],[1559808555307,["GJX@GJXAIOU",[[1,319,"\n"]],[318,318],[319,319]]],[1559808555341,["GJX@GJXAIOU",[[1,320,"\n"]],[319,319],[320,320]]],[1559808555373,["GJX@GJXAIOU",[[1,321,"\n"]],[320,320],[321,321]]],[1559808555406,["GJX@GJXAIOU",[[1,322,"\n"]],[321,321],[322,322]]],[1559808555440,["GJX@GJXAIOU",[[1,323,"\n"]],[322,322],[323,323]]],[1559808555472,["GJX@GJXAIOU",[[1,324,"\n"]],[323,323],[324,324]]],[1559808555506,["GJX@GJXAIOU",[[1,325,"\n"]],[324,324],[325,325]]],[1559808555538,["GJX@GJXAIOU",[[1,326,"\n"]],[325,325],[326,326]]],[1559808555571,["GJX@GJXAIOU",[[1,327,"\n"]],[326,326],[327,327]]],[1559808555604,["GJX@GJXAIOU",[[1,328,"\n"]],[327,327],[328,328]]],[1559808555645,["GJX@GJXAIOU",[[1,329,"\n"]],[328,328],[329,329]]],[1559808555673,["GJX@GJXAIOU",[[1,330,"\n"]],[329,329],[330,330]]],[1559808583915,["GJX@GJXAIOU",[[1,310,"方法一：水平扫描法\n思路\n\n首先，我们将描述一种查找一组字符串的最长公共前缀 LCP(S_1 \\ldots S_n)LCP(S \n1\n​\t\n …S \nn\n​\t\n ) 的简单方法。 我们将会用到这样的结论：\n\nLCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)LCP(S \n1\n​\t\n …S \nn\n​\t\n )=LCP(LCP(LCP(S \n1\n​\t\n ,S \n2\n​\t\n ),S \n3\n​\t\n ),…S \nn\n​\t\n )\n\n算法\n\n为了运用这种思想，算法要依次遍历字符串 [S_1 \\ldots S_n][S \n1\n​\t\n …S \nn\n​\t\n ]，当遍历到第 ii 个字符串的时候，找到最长公共前缀 LCP(S_1 \\ldots S_i)LCP(S \n1\n​\t\n …S \ni\n​\t\n )。当 LCP(S_1 \\ldots S_i)LCP(S \n1\n​\t\n …S \ni\n​\t\n ) 是一个空串的时候，算法就结束了。 否则，在执行了 nn 次遍历之后，算法就会返回最终答案 LCP(S_1 \\ldots S_n)LCP(S \n1\n​\t\n …S \nn\n​\t\n )。\n\n\n\n图 1. 查找最长公共前缀 （水平扫描法）\n\nJava\npublic String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return \"\";\n   String prefix = strs[0];\n   for (int i = 1; i < strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) {\n           prefix = prefix.substring(0, prefix.length() - 1);\n           if (prefix.isEmpty()) return \"\";\n       }        \n   return prefix;\n}\n\n复杂度分析\n\n时间复杂度：O(S)O(S)，S 是所有字符串中字符数量的总和。\n\n最坏的情况下，nn 个字符串都是相同的。算法会将 S1S1 与其他字符串 [S_2 \\ldots S_n][S \n2\n​\t\n …S \nn\n​\t\n ] 都做一次比较。这样就会进行 SS 次字符比较，其中 SS 是输入数据中所有字符数量。\n\n空间复杂度：O(1)O(1)，我们只需要使用常数级别的额外空间。\n\n算法二：水平扫描\n算法\n\n想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 S​S​ 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。\n\nJava\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n复杂度分析\n\n时间复杂度：O(S)O(S)，S 是所有字符串中字符数量的总和。\n\n最坏情况下，输入数据为 nn 个长度为 mm 的相同字符串，算法会进行 S = m*nS=m∗n 次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 n*minLenn∗minLen 次比较，其中 minLenminLen 是数组中最短字符串的长度。\n\n空间复杂度：O(1)O(1)，我们只需要使用常数级别的额外空间。\n\n算法三：分治\n思路\n\n这个算法的思路来自于LCP操作的结合律。 我们可以发现： LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))LCP(S \n1\n​\t\n …S \nn\n​\t\n )=LCP(LCP(S \n1\n​\t\n …S \nk\n​\t\n ),LCP(S \nk+1\n​\t\n …S \nn\n​\t\n )) ，其中 LCP(S_1 \\ldots S_n)LCP(S \n1\n​\t\n …S \nn\n​\t\n ) 是字符串 [S_1 \\ldots S_n][S \n1\n​\t\n …S \nn\n​\t\n ] 的最长公共前缀，1 < k < n1<k<n。\n\n算法\n\n为了应用上述的结论，我们使用分治的技巧，将原问题 LCP(S_i\\cdots S_j)LCP(S \ni\n​\t\n ⋯S \nj\n​\t\n ) 分成两个子问题 LCP(S_i\\cdots S_{mid})LCP(S \ni\n​\t\n ⋯S \nmid\n​\t\n ) 与 LCP(S_{mid+1}, S_j)LCP(S \nmid+1\n​\t\n ,S \nj\n​\t\n ) ，其中 mid = \\frac{i+j}{2} \n2\ni+j\n​\t\n 。 我们用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 LCP(S_i \\cdots S_j)LCP(S \ni\n​\t\n ⋯S \nj\n​\t\n )。 从头到尾挨个比较 lcpLeft 与 lcpRight 中的字符，直到不能再匹配为止。 计算所得的 lcpLeft 与 lcpRight 最长公共前缀就是原问题的解 LCP(S_i\\cdots S_j)LCP(S \ni\n​\t\n ⋯S \nj\n​\t\n )。\n\n\n\n图 2. 查找最长公共前缀的分治方法\n\nJava\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n复杂度分析\n\n最坏情况下，我们有 nn 个长度为 mm 的相同字符串。\n\n时间复杂度：O(S)O(S)，SS 是所有字符串中字符数量的总和，S=m*nS=m∗n。\n\n时间复杂度的递推式为 T(n)=2\\cdot T(\\frac{n}{2})+O(m)T(n)=2⋅T( \n2\nn\n​\t\n )+O(m)， 化简后可知其就是 O(S)O(S)。最好情况下，算法会进行 minLen\\cdot nminLen⋅n 次比较，其中 minLenminLen 是数组中最短字符串的长度。\n\n空间复杂度：O(m \\cdot log(n))O(m⋅log(n))\n\n内存开支主要是递归过程中使用的栈空间所消耗的。 一共会进行 log(n)log(n) 次递归，每次需要 mm 的空间存储返回结果，所以空间复杂度为 O(m\\cdot log(n))O(m⋅log(n))。\n\n方法四：二分查找法\n这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 L。 算法的查找区间是 (0 \\ldots minLen)(0…minLen)，其中 minLen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：\n\nS[1...mid] 不是所有串的公共前缀。 这表明对于所有的 j > i S[1..j] 也不是公共前缀，于是我们就可以丢弃后半个查找区间。\n\nS[1...mid] 是所有串的公共前缀。 这表示对于所有的 i < j S[1..i] 都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。\n\n\n\n图 3. 使用二分查找法寻找最长公共前缀\n\nJava\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}\n复杂度分析\n\n最坏情况下，我们有 nn 个长度为 mm 的相同字符串。\n\n时间复杂度：O(S \\cdot log(n))O(S⋅log(n))，其中 SS 所有字符串中字符数量的总和。\n\n算法一共会进行 log(n)log(n) 次迭代，每次一都会进行 S = m*nS=m∗n 次比较，所以总时间复杂度为 O(S \\cdot log(n))O(S⋅log(n))。\n\n空间复杂度：O(1)O(1)，我们只需要使用常数级别的额外空间。\n\n更进一步\n让我们看一个有些不同的问题：\n\n给定一些键值字符串 S = [S_1,S_2 \\ldots S_n][S \n1\n​\t\n ,S \n2\n​\t\n …S \nn\n​\t\n ]，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。\n\n我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从 208. 实现 Trie (前缀树) 开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：\n\n这是所查询的字符串 q 的一个前缀\n\n路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀\n\n路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长\n\n算法\n\n最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串 [S_1 \\ldots S_n][S \n1\n​\t\n …S \nn\n​\t\n ] 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。\n\n\n\n图 4. 使用字典树查找最长公共前缀\n\nJava\npublic String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // 子节点的链接数组\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // 非空子节点的数量\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    // 假设方法 containsKey、isEnd、get、put 都已经实现了\n    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n// 假设方法 insert、search、searchPrefix 都已经实现了\n// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}\n复杂度分析\n\n最坏情况下查询字符串 qq 的长度为 mm 并且它与数组中 nn 个字符串均相同。\n\n时间复杂度：预处理过程 O(S)O(S)，其中 SS 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 O(m)O(m)。\n\n建立字典树的时间复杂度为 O(S)O(S)。在字典树中查找字符串 qq 的最长公共前缀在最坏情况下需要 O(m)O(m) 的时间。\n\n空间复杂度：O(S)O(S)，我们只需要使用额外的 SS 空间建立字典树。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[310,310],[7897,7897]]],[1559808745532,["GJX@GJXAIOU",[[1,349,"$"]],[349,349],[350,350]]],[1559808750666,["GJX@GJXAIOU",[[-1,369,"LCP(S \n1\n​\t\n …S \nn"]],[369,387],[369,369]]],[1559808752346,["GJX@GJXAIOU",[[1,369,"$"]],[369,369],[370,370]]],[1559808770124,["GJX@GJXAIOU",[[-1,458,"LCP(S \n1\n​\t\n …S \nn\n​\t\n )=LCP(LCP(LCP(S \n1\n​\t\n ,S \n2\n​\t\n ),S \n3\n​\t\n ),…S \nn\n​\t\n )"]],[458,538],[458,458]]],[1559808774336,["GJX@GJXAIOU",[[1,398,"$"]],[398,398],[399,399]]],[1559808776558,["GJX@GJXAIOU",[[1,459,"$"]],[459,459],[460,460]]],[1559808783167,["GJX@GJXAIOU",[[-1,374," ) "]],[377,377],[374,374]]],[1559808783675,["GJX@GJXAIOU",[[-1,373,"\n"]],[374,374],[373,373]]],[1559808784676,["GJX@GJXAIOU",[[-1,371,"​\t"]],[373,373],[371,371]]],[1559808785244,["GJX@GJXAIOU",[[-1,370,"\n"]],[371,371],[370,370]]],[1559808787893,["GJX@GJXAIOU",[[-1,390,"\n"]],[390,390],[389,389]]],[1559808801395,["GJX@GJXAIOU",[[-1,494,"[S \n1\n​\t\n …S \nn\n​\t\n ]"]],[494,515],[494,494]]],[1559808803317,["GJX@GJXAIOU",[[1,494,"$"]],[494,494],[495,495]]],[1559808809030,["GJX@GJXAIOU",[[1,478,"$"]],[478,478],[479,479]]],[1559808829531,["GJX@GJXAIOU",[[-1,504,"i "]],[506,506],[504,504]]],[1559808833180,["GJX@GJXAIOU",[[1,521,"$"]],[521,521],[522,522]]],[1559808835588,["GJX@GJXAIOU",[[1,541,"$"]],[541,541],[542,542]]],[1559808839564,["GJX@GJXAIOU",[[-1,542,"LCP(S \n1\n​\t\n …S \ni\n​\t\n )"]],[542,566],[542,542]]],[1559808843112,["GJX@GJXAIOU",[[1,545,"$"]],[545,545],[546,546]]],[1559808845531,["GJX@GJXAIOU",[[1,565,"$"]],[565,565],[566,566]]],[1559808849548,["GJX@GJXAIOU",[[-1,566,"LCP(S \n1\n​\t\n …S \ni\n​\t\n ) "]],[566,591],[566,566]]],[1559808868314,["GJX@GJXAIOU",[[-1,630,"LCP(S \n1\n​\t\n …S \nn\n​\t\n )。\n"]],[630,656],[630,630]]],[1559808870030,["GJX@GJXAIOU",[[1,630,"V"]],[630,630],[631,631]]],[1559808872297,["GJX@GJXAIOU",[[1,611,"V"]],[611,611],[612,612]]],[1559808874587,["GJX@GJXAIOU",[[-1,611,"V"]],[612,612],[611,611]]],[1559808875164,["GJX@GJXAIOU",[[1,611,"$"]],[611,611],[612,612]]],[1559808876923,["GJX@GJXAIOU",[[-1,631,"V"]],[632,632],[631,631]]],[1559808877326,["GJX@GJXAIOU",[[1,631,"$"]],[631,631],[632,632]]],[1559808908740,["GJX@GJXAIOU",[[-1,635,"图 1. 查找最长公共前缀 （水平扫描法）\n"]],[634,656],[634,634]]],[1559808915461,["GJX@GJXAIOU",[[1,634,"![图 1. 查找最长公共前缀 （水平扫描法）]($resource/%E5%9B%BE%201.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%20%EF%BC%88%E6%B0%B4%E5%B9%B3%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%89.png)"]],[634,634],[830,830]]],[1559808924541,["GJX@GJXAIOU",[[1,831,"```"]],[831,831],[834,834]]],[1559808927440,["GJX@GJXAIOU",[[1,1184,"```"]],[1184,1184],[1187,1187]]],[1559808961524,["GJX@GJXAIOU",[[-1,1205,"O(S)"]],[1201,1205],[1201,1201]]],[1559808966644,["GJX@GJXAIOU",[[-1,1233,"n "]],[1235,1235],[1233,1233]]],[1559808970468,["GJX@GJXAIOU",[[-1,1250,"S1"]],[1250,1252],[1250,1250]]],[1559808974411,["GJX@GJXAIOU",[[1,1258,"图 1. 查找最长公共前缀 （水平扫描法）"]],[1258,1258],[1279,1279]]],[1559808976419,["GJX@GJXAIOU",[[-1,1258,"图 1. 查找最长公共前缀 （水平扫描法）"]],[1279,1279],[1258,1258]]],[1559808980006,["GJX@GJXAIOU",[[1,1258,"$"]],[1258,1258],[1259,1259]]],[1559808982563,["GJX@GJXAIOU",[[1,1275,"$"]],[1275,1275],[1276,1276]]],[1559808987019,["GJX@GJXAIOU",[[-1,1276,"[S \n2\n​\t\n …S \nn\n​\t\n ] "]],[1276,1298],[1276,1276]]],[1559809002220,["GJX@GJXAIOU",[[-1,1303,"S"]],[1304,1304],[1303,1303]]],[1559809004388,["GJX@GJXAIOU",[[-1,1291,"S"]],[1292,1292],[1291,1291]]],[1559809008411,["GJX@GJXAIOU",[[-1,1328,"O(1)"]],[1328,1332],[1328,1328]]],[1559809010910,["GJX@GJXAIOU",[[1,1225,"- "]],[1225,1225],[1227,1227]]],[1559809012798,["GJX@GJXAIOU",[[1,1195,"- "]],[1195,1195],[1197,1197]]],[1559809015941,["GJX@GJXAIOU",[[1,1322,"- "]],[1322,1322],[1324,1324]]],[1559809026925,["GJX@GJXAIOU",[[1,310,"### "]],[310,319],[323,323]]],[1559809030222,["GJX@GJXAIOU",[[1,324,"**"],[1,326,"**"]],[324,326],[324,330]]],[1559809033440,["GJX@GJXAIOU",[[1,462,"**"],[1,464,"**"]],[462,464],[462,468]]],[1559809037464,["GJX@GJXAIOU",[[1,1200,"**"],[1,1205,"**"]],[1200,1205],[1200,1209]]],[1559809383695,["GJX@GJXAIOU",[[-1,1370,"算法二：水平扫描"],[1,1378,"$"]],[1370,1378],[1371,1371]]],[1559809385503,["GJX@GJXAIOU",[[1,1370,"算法二：水平扫描"],[-1,1370,"$"]],[1371,1371],[1370,1378]]],[1559809386052,["GJX@GJXAIOU",[[1,1370,"**"],[1,1378,"**"]],[1370,1378],[1370,1382]]],[1559809388100,["GJX@GJXAIOU",[[1,1383,"**"],[1,1385,"**"]],[1383,1385],[1383,1389]]],[1559809420132,["GJX@GJXAIOU",[[-1,1422,"​S"]],[1423,1423],[1421,1421]]],[1559809423199,["GJX@GJXAIOU",[[1,1507,"```"]],[1507,1507],[1510,1510]]],[1559809425628,["GJX@GJXAIOU",[[1,1917,"\n"]],[1916,1916],[1917,1917]]],[1559809426247,["GJX@GJXAIOU",[[1,1917,"```"]],[1917,1917],[1920,1920]]],[1559809428889,["GJX@GJXAIOU",[[1,1921,"**"],[1,1926,"**"]],[1921,1926],[1921,1930]]],[1559809430776,["GJX@GJXAIOU",[[1,1932,"- "]],[1932,1932],[1934,1934]]],[1559809433362,["GJX@GJXAIOU",[[1,1968,"- "]],[1968,1968],[1970,1970]]],[1559809436382,["GJX@GJXAIOU",[[1,2115,"- "]],[2115,2115],[2117,2117]]],[1559809439030,["GJX@GJXAIOU",[[-1,2127,"O(1)"]],[2123,2127],[2123,2123]]],[1559809446999,["GJX@GJXAIOU",[[-1,2013,"S=m∗n"]],[2013,2018],[2013,2013]]],[1559809454681,["GJX@GJXAIOU",[[-1,2067,"∗minLen"]],[2067,2074],[2067,2067]]],[1559809458463,["GJX@GJXAIOU",[[-1,2081,"minLen "]],[2081,2088],[2081,2081]]],[1559809476582,["GJX@GJXAIOU",[[1,2006,"$"]],[2006,2006],[2007,2007]]],[1559809478719,["GJX@GJXAIOU",[[1,2015,"$"]],[2015,2015],[2016,2016]]],[1559809483629,["GJX@GJXAIOU",[[1,2060,"$"]],[2060,2060],[2061,2061]]],[1559809485706,["GJX@GJXAIOU",[[1,2070,"$"]],[2070,2070],[2071,2071]]],[1559809489651,["GJX@GJXAIOU",[[-1,2014," "]],[2015,2015],[2014,2014]]],[1559809500523,["GJX@GJXAIOU",[[1,2131,"**"],[1,2137,"**"]],[2131,2137],[2131,2141]]],[1559809502919,["GJX@GJXAIOU",[[1,2142,"**"],[1,2144,"**"]],[2142,2144],[2142,2148]]],[1559809514908,["GJX@GJXAIOU",[[1,2179,"$"]],[2179,2179],[2180,2180]]],[1559809528031,["GJX@GJXAIOU",[[1,2252,"$"]],[2252,2252],[2253,2253]]],[1559809532020,["GJX@GJXAIOU",[[-1,2253,"LCP(S \n1\n​\t\n …S \nn\n​\t\n )=LCP(LCP(S \n1\n​\t\n …S \nk\n​\t\n ),LCP(S \nk+1\n​\t\n …S \nn\n​\t\n )) "]],[2253,2335],[2253,2253]]],[1559809540844,["GJX@GJXAIOU",[[1,2257,"$"]],[2257,2257],[2258,2258]]],[1559809544628,["GJX@GJXAIOU",[[-1,2277,"LCP(S \n1\n​\t\n …S \nn\n​\t\n ) "]],[2277,2302],[2277,2277]]],[1559809546676,["GJX@GJXAIOU",[[1,2277,"$"]],[2277,2277],[2278,2278]]],[1559809553116,["GJX@GJXAIOU",[[1,2283,"$"]],[2283,2283],[2284,2284]]],[1559809560302,["GJX@GJXAIOU",[[-1,2300,"[S \n1\n​\t\n …S \nn\n​\t\n ] "]],[2300,2322],[2300,2300]]],[1559809560815,["GJX@GJXAIOU",[[1,2300,"$"]],[2300,2300],[2301,2301]]],[1559809568409,["GJX@GJXAIOU",[[-1,2318,"1<k<n"]],[2318,2323],[2318,2318]]],[1559809577612,["GJX@GJXAIOU",[[1,2321,"**"],[1,2323,"**"]],[2321,2323],[2321,2327]]],[1559809583645,["GJX@GJXAIOU",[[1,2354,"$"]],[2354,2354],[2355,2355]]],[1559809591596,["GJX@GJXAIOU",[[-1,2373,"LCP(S \ni\n​\t\n ⋯S \nj\n​\t\n )"],[1,2397,"$"]],[2373,2397],[2374,2374]]],[1559809601085,["GJX@GJXAIOU",[[1,2383,"$"]],[2383,2383],[2384,2384]]],[1559809607413,["GJX@GJXAIOU",[[-1,2406,"LCP(S \ni\n​\t\n ⋯S \nmid\n​\t\n )"],[1,2432,"$"]],[2406,2432],[2407,2407]]],[1559809610468,["GJX@GJXAIOU",[[1,2410,"$"]],[2410,2410],[2411,2411]]],[1559809614413,["GJX@GJXAIOU",[[-1,2430,"LCP(S \nmid+1\n​\t\n ,S \nj\n​\t\n ) "],[1,2459,"$"]],[2430,2459],[2431,2431]]],[1559809617655,["GJX@GJXAIOU",[[1,2435,"$"]],[2435,2435],[2436,2436]]],[1559809632676,["GJX@GJXAIOU",[[1,2456,"$"]],[2456,2456],[2457,2457]]],[1559809637837,["GJX@GJXAIOU",[[-1,2455," "]],[2456,2456],[2455,2455]]],[1559809643703,["GJX@GJXAIOU",[[-1,2457,"2\ni+j\n​\t\n"]],[2457,2466],[2457,2457]]],[1559809644630,["GJX@GJXAIOU",[[-1,2456,"\n"]],[2457,2457],[2456,2456]]],[1559809655860,["GJX@GJXAIOU",[[1,2495,"$"]],[2495,2495],[2496,2496]]],[1559809659821,["GJX@GJXAIOU",[[-1,2515,"LCP(S \ni\n​\t\n ⋯S \nj\n​\t\n )"],[1,2539,"$"]],[2515,2539],[2516,2516]]],[1559809684909,["GJX@GJXAIOU",[[1,2601,"$"]],[2601,2601],[2602,2602]]],[1559809689779,["GJX@GJXAIOU",[[-1,2620,"LCP(S \ni\n​\t\n ⋯S \nj\n​\t\n )"],[1,2644,"$"]],[2620,2644],[2621,2621]]],[1559809710445,["GJX@GJXAIOU",[[-1,2626,"图 2. 查找最长公共前缀的分治方法"]],[2626,2644],[2626,2626]]],[1559809717506,["GJX@GJXAIOU",[[1,2625,"![图 2. 查找最长公共前缀的分治方法]($resource/%E5%9B%BE%202.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%E7%9A%84%E5%88%86%E6%B2%BB%E6%96%B9%E6%B3%95.png)"]],[2625,2625],[2797,2797]]],[1559809724223,["GJX@GJXAIOU",[[1,2799,"```"]],[2799,2799],[2802,2802]]],[1559809727132,["GJX@GJXAIOU",[[1,3598,"\n"]],[3597,3597],[3598,3598]]],[1559809727759,["GJX@GJXAIOU",[[1,3598,"```"]],[3598,3598],[3601,3601]]],[1559809742013,["GJX@GJXAIOU",[[1,3602,"**"],[1,3607,"**"]],[3602,3607],[3602,3611]]],[1559809746535,["GJX@GJXAIOU",[[1,3613,"-"]],[3613,3613],[3614,3614]]],[1559809748932,["GJX@GJXAIOU",[[-1,3613,"-"]],[3614,3614],[3613,3613]]],[1559809751592,["GJX@GJXAIOU",[[-1,3624,"n"]],[3624,3624],[3623,3623]]],[1559809754276,["GJX@GJXAIOU",[[-1,3631,"m"]],[3631,3631],[3630,3630]]],[1559809759865,["GJX@GJXAIOU",[[1,3641,"- "]],[3641,3641],[3643,3643]]],[1559809765002,["GJX@GJXAIOU",[[1,3845,"- "]],[3845,3845],[3847,3847]]],[1559809768764,["GJX@GJXAIOU",[[-1,3653,"O(S)"]],[3653,3657],[3653,3653]]],[1559809769934,["GJX@GJXAIOU",[[-1,3655,"S"]],[3655,3655],[3654,3654]]],[1559809773223,["GJX@GJXAIOU",[[-1,3726,"T(n)=2⋅T( \n2\nn"]],[3726,3740],[3726,3726]]],[1559809779454,["GJX@GJXAIOU",[[1,3726,"$"]],[3726,3726],[3727,3727]]],[1559809782479,["GJX@GJXAIOU",[[1,3695,"$"]],[3695,3695],[3696,3696]]],[1559809793568,["GJX@GJXAIOU",[[-1,3676,"S=m∗n"]],[3676,3681],[3676,3676]]],[1559809802348,["GJX@GJXAIOU",[[-1,3723,"\n​\t\n )+O(m)"]],[3723,3734],[3723,3723]]],[1559809806620,["GJX@GJXAIOU",[[-1,3738,"O(S)"]],[3738,3742],[3738,3738]]],[1559809817119,["GJX@GJXAIOU",[[-1,3764,"minLen⋅n"],[1,3772,"V"]],[3764,3772],[3765,3765]]],[1559809818781,["GJX@GJXAIOU",[[-1,3764,"V"]],[3765,3765],[3764,3764]]],[1559809819366,["GJX@GJXAIOU",[[1,3764,"图 2. 查找最长公共前缀的分治方法"]],[3764,3764],[3782,3782]]],[1559809820990,["GJX@GJXAIOU",[[-1,3764,"图 2. 查找最长公共前缀的分治方法"]],[3782,3782],[3764,3764]]],[1559809823310,["GJX@GJXAIOU",[[1,3764,"$"]],[3764,3764],[3765,3765]]],[1559809825863,["GJX@GJXAIOU",[[1,3751,"$"]],[3751,3751],[3752,3752]]],[1559809837524,["GJX@GJXAIOU",[[-1,3780,"minLen "]],[3780,3787],[3780,3780]]],[1559809842055,["GJX@GJXAIOU",[[1,3803,"$"]],[3803,3803],[3804,3804]]],[1559809846984,["GJX@GJXAIOU",[[-1,3821,"O(m⋅log(n))"],[1,3832,"$"]],[3821,3832],[3822,3822]]],[1559809855486,["GJX@GJXAIOU",[[-1,3914,"O(m⋅log(n))"],[1,3925,"$"]],[3914,3925],[3915,3915]]],[1559809857862,["GJX@GJXAIOU",[[1,3898,"$"]],[3898,3898],[3899,3899]]],[1559809860775,["GJX@GJXAIOU",[[1,3854,"$$"]],[3854,3854],[3856,3856]]],[1559809864396,["GJX@GJXAIOU",[[-1,3855,"$"]],[3856,3856],[3855,3855]]],[1559809867831,["GJX@GJXAIOU",[[-1,3861,"log(n)"],[1,3867,"$"]],[3861,3867],[3862,3862]]],[1559809871885,["GJX@GJXAIOU",[[1,3915,"**"],[1,3924,"**"]],[3915,3924],[3915,3928]]],[1559811407642,["GJX@GJXAIOU",[[-1,3988,"(0…minLen)"],[1,3998,"http://cet-bm.neea.edu.cn/Home/QuickPrintTestTicket"]],[3988,3998],[4039,4039]]],[1559811409701,["GJX@GJXAIOU",[[1,3988,"(0…minLen)"],[-1,3988,"http://cet-bm.neea.edu.cn/Home/QuickPrintTestTicket"]],[4039,4039],[3988,3998]]],[1559811413617,["GJX@GJXAIOU",[[-1,3988,"(0…minLen)"],[1,3998,"$"]],[3988,3998],[3989,3989]]],[1559811419629,["GJX@GJXAIOU",[[1,3971,"$"]],[3971,3971],[3972,3972]]],[1559811443555,["GJX@GJXAIOU",[[1,4085,"- "]],[4085,4085],[4087,4087]]],[1559811457745,["GJX@GJXAIOU",[[1,4160,"- "]],[4160,4160],[4162,4162]]],[1559811489566,["GJX@GJXAIOU",[[-1,4252,"图 3. 使用二分查找法寻找最长公共前缀\n"]],[4251,4272],[4251,4251]]],[1559811495411,["GJX@GJXAIOU",[[1,4251,"![图 3. 使用二分查找法寻找最长公共前缀]($resource/%E5%9B%BE%203.%20%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E5%AF%BB%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)"]],[4251,4251],[4443,4443]]],[1559811502104,["GJX@GJXAIOU",[[1,4444,"```"]],[4444,4444],[4447,4447]]],[1559811504759,["GJX@GJXAIOU",[[1,5184,"\n"]],[5183,5183],[5184,5184]]],[1559811505481,["GJX@GJXAIOU",[[1,5184,"```"]],[5184,5184],[5187,5187]]],[1559811507839,["GJX@GJXAIOU",[[1,5188,"**"],[1,5193,"**"]],[5188,5193],[5188,5197]]],[1559811515726,["GJX@GJXAIOU",[[-1,5210,"n "]],[5212,5212],[5210,5210]]],[1559811518475,["GJX@GJXAIOU",[[-1,5216,"m"]],[5216,5216],[5215,5215]]],[1559811520944,["GJX@GJXAIOU",[[1,5232,"`"]],[5232,5232],[5233,5233]]],[1559811522104,["GJX@GJXAIOU",[[1,5250,"`"]],[5250,5250],[5251,5251]]],[1559811524822,["GJX@GJXAIOU",[[-1,5232,"`"]],[5233,5233],[5232,5232]]],[1559811526223,["GJX@GJXAIOU",[[1,5232,"图 3. 使用二分查找法寻找最长公共前缀"]],[5232,5232],[5252,5252]]],[1559811527948,["GJX@GJXAIOU",[[-1,5232,"图 3. 使用二分查找法寻找最长公共前缀"]],[5252,5252],[5232,5232]]],[1559811530657,["GJX@GJXAIOU",[[1,5232,"$"]],[5232,5232],[5233,5233]]],[1559811533239,["GJX@GJXAIOU",[[-1,5250,"`"]],[5251,5251],[5250,5250]]],[1559811534980,["GJX@GJXAIOU",[[1,5250,"$"]],[5250,5250],[5251,5251]]],[1559811538313,["GJX@GJXAIOU",[[-1,5251,"O(S⋅log(n))"]],[5251,5262],[5251,5251]]],[1559811540365,["GJX@GJXAIOU",[[-1,5256,"S"]],[5256,5256],[5255,5255]]],[1559811545048,["GJX@GJXAIOU",[[1,5226,"- "]],[5226,5226],[5228,5228]]],[1559811551055,["GJX@GJXAIOU",[[-1,5284,"og(n)l"]],[5289,5289],[5283,5283]]],[1559811554078,["GJX@GJXAIOU",[[-1,5309,"S=m∗n"]],[5309,5314],[5309,5309]]],[1559811558336,["GJX@GJXAIOU",[[-1,5341,"O(S⋅log(n))"],[1,5352,"$"]],[5341,5352],[5342,5342]]],[1559811560921,["GJX@GJXAIOU",[[1,5324,"$"]],[5324,5324],[5325,5325]]],[1559811564880,["GJX@GJXAIOU",[[-1,5356,"O(1)"]],[5352,5356],[5352,5352]]],[1559811568857,["GJX@GJXAIOU",[[1,5346,"- "]],[5346,5346],[5348,5348]]],[1559811585479,["GJX@GJXAIOU",[[1,5378,"**"],[1,5382,"**"]],[5378,5382],[5378,5386]]],[1559811591687,["GJX@GJXAIOU",[[1,5413,"$"]],[5413,5413],[5414,5414]]],[1559811594321,["GJX@GJXAIOU",[[1,5438,"$"]],[5438,5438],[5439,5439]]],[1559811599023,["GJX@GJXAIOU",[[-1,5439,"[S \n1\n​\t\n ,S \n2\n​\t\n …S \nn\n​\t\n ]"]],[5439,5470],[5439,5439]]],[1559811635342,["GJX@GJXAIOU",[[-1,5540," "],[1,5541,"["],[1,5558,")](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/"]],[5540,5559],[5631,5631]]],[1559811645474,["GJX@GJXAIOU",[[1,5724,"- "]],[5724,5724],[5726,5726]]],[1559811648273,["GJX@GJXAIOU",[[1,5745,"- "]],[5745,5745],[5747,5747]]],[1559811650555,["GJX@GJXAIOU",[[1,5790,"- "]],[5790,5790],[5792,5792]]],[1559811654079,["GJX@GJXAIOU",[[1,5838,"**"],[1,5840,"**"]],[5838,5840],[5838,5844]]],[1559811657864,["GJX@GJXAIOU",[[1,5895,"https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/)["]],[5894,5894],[6036,6036]]],[1559811659619,["GJX@GJXAIOU",[[-1,5895,"https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/)["]],[6036,6036],[5894,5894]]],[1559811661991,["GJX@GJXAIOU",[[1,5894,"$"]],[5894,5894],[5895,5895]]],[1559811664366,["GJX@GJXAIOU",[[1,5911,"$"]],[5911,5911],[5912,5912]]],[1559811667974,["GJX@GJXAIOU",[[-1,5912,"[S \n1\n​\t\n …S \nn\n​\t\n ]"]],[5912,5933],[5912,5912]]],[1559811690183,["GJX@GJXAIOU",[[-1,5975,"图 4. 使用字典树查找最长公共前缀"]],[5975,5993],[5975,5975]]],[1559811701288,["GJX@GJXAIOU",[[1,5974,"![图 4. 使用字典树查找最长公共前缀]($resource/%E5%9B%BE%204.%20%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)"]],[5974,5974],[6146,6146]]],[1559811703785,["GJX@GJXAIOU",[[1,6148,"···"]],[6148,6148],[6151,6151]]],[1559811705087,["GJX@GJXAIOU",[[-1,6148,"···"]],[6151,6151],[6148,6148]]],[1559811706128,["GJX@GJXAIOU",[[1,6148,"```"]],[6148,6148],[6151,6151]]],[1559811713127,["GJX@GJXAIOU",[[1,7685,"\n"]],[7684,7684],[7685,7685]]],[1559811713251,["GJX@GJXAIOU",[[1,7686,"\n"]],[7685,7685],[7686,7686]]],[1559811713400,["GJX@GJXAIOU",[[1,7687,"\n"]],[7686,7686],[7687,7687]]],[1559811714451,["GJX@GJXAIOU",[[1,7686,"```"]],[7686,7686],[7689,7689]]],[1559811717018,["GJX@GJXAIOU",[[1,7691,"**"],[1,7696,"**"]],[7691,7696],[7691,7700]]],[1559811721930,["GJX@GJXAIOU",[[1,7745,"- "]],[7745,7745],[7747,7747]]],[1559811724747,["GJX@GJXAIOU",[[1,7818,"- "]],[7818,7818],[7820,7820]]],[1559811743953,["GJX@GJXAIOU",[[1,8088,"- lign"]],[8088,8088],[8094,8094]]],[1559811745688,["GJX@GJXAIOU",[[-1,8090,"lign"]],[8094,8094],[8090,8090]]],[1559811759602,["GJX@GJXAIOU",[[1,8090,"使用纯遍历做法，和我的类型"]],[8090,8090],[8103,8103]]],[1559811760347,["GJX@GJXAIOU",[[-1,8101,"类型"]],[8103,8103],[8101,8101]]],[1559811762107,["GJX@GJXAIOU",[[1,8101,"类似："]],[8101,8101],[8104,8104]]],[1559811762368,["GJX@GJXAIOU",[[1,8105,"- \n"]],[8104,8104],[8107,8107]]],[1559811763479,["GJX@GJXAIOU",[[-1,8105,"- "]],[8107,8107],[8105,8105]]],[1559811766488,["GJX@GJXAIOU",[[1,8105,"```java"]],[8105,8105],[8112,8112]]],[1559811766712,["GJX@GJXAIOU",[[1,8128,"\n"]],[8112,8112],[8113,8113]]],[1559811766815,["GJX@GJXAIOU",[[1,8129,"\n"]],[8113,8113],[8114,8114]]],[1559811766960,["GJX@GJXAIOU",[[1,8130,"\n"]],[8114,8114],[8115,8115]]],[1559811767080,["GJX@GJXAIOU",[[1,8131,"\n"]],[8115,8115],[8116,8116]]],[1559811767208,["GJX@GJXAIOU",[[1,8132,"\n"]],[8116,8116],[8117,8117]]],[1559811767314,["GJX@GJXAIOU",[[1,8133,"\n"]],[8117,8117],[8118,8118]]],[1559811767437,["GJX@GJXAIOU",[[1,8134,"\n"]],[8118,8118],[8119,8119]]],[1559811767569,["GJX@GJXAIOU",[[1,8135,"\n"]],[8119,8119],[8120,8120]]],[1559811767707,["GJX@GJXAIOU",[[1,8136,"\n"]],[8120,8120],[8121,8121]]],[1559811768978,["GJX@GJXAIOU",[[1,8121,"```"]],[8121,8121],[8124,8124]]],[1559811771720,["GJX@GJXAIOU",[[1,8113,"class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        StringBuilder commonPrefix = new StringBuilder(\"\");\n        \n\t\t// 若只有一个字符串则返回第一个字符串\n\t\tif(strs.length == 1)\n\t\t\treturn strs[0];\n\t\t// 若为空集则返回空字符串\n\t\telse if (strs.length == 0)\n\t\t\treturn \"\";\n        \n\t\t// 获取最短字符串，以其长度参考\n\t\tint length = strs[0].length();\n\t\tfor(int i = 0; i < strs.length; i ++) {\n\t\t\tif(strs[i].length() < length)\n\t\t\t\tlength = strs[i].length();\n\t\t}\n\t\t\n\t\t// 检索字符串的字母，并逐次比较\n\t\tfor(int j = 0; j < length; j++) {\n\t\t\tfor(int k = 0; k < strs.length - 1; k++) {\n\t\t\t\tif(strs[k].charAt(j) != strs[k + 1].charAt(j))\n\t\t\t\t\treturn commonPrefix.toString();\n\t\t\t\t}\n\t\t\tcommonPrefix.append(strs[0].charAt(j));\n\t\t}\n\t\treturn commonPrefix.toString();\n\t}\n}\n作者：lui-3\n链接：https://leetcode-cn.com/problems/two-sum/solution/wa-wo-zhe-ren-shi-zhen-de-xi-huan-bian-li-by-lui-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[8113,8113],[9000,9000]]],[1559811776768,["GJX@GJXAIOU",[[-1,8836,"作者：lui-3\n链接：https://leetcode-cn.com/problems/two-sum/solution/wa-wo-zhe-ren-shi-zhen-de-xi-huan-bian-li-by-lui-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n"]],[8836,9007],[8836,8836]]],[1559811778615,["GJX@GJXAIOU",[[1,8842,"作者：lui-3\n链接：https://leetcode-cn.com/problems/two-sum/solution/wa-wo-zhe-ren-shi-zhen-de-xi-huan-bian-li-by-lui-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n"]],[8842,8842],[9013,9013]]],[1559811780859,["GJX@GJXAIOU",[[-1,9026,"\n"]],[9025,9025],[9024,9024]]],[1559811780991,["GJX@GJXAIOU",[[-1,9025,"\n"]],[9024,9024],[9023,9023]]],[1559811781279,["GJX@GJXAIOU",[[-1,9023,"\n"]],[9022,9022],[9021,9021]]],[1559811781376,["GJX@GJXAIOU",[[-1,9022,"\n"]],[9021,9021],[9020,9020]]],[1559811781506,["GJX@GJXAIOU",[[-1,9021,"\n"]],[9020,9020],[9019,9019]]],[1559811781751,["GJX@GJXAIOU",[[-1,9020,"\n"]],[9019,9019],[9018,9018]]],[1559811781921,["GJX@GJXAIOU",[[-1,9019,"\n"]],[9018,9018],[9017,9017]]],[1559811782087,["GJX@GJXAIOU",[[-1,9018,"\n"]],[9017,9017],[9016,9016]]],[1559811901160,[null,[[-1,9018,"\n"]],[9018,9018],[9018,9018]]],[1559811901160,[null,[[1,9018,"\n"]],[9018,9018],[9018,9018]]],[1559811882942,["GJX@GJXAIOU",[[-1,17,"dd"]],[19,19],[17,17]]],[1559811884865,["GJX@GJXAIOU",[[1,17,"遍历"]],[17,17],[19,19]]],[1559811885910,["GJX@GJXAIOU",[[1,23,"  \n"]],[19,19],[22,22]]],[1559811890651,["GJX@GJXAIOU",[[1,22,"- 二分法"]],[22,22],[27,27]]],[1559811891004,["GJX@GJXAIOU",[[1,31,"  \n"]],[27,27],[30,30]]],[1559811892380,["GJX@GJXAIOU",[[1,30,"- "]],[30,30],[32,32]]],[1559811961153,[null,[[-1,9031,"\n"]],[9031,9031],[9031,9031]]],[1559811961153,[null,[[1,9031,"\n"]],[9031,9031],[9031,9031]]],[1559811906979,["GJX@GJXAIOU",[[1,32,"分治"]],[32,32],[34,34]]]],null,"GJX@GJXAIOU"],["8b7b32b5-0caf-4825-bcdd-b057de833cbb",1560058678250,"---\ntags:  \n  -  遍历\n  - 二分法\n  - 分治\n  \nflag: green\n\ndate: '2019-6-6'\n---\n\n\n\n# 5.最长公共前缀\n\n\n\n## 一、题目\n\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1:**\n\n**输入:** [\"flower\",\"flow\",\"flight\"]\n**输出:** \"fl\"\n\n**示例 2:**\n\n**输入:** [\"dog\",\"racecar\",\"car\"]\n**输出:** \"\"\n**解释:** 输入不存在公共前缀。\n\n**说明:**\n\n所有输入只包含小写字母 `a-z` 。\n\n\n\n\n## 二、解答\n\n\n### 方法一：水平扫描法\n**思路**\n\n首先，我们将描述一种查找一组字符串的最长公共前缀 $LCP(S_1 \\ldots S_n)$的简单方法。 我们将会用到这样的结论：\n$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$\n\n**算法**\n\n为了运用这种思想，算法要依次遍历字符串 $[S_1 \\ldots S_n]$，当遍历到第 i个字符串的时候，找到最长公共前缀 $LCP(S_1 \\ldots S_i)$。当 $LCP(S_1 \\ldots S_i)$是一个空串的时候，算法就结束了。 否则，在执行了 nn 次遍历之后，算法就会返回最终答案 $LCP(S_1 \\ldots S_n)$\n\n![图 1. 查找最长公共前缀 （水平扫描法）]($resource/%E5%9B%BE%201.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%20%EF%BC%88%E6%B0%B4%E5%B9%B3%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%89.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return \"\";\n   String prefix = strs[0];\n   for (int i = 1; i < strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) {\n           prefix = prefix.substring(0, prefix.length() - 1);\n           if (prefix.isEmpty()) return \"\";\n       }        \n   return prefix;\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏的情况下，n个字符串都是相同的。算法会将 S1 与其他字符串 $[S_2 \\ldots S_n]$都做一次比较。这样就会进行 S 次字符比较，其中 S 是输入数据中所有字符数量。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法二：水平扫描**\n**算法**\n\n想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 S​ 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏情况下，输入数据为 nn 个长度为 mm 的相同字符串，算法会进行 $S = m*n$次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 $n*minLenn$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法三：分治**\n**思路**\n\n这个算法的思路来自于LCP操作的结合律。 我们可以发现： $LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$，其中 $LCP(S_1 \\ldots S_n)$是字符串 $[S_1 \\ldots S_n]$的最长公共前缀，1 < k < n。\n\n**算法**\n\n为了应用上述的结论，我们使用分治的技巧，将原问题 $LCP(S_i\\cdots S_j)$ 分成两个子问题 $LCP(S_i\\cdots S_{mid})$ 与 $LCP(S_{mid+1}, S_j)$，其中 $mid = \\frac{i+j}{2}$ 。 我们用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 $LCP(S_i \\cdots S_j)$。 从头到尾挨个比较 lcpLeft 与 lcpRight 中的字符，直到不能再匹配为止。 计算所得的 lcpLeft 与 lcpRight 最长公共前缀就是原问题的解 $LCP(S_i\\cdots S_j)$。\n\n\n![图 2. 查找最长公共前缀的分治方法]($resource/%E5%9B%BE%202.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%E7%9A%84%E5%88%86%E6%B2%BB%E6%96%B9%E6%B3%95.png)\n\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n 个长度为 m 的相同字符串。\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和，S=m*n。\n\n时间复杂度的递推式为 $T(n)=2\\cdot T(\\frac{n}{2})+O(m)$， 化简后可知其就是 O(S)。最好情况下，算法会进行 $minLen\\cdot n$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：$O(m \\cdot log(n))$\n\n内存开支主要是递归过程中使用的栈空间所消耗的。 一共会进行 $log(n)$ 次递归，每次需要 mm 的空间存储返回结果，所以空间复杂度为 $O(m\\cdot log(n))$。\n\n**方法四：二分查找法**\n这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 L。 算法的查找区间是 $(0 \\ldots minLen)$，其中 minLen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：\n\n- S[1...mid] 不是所有串的公共前缀。 这表明对于所有的 j > i S[1..j] 也不是公共前缀，于是我们就可以丢弃后半个查找区间。\n\n- S[1...mid] 是所有串的公共前缀。 这表示对于所有的 i < j S[1..i] 都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。\n\n\n![图 3. 使用二分查找法寻找最长公共前缀]($resource/%E5%9B%BE%203.%20%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E5%AF%BB%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n个长度为 m 的相同字符串。\n\n- 时间复杂度：$O(S \\cdot log(n))$，其中 S 所有字符串中字符数量的总和。\n\n算法一共会进行 log(n) 次迭代，每次一都会进行 S = m*n 次比较，所以总时间复杂度为 $O(S \\cdot log(n))$。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**更进一步**\n让我们看一个有些不同的问题：\n\n给定一些键值字符串 $S = [S_1,S_2 \\ldots S_n]$，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。\n\n我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/) 开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：\n\n- 这是所查询的字符串 q 的一个前缀\n\n- 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀\n\n- 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长\n\n**算法**\n\n最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串 $[S_1 \\ldots S_n]$ 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。\n\n\n![图 4. 使用字典树查找最长公共前缀]($resource/%E5%9B%BE%204.%20%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n\n```Java\npublic String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // 子节点的链接数组\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // 非空子节点的数量\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    // 假设方法 containsKey、isEnd、get、put 都已经实现了\n    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n// 假设方法 insert、search、searchPrefix 都已经实现了\n// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n\n最坏情况下查询字符串 qq 的长度为 mm 并且它与数组中 nn 个字符串均相同。\n\n- 时间复杂度：预处理过程 O(S)O(S)，其中 SS 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 O(m)O(m)。\n\n- 建立字典树的时间复杂度为 O(S)O(S)。在字典树中查找字符串 qq 的最长公共前缀在最坏情况下需要 O(m)O(m) 的时间。\n\n空间复杂度：O(S)O(S)，我们只需要使用额外的 SS 空间建立字典树。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n- 使用纯遍历做法，和我的类似：\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        StringBuilder commonPrefix = new StringBuilder(\"\");\n        \n\t\t// 若只有一个字符串则返回第一个字符串\n\t\tif(strs.length == 1)\n\t\t\treturn strs[0];\n\t\t// 若为空集则返回空字符串\n\t\telse if (strs.length == 0)\n\t\t\treturn \"\";\n        \n\t\t// 获取最短字符串，以其长度参考\n\t\tint length = strs[0].length();\n\t\tfor(int i = 0; i < strs.length; i ++) {\n\t\t\tif(strs[i].length() < length)\n\t\t\t\tlength = strs[i].length();\n\t\t}\n\t\t\n\t\t// 检索字符串的字母，并逐次比较\n\t\tfor(int j = 0; j < length; j++) {\n\t\t\tfor(int k = 0; k < strs.length - 1; k++) {\n\t\t\t\tif(strs[k].charAt(j) != strs[k + 1].charAt(j))\n\t\t\t\t\treturn commonPrefix.toString();\n\t\t\t\t}\n\t\t\tcommonPrefix.append(strs[0].charAt(j));\n\t\t}\n\t\treturn commonPrefix.toString();\n\t}\n}\n\n```\n\n作者：lui-3\n链接：https://leetcode-cn.com/problems/two-sum/solution/wa-wo-zhe-ren-shi-zhen-de-xi-huan-bian-li-by-lui-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n---\n\n自己代码：有问题\n\n输入\n\n[\"dog\",\"racecar\",\"car\"]\n\n输出\n\n\"d\"\n\n预期结果\n\n\"\"\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n\n    \tif (strs.length == 0) {\n    \t\treturn \"\";\n    \t}else if (strs.length == 1) {\n    \t\treturn strs[0];\n    \t}else{\n    \t\t\n    \t\n    \t//获取数组中最短字符串的长度\n        int lowLength = strs[0].length();\n        for (int i = 1; i < strs.length; i++ ) {\n        \tif (lowLength > strs[i].length()) {\n           \t\tlowLength = strs[i].length();\n        \t}\n        }\n\n        int longFront = 0;\n        for (int i = 0; i < lowLength; i++) {\n        \tfor (int j = 0; j < strs.length - 1 ; j++ ) {\n        \t\tif (strs[j].charAt(i) != strs[j + 1].charAt(i)) {\n                    if(i == 0){\n                        longFront = 0;\n                    }else{\n                        longFront = i -1;\n                    }\n        \t\t\t\n                    break;\n        \t\t}\n        \t}\n        }\n\n        String  ans = new String(\"\");\n        \n        if(longFront == 0){\n            return \"\";\n        }else{\n        \tfor (int i = 0;i < longFront ;i++ ) {\n            \tans = ans + strs[0].charAt(i);\n            }\n        }\n        \t    \n             return ans;\n\n        }\n\n       \n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1560058623429,["GJX@GJXAIOU",[[1,12,"\n"]],[11,11],[12,12]]],[1560058627942,["GJX@GJXAIOU",[[1,12,"- 简单  "]],[12,12],[18,18]]],[1560058630140,["GJX@GJXAIOU",[[1,12,"  "]],[12,12],[14,14]]]],null,"GJX@GJXAIOU"],["9d8e5deb-246c-419d-afb4-9ca21878b060",1560157557217,"---\ntags:  \n  - 简单  \n  -  遍历\n  - 二分法\n  - 分治\n  \nflag: green\n\ndate: '2019-6-6'\n---\n\n\n\n# 5.最长公共前缀\n\n\n\n## 一、题目\n\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1:**\n\n**输入:** [\"flower\",\"flow\",\"flight\"]\n**输出:** \"fl\"\n\n**示例 2:**\n\n**输入:** [\"dog\",\"racecar\",\"car\"]\n**输出:** \"\"\n**解释:** 输入不存在公共前缀。\n\n**说明:**\n\n所有输入只包含小写字母 `a-z` 。\n\n\n\n\n## 二、解答\n\n\n### 方法一：水平扫描法\n**思路**\n\n首先，我们将描述一种查找一组字符串的最长公共前缀 $LCP(S_1 \\ldots S_n)$的简单方法。 我们将会用到这样的结论：\n$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$\n\n**算法**\n\n为了运用这种思想，算法要依次遍历字符串 $[S_1 \\ldots S_n]$，当遍历到第 i个字符串的时候，找到最长公共前缀 $LCP(S_1 \\ldots S_i)$。当 $LCP(S_1 \\ldots S_i)$是一个空串的时候，算法就结束了。 否则，在执行了 nn 次遍历之后，算法就会返回最终答案 $LCP(S_1 \\ldots S_n)$\n\n![图 1. 查找最长公共前缀 （水平扫描法）]($resource/%E5%9B%BE%201.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%20%EF%BC%88%E6%B0%B4%E5%B9%B3%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%89.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return \"\";\n   String prefix = strs[0];\n   for (int i = 1; i < strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) {\n           prefix = prefix.substring(0, prefix.length() - 1);\n           if (prefix.isEmpty()) return \"\";\n       }        \n   return prefix;\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏的情况下，n个字符串都是相同的。算法会将 S1 与其他字符串 $[S_2 \\ldots S_n]$都做一次比较。这样就会进行 S 次字符比较，其中 S 是输入数据中所有字符数量。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法二：水平扫描**\n**算法**\n\n想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 S​ 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏情况下，输入数据为 nn 个长度为 mm 的相同字符串，算法会进行 $S = m*n$次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 $n*minLenn$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法三：分治**\n**思路**\n\n这个算法的思路来自于LCP操作的结合律。 我们可以发现： $LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$，其中 $LCP(S_1 \\ldots S_n)$是字符串 $[S_1 \\ldots S_n]$的最长公共前缀，1 < k < n。\n\n**算法**\n\n为了应用上述的结论，我们使用分治的技巧，将原问题 $LCP(S_i\\cdots S_j)$ 分成两个子问题 $LCP(S_i\\cdots S_{mid})$ 与 $LCP(S_{mid+1}, S_j)$，其中 $mid = \\frac{i+j}{2}$ 。 我们用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 $LCP(S_i \\cdots S_j)$。 从头到尾挨个比较 lcpLeft 与 lcpRight 中的字符，直到不能再匹配为止。 计算所得的 lcpLeft 与 lcpRight 最长公共前缀就是原问题的解 $LCP(S_i\\cdots S_j)$。\n\n\n![图 2. 查找最长公共前缀的分治方法]($resource/%E5%9B%BE%202.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%E7%9A%84%E5%88%86%E6%B2%BB%E6%96%B9%E6%B3%95.png)\n\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n 个长度为 m 的相同字符串。\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和，S=m*n。\n\n时间复杂度的递推式为 $T(n)=2\\cdot T(\\frac{n}{2})+O(m)$， 化简后可知其就是 O(S)。最好情况下，算法会进行 $minLen\\cdot n$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：$O(m \\cdot log(n))$\n\n内存开支主要是递归过程中使用的栈空间所消耗的。 一共会进行 $log(n)$ 次递归，每次需要 mm 的空间存储返回结果，所以空间复杂度为 $O(m\\cdot log(n))$。\n\n**方法四：二分查找法**\n这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 L。 算法的查找区间是 $(0 \\ldots minLen)$，其中 minLen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：\n\n- S[1...mid] 不是所有串的公共前缀。 这表明对于所有的 j > i S[1..j] 也不是公共前缀，于是我们就可以丢弃后半个查找区间。\n\n- S[1...mid] 是所有串的公共前缀。 这表示对于所有的 i < j S[1..i] 都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。\n\n\n![图 3. 使用二分查找法寻找最长公共前缀]($resource/%E5%9B%BE%203.%20%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E5%AF%BB%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n个长度为 m 的相同字符串。\n\n- 时间复杂度：$O(S \\cdot log(n))$，其中 S 所有字符串中字符数量的总和。\n\n算法一共会进行 log(n) 次迭代，每次一都会进行 S = m*n 次比较，所以总时间复杂度为 $O(S \\cdot log(n))$。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**更进一步**\n让我们看一个有些不同的问题：\n\n给定一些键值字符串 $S = [S_1,S_2 \\ldots S_n]$，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。\n\n我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/) 开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：\n\n- 这是所查询的字符串 q 的一个前缀\n\n- 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀\n\n- 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长\n\n**算法**\n\n最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串 $[S_1 \\ldots S_n]$ 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。\n\n\n![图 4. 使用字典树查找最长公共前缀]($resource/%E5%9B%BE%204.%20%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n\n```Java\npublic String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // 子节点的链接数组\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // 非空子节点的数量\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    // 假设方法 containsKey、isEnd、get、put 都已经实现了\n    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n// 假设方法 insert、search、searchPrefix 都已经实现了\n// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n\n最坏情况下查询字符串 qq 的长度为 mm 并且它与数组中 nn 个字符串均相同。\n\n- 时间复杂度：预处理过程 O(S)O(S)，其中 SS 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 O(m)O(m)。\n\n- 建立字典树的时间复杂度为 O(S)O(S)。在字典树中查找字符串 qq 的最长公共前缀在最坏情况下需要 O(m)O(m) 的时间。\n\n空间复杂度：O(S)O(S)，我们只需要使用额外的 SS 空间建立字典树。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n- 使用纯遍历做法，和我的类似：\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        StringBuilder commonPrefix = new StringBuilder(\"\");\n        \n\t\t// 若只有一个字符串则返回第一个字符串\n\t\tif(strs.length == 1)\n\t\t\treturn strs[0];\n\t\t// 若为空集则返回空字符串\n\t\telse if (strs.length == 0)\n\t\t\treturn \"\";\n        \n\t\t// 获取最短字符串，以其长度参考\n\t\tint length = strs[0].length();\n\t\tfor(int i = 0; i < strs.length; i ++) {\n\t\t\tif(strs[i].length() < length)\n\t\t\t\tlength = strs[i].length();\n\t\t}\n\t\t\n\t\t// 检索字符串的字母，并逐次比较\n\t\tfor(int j = 0; j < length; j++) {\n\t\t\tfor(int k = 0; k < strs.length - 1; k++) {\n\t\t\t\tif(strs[k].charAt(j) != strs[k + 1].charAt(j))\n\t\t\t\t\treturn commonPrefix.toString();\n\t\t\t\t}\n\t\t\tcommonPrefix.append(strs[0].charAt(j));\n\t\t}\n\t\treturn commonPrefix.toString();\n\t}\n}\n\n```\n\n作者：lui-3\n链接：https://leetcode-cn.com/problems/two-sum/solution/wa-wo-zhe-ren-shi-zhen-de-xi-huan-bian-li-by-lui-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n---\n\n自己代码：有问题\n\n输入\n\n[\"dog\",\"racecar\",\"car\"]\n\n输出\n\n\"d\"\n\n预期结果\n\n\"\"\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n\n    \tif (strs.length == 0) {\n    \t\treturn \"\";\n    \t}else if (strs.length == 1) {\n    \t\treturn strs[0];\n    \t}else{\n    \t\t\n    \t\n    \t//获取数组中最短字符串的长度\n        int lowLength = strs[0].length();\n        for (int i = 1; i < strs.length; i++ ) {\n        \tif (lowLength > strs[i].length()) {\n           \t\tlowLength = strs[i].length();\n        \t}\n        }\n\n        int longFront = 0;\n        for (int i = 0; i < lowLength; i++) {\n        \tfor (int j = 0; j < strs.length - 1 ; j++ ) {\n        \t\tif (strs[j].charAt(i) != strs[j + 1].charAt(i)) {\n                    if(i == 0){\n                        longFront = 0;\n                    }else{\n                        longFront = i -1;\n                    }\n        \t\t\t\n                    break;\n        \t\t}\n        \t}\n        }\n\n        String  ans = new String(\"\");\n        \n        if(longFront == 0){\n            return \"\";\n        }else{\n        \tfor (int i = 0;i < longFront ;i++ ) {\n            \tans = ans + strs[0].charAt(i);\n            }\n        }\n        \t    \n             return ans;\n\n        }\n\n       \n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1560157536404,["GJX@GJXAIOU",[[-1,86,"5"]],[87,87],[86,86]]],[1560157537099,["GJX@GJXAIOU",[[1,86,"514"]],[86,86],[89,89]]],[1560157540603,["GJX@GJXAIOU",[[-1,85," 5"]],[87,87],[85,85]]],[1560157541829,["GJX@GJXAIOU",[[-1,86,"4"]],[87,87],[86,86]]],[1560157549668,["GJX@GJXAIOU",[[-1,85,"1.最长公"]],[88,88],[85,85]]],[1560157553482,["GJX@GJXAIOU",[[-1,84,"#共前缀\n\n\n\n## 一"]],[84,96],[84,84]]]],null,"GJX@GJXAIOU"],["44b1cada-69d5-4d0b-8f18-8c0af8534361",1560157625392,"---\ntags:  \n  - 简单  \n  -  遍历\n  - 二分法\n  - 分治\n  \nflag: green\n\ndate: '2019-6-6'\n---\n\n\n\n、题目\n\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1:**\n\n**输入:** [\"flower\",\"flow\",\"flight\"]\n**输出:** \"fl\"\n\n**示例 2:**\n\n**输入:** [\"dog\",\"racecar\",\"car\"]\n**输出:** \"\"\n**解释:** 输入不存在公共前缀。\n\n**说明:**\n\n所有输入只包含小写字母 `a-z` 。\n\n\n\n\n## 二、解答\n\n\n### 方法一：水平扫描法\n**思路**\n\n首先，我们将描述一种查找一组字符串的最长公共前缀 $LCP(S_1 \\ldots S_n)$的简单方法。 我们将会用到这样的结论：\n$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$\n\n**算法**\n\n为了运用这种思想，算法要依次遍历字符串 $[S_1 \\ldots S_n]$，当遍历到第 i个字符串的时候，找到最长公共前缀 $LCP(S_1 \\ldots S_i)$。当 $LCP(S_1 \\ldots S_i)$是一个空串的时候，算法就结束了。 否则，在执行了 nn 次遍历之后，算法就会返回最终答案 $LCP(S_1 \\ldots S_n)$\n\n![图 1. 查找最长公共前缀 （水平扫描法）]($resource/%E5%9B%BE%201.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%20%EF%BC%88%E6%B0%B4%E5%B9%B3%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%89.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return \"\";\n   String prefix = strs[0];\n   for (int i = 1; i < strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) {\n           prefix = prefix.substring(0, prefix.length() - 1);\n           if (prefix.isEmpty()) return \"\";\n       }        \n   return prefix;\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏的情况下，n个字符串都是相同的。算法会将 S1 与其他字符串 $[S_2 \\ldots S_n]$都做一次比较。这样就会进行 S 次字符比较，其中 S 是输入数据中所有字符数量。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法二：水平扫描**\n**算法**\n\n想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 S​ 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏情况下，输入数据为 nn 个长度为 mm 的相同字符串，算法会进行 $S = m*n$次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 $n*minLenn$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法三：分治**\n**思路**\n\n这个算法的思路来自于LCP操作的结合律。 我们可以发现： $LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$，其中 $LCP(S_1 \\ldots S_n)$是字符串 $[S_1 \\ldots S_n]$的最长公共前缀，1 < k < n。\n\n**算法**\n\n为了应用上述的结论，我们使用分治的技巧，将原问题 $LCP(S_i\\cdots S_j)$ 分成两个子问题 $LCP(S_i\\cdots S_{mid})$ 与 $LCP(S_{mid+1}, S_j)$，其中 $mid = \\frac{i+j}{2}$ 。 我们用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 $LCP(S_i \\cdots S_j)$。 从头到尾挨个比较 lcpLeft 与 lcpRight 中的字符，直到不能再匹配为止。 计算所得的 lcpLeft 与 lcpRight 最长公共前缀就是原问题的解 $LCP(S_i\\cdots S_j)$。\n\n\n![图 2. 查找最长公共前缀的分治方法]($resource/%E5%9B%BE%202.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%E7%9A%84%E5%88%86%E6%B2%BB%E6%96%B9%E6%B3%95.png)\n\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n 个长度为 m 的相同字符串。\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和，S=m*n。\n\n时间复杂度的递推式为 $T(n)=2\\cdot T(\\frac{n}{2})+O(m)$， 化简后可知其就是 O(S)。最好情况下，算法会进行 $minLen\\cdot n$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：$O(m \\cdot log(n))$\n\n内存开支主要是递归过程中使用的栈空间所消耗的。 一共会进行 $log(n)$ 次递归，每次需要 mm 的空间存储返回结果，所以空间复杂度为 $O(m\\cdot log(n))$。\n\n**方法四：二分查找法**\n这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 L。 算法的查找区间是 $(0 \\ldots minLen)$，其中 minLen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：\n\n- S[1...mid] 不是所有串的公共前缀。 这表明对于所有的 j > i S[1..j] 也不是公共前缀，于是我们就可以丢弃后半个查找区间。\n\n- S[1...mid] 是所有串的公共前缀。 这表示对于所有的 i < j S[1..i] 都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。\n\n\n![图 3. 使用二分查找法寻找最长公共前缀]($resource/%E5%9B%BE%203.%20%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E5%AF%BB%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n个长度为 m 的相同字符串。\n\n- 时间复杂度：$O(S \\cdot log(n))$，其中 S 所有字符串中字符数量的总和。\n\n算法一共会进行 log(n) 次迭代，每次一都会进行 S = m*n 次比较，所以总时间复杂度为 $O(S \\cdot log(n))$。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**更进一步**\n让我们看一个有些不同的问题：\n\n给定一些键值字符串 $S = [S_1,S_2 \\ldots S_n]$，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。\n\n我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/) 开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：\n\n- 这是所查询的字符串 q 的一个前缀\n\n- 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀\n\n- 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长\n\n**算法**\n\n最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串 $[S_1 \\ldots S_n]$ 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。\n\n\n![图 4. 使用字典树查找最长公共前缀]($resource/%E5%9B%BE%204.%20%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n\n```Java\npublic String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // 子节点的链接数组\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // 非空子节点的数量\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    // 假设方法 containsKey、isEnd、get、put 都已经实现了\n    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n// 假设方法 insert、search、searchPrefix 都已经实现了\n// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n\n最坏情况下查询字符串 qq 的长度为 mm 并且它与数组中 nn 个字符串均相同。\n\n- 时间复杂度：预处理过程 O(S)O(S)，其中 SS 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 O(m)O(m)。\n\n- 建立字典树的时间复杂度为 O(S)O(S)。在字典树中查找字符串 qq 的最长公共前缀在最坏情况下需要 O(m)O(m) 的时间。\n\n空间复杂度：O(S)O(S)，我们只需要使用额外的 SS 空间建立字典树。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n- 使用纯遍历做法，和我的类似：\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        StringBuilder commonPrefix = new StringBuilder(\"\");\n        \n\t\t// 若只有一个字符串则返回第一个字符串\n\t\tif(strs.length == 1)\n\t\t\treturn strs[0];\n\t\t// 若为空集则返回空字符串\n\t\telse if (strs.length == 0)\n\t\t\treturn \"\";\n        \n\t\t// 获取最短字符串，以其长度参考\n\t\tint length = strs[0].length();\n\t\tfor(int i = 0; i < strs.length; i ++) {\n\t\t\tif(strs[i].length() < length)\n\t\t\t\tlength = strs[i].length();\n\t\t}\n\t\t\n\t\t// 检索字符串的字母，并逐次比较\n\t\tfor(int j = 0; j < length; j++) {\n\t\t\tfor(int k = 0; k < strs.length - 1; k++) {\n\t\t\t\tif(strs[k].charAt(j) != strs[k + 1].charAt(j))\n\t\t\t\t\treturn commonPrefix.toString();\n\t\t\t\t}\n\t\t\tcommonPrefix.append(strs[0].charAt(j));\n\t\t}\n\t\treturn commonPrefix.toString();\n\t}\n}\n\n```\n\n作者：lui-3\n链接：https://leetcode-cn.com/problems/two-sum/solution/wa-wo-zhe-ren-shi-zhen-de-xi-huan-bian-li-by-lui-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n---\n\n自己代码：有问题\n\n输入\n\n[\"dog\",\"racecar\",\"car\"]\n\n输出\n\n\"d\"\n\n预期结果\n\n\"\"\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n\n    \tif (strs.length == 0) {\n    \t\treturn \"\";\n    \t}else if (strs.length == 1) {\n    \t\treturn strs[0];\n    \t}else{\n    \t\t\n    \t\n    \t//获取数组中最短字符串的长度\n        int lowLength = strs[0].length();\n        for (int i = 1; i < strs.length; i++ ) {\n        \tif (lowLength > strs[i].length()) {\n           \t\tlowLength = strs[i].length();\n        \t}\n        }\n\n        int longFront = 0;\n        for (int i = 0; i < lowLength; i++) {\n        \tfor (int j = 0; j < strs.length - 1 ; j++ ) {\n        \t\tif (strs[j].charAt(i) != strs[j + 1].charAt(i)) {\n                    if(i == 0){\n                        longFront = 0;\n                    }else{\n                        longFront = i -1;\n                    }\n        \t\t\t\n                    break;\n        \t\t}\n        \t}\n        }\n\n        String  ans = new String(\"\");\n        \n        if(longFront == 0){\n            return \"\";\n        }else{\n        \tfor (int i = 0;i < longFront ;i++ ) {\n            \tans = ans + strs[0].charAt(i);\n            }\n        }\n        \t    \n             return ans;\n\n        }\n\n       \n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1560157578646,["GJX@GJXAIOU",[[-1,84,"、"]],[85,85],[84,84]]],[1560157586406,["GJX@GJXAIOU",[[1,84,"## 一、"]],[84,84],[89,89]]],[1560157588457,["GJX@GJXAIOU",[[1,84,"\n"]],[83,83],[84,84]]],[1560157588587,["GJX@GJXAIOU",[[1,85,"\n"]],[84,84],[85,85]]],[1560157600211,["GJX@GJXAIOU",[[1,83,"# 14.最长公共前缀"]],[83,83],[94,94]]]],null,"GJX@GJXAIOU"],["4c92cbc5-74a3-4775-bb6e-e6ed77c0cae0",1561422677576,"---\ntags:  \n  - 简单  \n  -  遍历\n  - 二分法\n  - 分治\n  \nflag: green\n\ndate: '2019-6-6'\n---\n\n\n# 14.最长公共前缀\n\n\n## 一、题目\n\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1:**\n\n**输入:** [\"flower\",\"flow\",\"flight\"]\n**输出:** \"fl\"\n\n**示例 2:**\n\n**输入:** [\"dog\",\"racecar\",\"car\"]\n**输出:** \"\"\n**解释:** 输入不存在公共前缀。\n\n**说明:**\n\n所有输入只包含小写字母 `a-z` 。\n\n\n\n\n## 二、解答\n\n\n### 方法一：水平扫描法\n**思路**\n\n首先，我们将描述一种查找一组字符串的最长公共前缀 $LCP(S_1 \\ldots S_n)$的简单方法。 我们将会用到这样的结论：\n$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$\n\n**算法**\n\n为了运用这种思想，算法要依次遍历字符串 $[S_1 \\ldots S_n]$，当遍历到第 i个字符串的时候，找到最长公共前缀 $LCP(S_1 \\ldots S_i)$。当 $LCP(S_1 \\ldots S_i)$是一个空串的时候，算法就结束了。 否则，在执行了 nn 次遍历之后，算法就会返回最终答案 $LCP(S_1 \\ldots S_n)$\n\n![图 1. 查找最长公共前缀 （水平扫描法）]($resource/%E5%9B%BE%201.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%20%EF%BC%88%E6%B0%B4%E5%B9%B3%E6%89%AB%E6%8F%8F%E6%B3%95%EF%BC%89.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return \"\";\n   String prefix = strs[0];\n   for (int i = 1; i < strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) {\n           prefix = prefix.substring(0, prefix.length() - 1);\n           if (prefix.isEmpty()) return \"\";\n       }        \n   return prefix;\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏的情况下，n个字符串都是相同的。算法会将 S1 与其他字符串 $[S_2 \\ldots S_n]$都做一次比较。这样就会进行 S 次字符比较，其中 S 是输入数据中所有字符数量。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法二：水平扫描**\n**算法**\n\n想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 S​ 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n```\n**复杂度分析**\n\n- 时间复杂度：O(S)O(S)，S 是所有字符串中字符数量的总和。\n\n- 最坏情况下，输入数据为 nn 个长度为 mm 的相同字符串，算法会进行 $S = m*n$次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 $n*minLenn$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**算法三：分治**\n**思路**\n\n这个算法的思路来自于LCP操作的结合律。 我们可以发现： $LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$，其中 $LCP(S_1 \\ldots S_n)$是字符串 $[S_1 \\ldots S_n]$的最长公共前缀，1 < k < n。\n\n**算法**\n\n为了应用上述的结论，我们使用分治的技巧，将原问题 $LCP(S_i\\cdots S_j)$ 分成两个子问题 $LCP(S_i\\cdots S_{mid})$ 与 $LCP(S_{mid+1}, S_j)$，其中 $mid = \\frac{i+j}{2}$ 。 我们用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 $LCP(S_i \\cdots S_j)$。 从头到尾挨个比较 lcpLeft 与 lcpRight 中的字符，直到不能再匹配为止。 计算所得的 lcpLeft 与 lcpRight 最长公共前缀就是原问题的解 $LCP(S_i\\cdots S_j)$。\n\n\n![图 2. 查找最长公共前缀的分治方法]($resource/%E5%9B%BE%202.%20%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%E7%9A%84%E5%88%86%E6%B2%BB%E6%96%B9%E6%B3%95.png)\n\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n 个长度为 m 的相同字符串。\n\n- 时间复杂度：O(S)，S 是所有字符串中字符数量的总和，S=m*n。\n\n时间复杂度的递推式为 $T(n)=2\\cdot T(\\frac{n}{2})+O(m)$， 化简后可知其就是 O(S)。最好情况下，算法会进行 $minLen\\cdot n$ 次比较，其中 minLen是数组中最短字符串的长度。\n\n- 空间复杂度：$O(m \\cdot log(n))$\n\n内存开支主要是递归过程中使用的栈空间所消耗的。 一共会进行 $log(n)$ 次递归，每次需要 mm 的空间存储返回结果，所以空间复杂度为 $O(m\\cdot log(n))$。\n\n**方法四：二分查找法**\n这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 L。 算法的查找区间是 $(0 \\ldots minLen)$，其中 minLen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：\n\n- S[1...mid] 不是所有串的公共前缀。 这表明对于所有的 j > i S[1..j] 也不是公共前缀，于是我们就可以丢弃后半个查找区间。\n\n- S[1...mid] 是所有串的公共前缀。 这表示对于所有的 i < j S[1..i] 都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。\n\n\n![图 3. 使用二分查找法寻找最长公共前缀]($resource/%E5%9B%BE%203.%20%E4%BD%BF%E7%94%A8%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E5%AF%BB%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n```Java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}\n```\n**复杂度分析**\n\n最坏情况下，我们有 n个长度为 m 的相同字符串。\n\n- 时间复杂度：$O(S \\cdot log(n))$，其中 S 所有字符串中字符数量的总和。\n\n算法一共会进行 log(n) 次迭代，每次一都会进行 S = m*n 次比较，所以总时间复杂度为 $O(S \\cdot log(n))$。\n\n- 空间复杂度：O(1)，我们只需要使用常数级别的额外空间。\n\n**更进一步**\n让我们看一个有些不同的问题：\n\n给定一些键值字符串 $S = [S_1,S_2 \\ldots S_n]$，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。\n\n我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/) 开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：\n\n- 这是所查询的字符串 q 的一个前缀\n\n- 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀\n\n- 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长\n\n**算法**\n\n最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串 $[S_1 \\ldots S_n]$ 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。\n\n\n![图 4. 使用字典树查找最长公共前缀]($resource/%E5%9B%BE%204.%20%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%91%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.png)\n\n\n```Java\npublic String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // 子节点的链接数组\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // 非空子节点的数量\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    // 假设方法 containsKey、isEnd、get、put 都已经实现了\n    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n// 假设方法 insert、search、searchPrefix 都已经实现了\n// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n\n最坏情况下查询字符串 qq 的长度为 mm 并且它与数组中 nn 个字符串均相同。\n\n- 时间复杂度：预处理过程 O(S)O(S)，其中 SS 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 O(m)O(m)。\n\n- 建立字典树的时间复杂度为 O(S)O(S)。在字典树中查找字符串 qq 的最长公共前缀在最坏情况下需要 O(m)O(m) 的时间。\n\n空间复杂度：O(S)O(S)，我们只需要使用额外的 SS 空间建立字典树。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n- 使用纯遍历做法，和我的类似：\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        StringBuilder commonPrefix = new StringBuilder(\"\");\n        \n\t\t// 若只有一个字符串则返回第一个字符串\n\t\tif(strs.length == 1)\n\t\t\treturn strs[0];\n\t\t// 若为空集则返回空字符串\n\t\telse if (strs.length == 0)\n\t\t\treturn \"\";\n        \n\t\t// 获取最短字符串，以其长度参考\n\t\tint length = strs[0].length();\n\t\tfor(int i = 0; i < strs.length; i ++) {\n\t\t\tif(strs[i].length() < length)\n\t\t\t\tlength = strs[i].length();\n\t\t}\n\t\t\n\t\t// 检索字符串的字母，并逐次比较\n\t\tfor(int j = 0; j < length; j++) {\n\t\t\tfor(int k = 0; k < strs.length - 1; k++) {\n\t\t\t\tif(strs[k].charAt(j) != strs[k + 1].charAt(j))\n\t\t\t\t\treturn commonPrefix.toString();\n\t\t\t\t}\n\t\t\tcommonPrefix.append(strs[0].charAt(j));\n\t\t}\n\t\treturn commonPrefix.toString();\n\t}\n}\n\n```\n\n作者：lui-3\n链接：https://leetcode-cn.com/problems/two-sum/solution/wa-wo-zhe-ren-shi-zhen-de-xi-huan-bian-li-by-lui-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n---\n\n自己代码：有问题\n\n输入\n\n[\"dog\",\"racecar\",\"car\"]\n\n输出\n\n\"d\"\n\n预期结果\n\n\"\"\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n\n    \tif (strs.length == 0) {\n    \t\treturn \"\";\n    \t}else if (strs.length == 1) {\n    \t\treturn strs[0];\n    \t}else{\n    \t\t\n    \t\n    \t//获取数组中最短字符串的长度\n        int lowLength = strs[0].length();\n        for (int i = 1; i < strs.length; i++ ) {\n        \tif (lowLength > strs[i].length()) {\n           \t\tlowLength = strs[i].length();\n        \t}\n        }\n\n        int longFront = 0;\n        for (int i = 0; i < lowLength; i++) {\n        \tfor (int j = 0; j < strs.length - 1 ; j++ ) {\n        \t\tif (strs[j].charAt(i) != strs[j + 1].charAt(i)) {\n                    if(i == 0){\n                        longFront = 0;\n                    }else{\n                        longFront = i -1;\n                    }\n        \t\t\t\n                    break;\n        \t\t}\n        \t}\n        }\n\n        String  ans = new String(\"\");\n        \n        if(longFront == 0){\n            return \"\";\n        }else{\n        \tfor (int i = 0;i < longFront ;i++ ) {\n            \tans = ans + strs[0].charAt(i);\n            }\n        }\n        \t    \n             return ans;\n\n        }\n\n       \n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1561422631814,["GJX@GJXAIOU",[[1,59,"style: summer"]],[59,59],[72,72]]],[1561422900750,["GJX@GJXAIOU",[[1,23,"\n  "]],[20,20],[23,23]]],[1561422902031,["GJX@GJXAIOU",[[1,23,"- wa"]],[23,23],[27,27]]],[1561422903011,["GJX@GJXAIOU",[[-1,25,"wa"]],[27,27],[25,25]]],[1561422904592,["GJX@GJXAIOU",[[1,25,"完成"]],[25,25],[27,27]]],[1561422904890,["GJX@GJXAIOU",[[1,30,"\n  "]],[27,27],[30,30]]],[1561422907077,["GJX@GJXAIOU",[[1,30,"- 数组"]],[30,30],[34,34]]],[1561422915862,["GJX@GJXAIOU",[[-1,25,"完成"]],[27,27],[25,25]]],[1561422917385,["GJX@GJXAIOU",[[1,25,"参考"]],[25,25],[27,27]]]],null,"GJX@GJXAIOU"]]}