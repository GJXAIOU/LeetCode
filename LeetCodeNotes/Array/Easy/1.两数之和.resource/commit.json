{"compress":true,"commitItems":[["454e4b93-c51f-4a9f-afea-b5f4fdaf3169",1559698782693,"",[[1559698740337,["GJX@GJXAIOU",[[1,0,"# 两树之和\n\n\n\n"]],[0,0],[9,9]]],[1559698744356,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1559698744943,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1559698747331,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1559698747484,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1559698747620,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1559698747643,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1559698751589,["GJX@GJXAIOU",[[1,4,"tip:"]],[4,4],[8,8]]],[1559698753352,["GJX@GJXAIOU",[[-1,4,"tip:"]],[8,8],[4,4]]],[1559698900256,["GJX@GJXAIOU",[[-1,4,"\n"]],[4,4],[3,3]]],[1559698901628,["GJX@GJXAIOU",[[1,3,"data"]],[3,3],[7,7]]],[1559698902369,["GJX@GJXAIOU",[[-1,3,"data"]],[7,7],[3,3]]],[1559698902935,["GJX@GJXAIOU",[[1,4,"\n"]],[3,3],[4,4]]],[1559698906524,["GJX@GJXAIOU",[[1,4,"data:··"]],[4,4],[11,11]]],[1559698908387,["GJX@GJXAIOU",[[-1,9,"··"]],[11,11],[9,9]]],[1559698909027,["GJX@GJXAIOU",[[1,9,"``"]],[9,9],[11,11]]],[1559698916419,["GJX@GJXAIOU",[[1,10,"2019-6-5"]],[10,10],[18,18]]],[1559698918306,["GJX@GJXAIOU",[[1,20,"\n"]],[19,19],[20,20]]],[1559698928939,["GJX@GJXAIOU",[[1,20,"flag:green"]],[20,20],[30,30]]],[1559698929510,["GJX@GJXAIOU",[[1,31,"\n"]],[30,30],[31,31]]],[1559698934315,["GJX@GJXAIOU",[[-1,20,"flag:green"]],[20,30],[20,20]]],[1559698935805,["GJX@GJXAIOU",[[1,4,"\n"]],[4,4],[5,5]]],[1559698937075,["GJX@GJXAIOU",[[1,4,"flag:green"]],[4,4],[14,14]]],[1559698944483,["GJX@GJXAIOU",[[1,31,"tags:"]],[31,31],[36,36]]],[1559698946076,["GJX@GJXAIOU",[[1,38,"\n"]],[36,36],[37,37]]],[1559698947467,["GJX@GJXAIOU",[[1,37,"-"]],[37,37],[38,38]]],[1559698948141,["GJX@GJXAIOU",[[-1,37,"-"]],[38,38],[37,37]]],[1559698956685,["GJX@GJXAIOU",[[1,37,"  - haxi"]],[37,37],[45,45]]],[1559698957414,["GJX@GJXAIOU",[[-1,41,"haxi"]],[45,45],[41,41]]],[1559698960512,["GJX@GJXAIOU",[[1,41,"哈希表"]],[41,41],[44,44]]],[1559698972294,["GJX@GJXAIOU",[[-1,45,"\n"]],[45,45],[44,44]]],[1559698991866,["GJX@GJXAIOU",[[-1,15,"data:`2019-6-5`"]],[15,30],[15,15]]]],null,"GJX@GJXAIOU"],["419867c9-2863-4496-b0a3-e07b30e2c8d0",1559699063236,"---\nflag:green\n\ntags:\n  - 哈希表\n---\n\n\n# 两树之和\n\n\n\n",[[1559699062167,["GJX@GJXAIOU",[[-1,4,"flag:green\n\n"],[1,29,"\nflag: green"]],[45,45],[45,45]]],[1559699083088,["GJX@GJXAIOU",[[1,30,"date: '2019-06-05 09:38'\n"]],[33,33],[58,58]]],[1559699130221,["GJX@GJXAIOU",[[1,71,"\n"]],[68,68],[69,69]]],[1559699136119,["GJX@GJXAIOU",[[1,69,"## 题目"]],[69,69],[74,74]]],[1559699136538,["GJX@GJXAIOU",[[1,77,"\n"]],[74,74],[75,75]]],[1559699137988,["GJX@GJXAIOU",[[1,75,"给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:**\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[**0**] + nums[**1**] = 2 + 7 = 9\n所以返回 [**0, 1**]"]],[75,75],[291,291]]],[1559699141153,["GJX@GJXAIOU",[[1,294,"\n"]],[293,293],[294,294]]],[1559699141273,["GJX@GJXAIOU",[[1,295,"\n"]],[294,294],[295,295]]],[1559699142551,["GJX@GJXAIOU",[[-1,83," "],[1,84," "],[-1,90," "],[1,91," "],[-1,97," "],[1,98," "],[-1,123," "],[1,124," "],[-1,130," "],[1,131," "],[-1,295,"\n"],[1,296,"#"]],[295,295],[296,296]]],[1559699146414,["GJX@GJXAIOU",[[1,296,"# 解答"]],[296,296],[300,300]]],[1559699146762,["GJX@GJXAIOU",[[1,300,"\n\n"]],[300,300],[301,301]]],[1559700238476,["GJX@GJXAIOU",[[-1,64,"树"]],[65,65],[64,64]]],[1559700240743,["GJX@GJXAIOU",[[1,64,"数"]],[64,64],[65,65]]],[1559702883249,["GJX@GJXAIOU",[[1,302,"\n"]],[301,301],[302,302]]],[1559702883390,["GJX@GJXAIOU",[[1,303,"\n"]],[302,302],[303,303]]],[1559702883961,["GJX@GJXAIOU",[[1,303,"方法一：暴力法\n暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。\n\nJava\npublic int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[] { i, j };\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n复杂度分析：\n\n时间复杂度：O(n^2)O(n \n2\n )， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n \n2\n )。\n\n空间复杂度：O(1)O(1)。\n\n方法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！\n\nJava\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        map.put(nums[i], i);\n    }\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement) && map.get(complement) != i) {\n            return new int[] { i, map.get(complement) };\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n复杂度分析：\n\n时间复杂度：O(n)O(n)， 我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为 O(n)O(n)。\n\n空间复杂度：O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。\n\n方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\nJava\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n复杂度分析：\n\n时间复杂度：O(n)O(n)， 我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1) 的时间。\n\n空间复杂度：O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[303,303],[2630,2630]]],[1559702902152,["GJX@GJXAIOU",[[1,369,"```"]],[369,369],[372,372]]],[1559702902179,["GJX@GJXAIOU",[[1,372,"language\n```\n"]],[372,372],[372,380]]],[1559702905663,["GJX@GJXAIOU",[[1,717,"\n"]],[716,716],[717,717]]],[1559702906193,["GJX@GJXAIOU",[[1,717,"```"]],[717,717],[720,720]]],[1559702906218,["GJX@GJXAIOU",[[1,720,"language\n```\n"]],[720,720],[720,728]]],[1559702908908,["GJX@GJXAIOU",[[1,728,"language"]],[720,728],[728,728]]],[1559702911138,["GJX@GJXAIOU",[[-1,717,"```languagelanguage"]],[717,736],[717,717]]],[1559702912857,["GJX@GJXAIOU",[[-1,383,"`"]],[384,384],[383,383]]],[1559702914736,["GJX@GJXAIOU",[[-1,381,"``\nJava"]],[381,388],[381,381]]],[1559702917600,["GJX@GJXAIOU",[[-1,372,"language"],[1,380,"j"]],[372,380],[373,373]]],[1559702918080,["GJX@GJXAIOU",[[1,373,"ava"]],[373,373],[376,376]]]],null,"GJX@GJXAIOU"],["484d5df1-c2f7-42e3-86b8-46e5eea723d7",1559704888821,"---\ntags:\n  - 哈希表\nflag: green\ndate: '2019-06-05 09:38'\n---\n\n\n# 两数之和\n\n## 题目\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:**\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[**0**] + nums[**1**] = 2 + 7 = 9\n所以返回 [**0, 1**]\n\n\n\n## 解答\n\n\n方法一：暴力法\n暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。\n\n```java\n\npublic int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[] { i, j };\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n\n```\n\n复杂度分析：\n\n时间复杂度：O(n^2)O(n \n2\n )， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n \n2\n )。\n\n空间复杂度：O(1)O(1)。\n\n方法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！\n\nJava\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        map.put(nums[i], i);\n    }\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement) && map.get(complement) != i) {\n            return new int[] { i, map.get(complement) };\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n复杂度分析：\n\n时间复杂度：O(n)O(n)， 我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为 O(n)O(n)。\n\n空间复杂度：O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。\n\n方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\nJava\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n复杂度分析：\n\n时间复杂度：O(n)O(n)， 我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1) 的时间。\n\n空间复杂度：O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n",[[1559704839904,["GJX@GJXAIOU",[[-1,350,"target−x "]],[350,359],[350,350]]],[1559704842998,["GJX@GJXAIOU",[[-1,326,"x"]],[326,326],[325,325]]],[1559704855426,["GJX@GJXAIOU",[[-1,721,"O(n \n2\n )"]],[721,730],[721,721]]],[1559704860617,["GJX@GJXAIOU",[[-1,764,"(n)O"]],[767,767],[763,763]]],[1559704866331,["GJX@GJXAIOU",[[-1,794," )"]],[796,796],[794,794]]],[1559704866503,["GJX@GJXAIOU",[[-1,793,"\n"]],[794,794],[793,793]]],[1559704866699,["GJX@GJXAIOU",[[-1,792,"2"]],[793,793],[792,792]]],[1559704866971,["GJX@GJXAIOU",[[-1,791,"\n"]],[792,792],[791,791]]],[1559704868070,["GJX@GJXAIOU",[[-1,787,"O(n "]],[791,791],[787,787]]],[1559704871816,["GJX@GJXAIOU",[[-1,797,"(1)O"]],[800,800],[796,796]]],[1559704876407,["GJX@GJXAIOU",[[-1,942,"(1)O"]],[945,945],[941,941]]],[1559704879678,["GJX@GJXAIOU",[[-1,931,")O(n)"]],[936,936],[931,931]]],[1559704881194,["GJX@GJXAIOU",[[1,931,"0"]],[931,931],[932,932]]],[1559704882260,["GJX@GJXAIOU",[[-1,931,"0"]],[932,932],[931,931]]],[1559704883194,["GJX@GJXAIOU",[[1,931,")"]],[931,931],[932,932]]],[1559704886794,["GJX@GJXAIOU",[[-1,1011,"O(n)"]],[1011,1015],[1011,1011]]],[1559704888648,["GJX@GJXAIOU",[[-1,1049,"O(1)"]],[1049,1053],[1049,1049]]],[1559704892750,["GJX@GJXAIOU",[[-1,1140,"target−nums[i]"]],[1140,1154],[1140,1140]]],[1559704899753,["GJX@GJXAIOU",[[-1,1168,"nums[i]"]],[1161,1168],[1161,1161]]],[1559704904250,["GJX@GJXAIOU",[[1,1174,"```"]],[1174,1174],[1177,1177]]],[1559704904276,["GJX@GJXAIOU",[[1,1177,"language\n```\n"]],[1177,1177],[1177,1185]]],[1559704906979,["GJX@GJXAIOU",[[-1,1177,"language"],[1,1185,"j"]],[1177,1185],[1178,1178]]],[1559704907569,["GJX@GJXAIOU",[[1,1178,"AVA"]],[1178,1178],[1181,1181]]],[1559704908977,["GJX@GJXAIOU",[[-1,1177,"jAVA"]],[1181,1181],[1177,1177]]],[1559704910138,["GJX@GJXAIOU",[[1,1177,"jA"]],[1177,1177],[1179,1179]]],[1559704910835,["GJX@GJXAIOU",[[-1,1177,"jA"]],[1179,1179],[1177,1177]]],[1559704913225,["GJX@GJXAIOU",[[1,1177,"Java"]],[1177,1177],[1181,1181]]],[1559704916607,["GJX@GJXAIOU",[[-1,1182,"```\nJava"]],[1182,1190],[1182,1182]]],[1559704917195,["GJX@GJXAIOU",[[-1,1182,"\n"]],[1182,1182],[1181,1181]]],[1559704919786,["GJX@GJXAIOU",[[1,1652,"\n"]],[1651,1651],[1652,1652]]],[1559704921171,["GJX@GJXAIOU",[[1,1652,"```"]],[1652,1652],[1655,1655]]],[1559704925880,["GJX@GJXAIOU",[[-1,1674,"O(n)"]],[1670,1674],[1670,1670]]],[1559704928319,["GJX@GJXAIOU",[[-1,1715,"O(1)"]],[1715,1719],[1715,1715]]],[1559704930176,["GJX@GJXAIOU",[[-1,1730,"O(n)"]],[1726,1730],[1726,1726]]],[1559704931272,["GJX@GJXAIOU",[[-1,1684,"n"]],[1684,1684],[1683,1683]]],[1559704933298,["GJX@GJXAIOU",[[-1,1742,"O(n)"]],[1738,1742],[1738,1738]]],[1559704935055,["GJX@GJXAIOU",[[-1,1774,"n"]],[1774,1774],[1773,1773]]],[1559704940755,["GJX@GJXAIOU",[[1,1882,"···"]],[1882,1882],[1885,1885]]],[1559704941873,["GJX@GJXAIOU",[[-1,1882,"···"]],[1885,1885],[1882,1882]]],[1559704943209,["GJX@GJXAIOU",[[1,1882,"```"]],[1882,1882],[1885,1885]]],[1559704943234,["GJX@GJXAIOU",[[1,1885,"language\n```\n"]],[1885,1885],[1885,1893]]],[1559704944722,["GJX@GJXAIOU",[[-1,1885,"language"],[1,1893,"J"]],[1885,1893],[1886,1886]]],[1559704945282,["GJX@GJXAIOU",[[1,1886,"ava"]],[1886,1886],[1889,1889]]],[1559704948896,["GJX@GJXAIOU",[[-1,1890,"```\nJava"]],[1890,1898],[1890,1890]]],[1559704951112,["GJX@GJXAIOU",[[1,2283,"\n"]],[2282,2282],[2283,2283]]],[1559704951510,["GJX@GJXAIOU",[[1,2283,"```\nJava"]],[2283,2283],[2291,2291]]],[1559704953992,["GJX@GJXAIOU",[[-1,2287,"Java"]],[2287,2291],[2287,2287]]],[1559704956593,["GJX@GJXAIOU",[[-1,2306,"O(n)"]],[2302,2306],[2302,2302]]],[1559704959154,["GJX@GJXAIOU",[[-1,2348,"O(1)"]],[2348,2352],[2348,2348]]],[1559704960712,["GJX@GJXAIOU",[[-1,2319,"n"]],[2319,2319],[2318,2318]]],[1559704962841,["GJX@GJXAIOU",[[-1,2364,"O(n)"]],[2364,2368],[2364,2364]]],[1559704965320,["GJX@GJXAIOU",[[-1,2398,"n"]],[2398,2398],[2397,2397]]],[1559704970288,["GJX@GJXAIOU",[[1,2552,"\n"]],[2551,2551],[2552,2552]]],[1559704970432,["GJX@GJXAIOU",[[1,2553,"\n"]],[2552,2552],[2553,2553]]],[1559704970585,["GJX@GJXAIOU",[[1,2554,"\n"]],[2553,2553],[2554,2554]]],[1559704970711,["GJX@GJXAIOU",[[1,2555,"\n"]],[2554,2554],[2555,2555]]],[1559704970832,["GJX@GJXAIOU",[[1,2556,"\n"]],[2555,2555],[2556,2556]]],[1559704970968,["GJX@GJXAIOU",[[1,2557,"\n"]],[2556,2556],[2557,2557]]],[1559705004296,["GJX@GJXAIOU",[[1,2555,"反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2555,2555],[2846,2846]]],[1559705015203,["GJX@GJXAIOU",[[-1,2555,"反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2555,2846],[2555,2555]]],[1559705028066,["GJX@GJXAIOU",[[1,2554,"我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n算法\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2554,2554],[2904,2904]]],[1559705037811,["GJX@GJXAIOU",[[-1,2554,"我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n算法\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[2554,2905],[2554,2554]]],[1559705220478,["GJX@GJXAIOU",[[1,2553,"第一个：tablesgenerator\n\n优点：可以支持Latex、Excel、Markdown等多种格式转换\n\n缺点：国外网站，英文难懂，不太容易上手"]],[2553,2553],[2629,2629]]],[1559705223811,["GJX@GJXAIOU",[[-1,2553,"第一个：tablesgenerator\n\n优点：可以支持Latex、Excel、Markdown等多种格式转换\n\n缺点：国外网站，英文难懂，不太容易上手"]],[2553,2629],[2553,2553]]],[1559705325734,["GJX@GJXAIOU",[[1,2553,"反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2553,2553],[2798,2798]]],[1559705331050,["GJX@GJXAIOU",[[-1,2553,"反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n"]],[2553,2799],[2553,2553]]],[1559715397049,["GJX@GJXAIOU",[[1,368,"class Solution{\n\t"],[1,695,"}"]],[368,695],[713,713]]],[1559715407592,["GJX@GJXAIOU",[[1,733,"`"]],[733,733],[734,734]]],[1559715409903,["GJX@GJXAIOU",[[1,740,"`"]],[740,740],[741,741]]],[1559715426187,["GJX@GJXAIOU",[[1,719,"**"],[1,725,"**"]],[719,725],[719,729]]],[1559715433312,["GJX@GJXAIOU",[[1,72,"yi "]],[72,72],[75,75]]],[1559715434489,["GJX@GJXAIOU",[[-1,72,"yi "]],[75,75],[72,72]]],[1559715436073,["GJX@GJXAIOU",[[1,72,"一、"]],[72,72],[74,74]]],[1559715541962,["GJX@GJXAIOU",[[1,300,"二、"]],[300,300],[302,302]]],[1559715578520,["GJX@GJXAIOU",[[1,63,"1."]],[63,63],[65,65]]],[1559715648344,["GJX@GJXAIOU",[[1,309,"### "]],[309,309],[320,320]]],[1559715652474,["GJX@GJXAIOU",[[1,837,"### "]],[837,837],[850,850]]],[1559715655989,["GJX@GJXAIOU",[[1,1819,"### "]],[1819,1819],[1832,1832]]],[1559715680367,["GJX@GJXAIOU",[[1,879,"**"],[1,908,"**"]],[879,908],[879,912]]],[1559715747285,["GJX@GJXAIOU",[[1,2450,"\n"]],[2450,2450],[2451,2451]]],[1559715747413,["GJX@GJXAIOU",[[1,2451,"\n"]],[2451,2451],[2452,2452]]],[1559715748155,["GJX@GJXAIOU",[[1,2452,"\n"]],[2452,2452],[2453,2453]]],[1559715748324,["GJX@GJXAIOU",[[1,2453,"\n"]],[2453,2453],[2454,2454]]],[1559715748461,["GJX@GJXAIOU",[[1,2454,"\n"]],[2454,2454],[2455,2455]]],[1559715748611,["GJX@GJXAIOU",[[1,2455,"\n"]],[2455,2455],[2456,2456]]],[1559715748719,["GJX@GJXAIOU",[[1,2456,"\n"]],[2456,2456],[2457,2457]]],[1559715748866,["GJX@GJXAIOU",[[1,2457,"\n"]],[2457,2457],[2458,2458]]],[1559715925139,["GJX@GJXAIOU",[[1,2610,"\n"]],[2605,2605],[2606,2606]]],[1559715925271,["GJX@GJXAIOU",[[1,2611,"\n"]],[2606,2606],[2607,2607]]],[1559715925528,["GJX@GJXAIOU",[[1,2612,"\n"]],[2607,2607],[2608,2608]]],[1559715925663,["GJX@GJXAIOU",[[1,2613,"\n"]],[2608,2608],[2609,2609]]],[1559715927400,["GJX@GJXAIOU",[[1,2609,"kev"]],[2609,2609],[2612,2612]]],[1559715927986,["GJX@GJXAIOU",[[-1,2609,"kev"]],[2612,2612],[2609,2609]]],[1559715930770,["GJX@GJXAIOU",[[1,2609,"可以参考"]],[2609,2609],[2613,2613]]],[1559715932122,["GJX@GJXAIOU",[[1,2613,"链接："]],[2613,2613],[2616,2616]]],[1559715932679,["GJX@GJXAIOU",[[1,2621,"\n"]],[2616,2616],[2617,2617]]],[1559715933796,["GJX@GJXAIOU",[[1,2617,"[https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/](https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/)"]],[2617,2617],[2813,2813]]],[1559715935161,["GJX@GJXAIOU",[[1,2818,"\n"]],[2813,2813],[2814,2814]]],[1559715935314,["GJX@GJXAIOU",[[1,2819,"\n"]],[2814,2814],[2815,2815]]],[1559715938910,["GJX@GJXAIOU",[[1,2815,"https://leetcode-cn.com/problems/two-sum/solution/yi-bu-bu-dai-ni-cong-bao-li-dao-zui-you-jie-de-guo/"]],[2815,2815],[2916,2916]]],[1559716130409,["GJX@GJXAIOU",[[1,719," 、、"]],[719,719],[722,722]]],[1559716131067,["GJX@GJXAIOU",[[-1,720,"、、"]],[722,722],[720,720]]],[1559716135020,["GJX@GJXAIOU",[[1,720,"//或者夹着"]],[720,720],[726,726]]],[1559716136264,["GJX@GJXAIOU",[[-1,724,"夹着"]],[726,726],[724,724]]],[1559716153490,["GJX@GJXAIOU",[[1,724,"这里使用return null,因为该函数有返回值"]],[724,724],[749,749]]]],null,"GJX@GJXAIOU"],["f144bbc1-240e-4d51-8ec4-baf0dc3380d4",1560058678100,"---\ntags:\n  - 哈希表\nflag: green\ndate: '2019-06-05 09:38'\n---\n\n\n# 1.两数之和\n\n## 一、题目\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:**\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[**0**] + nums[**1**] = 2 + 7 = 9\n所以返回 [**0, 1**]\n\n\n\n## 二、解答\n\n\n### 方法一：暴力法\n暴力法很简单，遍历每个元素 x，并查找是否存在一个值与 target - x相等的目标元素。\n\n```java\n\nclass Solution{\n\tpublic int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[] { i, j };\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\"); //或者这里使用return null,因为该函数有返回值\n}\n}\n```\n\n**复杂度分析：**\n\n时间复杂度：`O(n^2)`， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。\n\n空间复杂度：O(1)。\n\n### 方法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来**检查数组中是否存在目标元素。如果存在，我们需要找出它的索引**。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！\n\n```Java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        map.put(nums[i], i);\n    }\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement) && map.get(complement) != i) {\n            return new int[] { i, map.get(complement) };\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n复杂度分析：\n\n时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。\n\n空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。\n\n### 方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\n```Java\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n\n复杂度分析：\n\n时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。\n\n空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。\n\n\n\n\n\n\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n可以参考链接：\n[https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/](https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/)\n\nhttps://leetcode-cn.com/problems/two-sum/solution/yi-bu-bu-dai-ni-cong-bao-li-dao-zui-you-jie-de-guo/\n\n\n\n\n",[[1560058666165,["GJX@GJXAIOU",[[1,10,"\n"]],[9,9],[10,10]]],[1560058670831,["GJX@GJXAIOU",[[1,10,"  - 简单"]],[10,10],[16,16]]]],null,"GJX@GJXAIOU"],["4f3b5912-f268-4525-802b-5082b2356e4e",1561422932530,"---\ntags:\n  - 简单\n  - 哈希表\nflag: green\ndate: '2019-06-05 09:38'\n---\n\n\n# 1.两数之和\n\n## 一、题目\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:**\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[**0**] + nums[**1**] = 2 + 7 = 9\n所以返回 [**0, 1**]\n\n\n\n## 二、解答\n\n\n### 方法一：暴力法\n暴力法很简单，遍历每个元素 x，并查找是否存在一个值与 target - x相等的目标元素。\n\n```java\n\nclass Solution{\n\tpublic int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[] { i, j };\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\"); //或者这里使用return null,因为该函数有返回值\n}\n}\n```\n\n**复杂度分析：**\n\n时间复杂度：`O(n^2)`， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。\n\n空间复杂度：O(1)。\n\n### 方法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来**检查数组中是否存在目标元素。如果存在，我们需要找出它的索引**。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！\n\n```Java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        map.put(nums[i], i);\n    }\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement) && map.get(complement) != i) {\n            return new int[] { i, map.get(complement) };\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n复杂度分析：\n\n时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。\n\n空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。\n\n### 方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\n```Java\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n\n复杂度分析：\n\n时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。\n\n空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。\n\n\n\n\n\n\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n可以参考链接：\n[https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/](https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/)\n\nhttps://leetcode-cn.com/problems/two-sum/solution/yi-bu-bu-dai-ni-cong-bao-li-dao-zui-you-jie-de-guo/\n\n\n\n\n",[[1561422875173,["GJX@GJXAIOU",[[1,19,"\n  "]],[16,16],[19,19]]],[1561422876737,["GJX@GJXAIOU",[[1,19,"- wanc"]],[19,19],[25,25]]],[1561422877702,["GJX@GJXAIOU",[[-1,21,"wanc"]],[25,25],[21,21]]],[1561422879304,["GJX@GJXAIOU",[[1,21,"完成"]],[21,21],[23,23]]],[1561422879814,["GJX@GJXAIOU",[[1,26,"\n  "]],[23,23],[26,26]]],[1561422881930,["GJX@GJXAIOU",[[1,26,"- 数组"]],[26,26],[30,30]]],[1561422884545,["GJX@GJXAIOU",[[1,51,"\n"]],[50,50],[51,51]]],[1561422887592,["GJX@GJXAIOU",[[1,51,"style: sumemr"]],[51,51],[64,64]]],[1561422889238,["GJX@GJXAIOU",[[-1,61,"emr"]],[64,64],[61,61]]],[1561422890911,["GJX@GJXAIOU",[[1,61,"mer"]],[61,61],[64,64]]]],null,"GJX@GJXAIOU"],["f0091e6f-f827-4680-9be0-5bb34011e972",1566826308414,"---\ntags:\n  - 简单\n  - 完成\n  - 数组\n  - 哈希表\nflag: green\nstyle: summer\ndate: '2019-06-05 09:38'\n---\n\n\n# 1.两数之和\n\n## 一、题目\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:**\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[**0**] + nums[**1**] = 2 + 7 = 9\n所以返回 [**0, 1**]\n\n\n\n## 二、解答\n\n\n### 方法一：暴力法\n暴力法很简单，遍历每个元素 x，并查找是否存在一个值与 target - x相等的目标元素。\n\n```java\n\nclass Solution{\n\tpublic int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[] { i, j };\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\"); //或者这里使用return null,因为该函数有返回值\n}\n}\n```\n\n**复杂度分析：**\n\n时间复杂度：`O(n^2)`， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。\n\n空间复杂度：O(1)。\n\n### 方法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来**检查数组中是否存在目标元素。如果存在，我们需要找出它的索引**。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！\n\n```Java\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        map.put(nums[i], i);\n    }\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement) && map.get(complement) != i) {\n            return new int[] { i, map.get(complement) };\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n复杂度分析：\n\n时间复杂度：O(n)， 我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。\n\n空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。\n\n### 方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\n```Java\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n\n复杂度分析：\n\n时间复杂度：O(n)， 我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。\n\n空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。\n\n\n\n\n\n\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n可以参考链接：\n[https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/](https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/)\n\nhttps://leetcode-cn.com/problems/two-sum/solution/yi-bu-bu-dai-ni-cong-bao-li-dao-zui-you-jie-de-guo/\n\n\n\n\n",[[1566826304572,["GJX@GJXAIOU",[[-1,2521,"\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n可以参考链接：\n[https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/](https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/)\n\nhttps://leetcode-cn.com/problems/two-sum/solution/yi-bu-bu-dai-ni-cong-bao-li-dao-zui-you-jie-de-guo/\n\n"]],[2521,2893],[2519,2519]]],[1566826304972,["GJX@GJXAIOU",[[-1,2523,"\n"]],[2519,2519],[2518,2518]]],[1566826305293,["GJX@GJXAIOU",[[-1,2522,"\n"]],[2518,2518],[2517,2517]]],[1566826305620,["GJX@GJXAIOU",[[-1,2521,"\n"]],[2517,2517],[2516,2516]]],[1566826306477,["GJX@GJXAIOU",[[-1,2520,"\n"]],[2519,2519],[2518,2518]]],[1566826306719,["GJX@GJXAIOU",[[-1,2519,"\n"]],[2518,2518],[2517,2517]]],[1566826306901,["GJX@GJXAIOU",[[-1,2518,"\n"]],[2517,2517],[2516,2516]]],[1566826307460,["GJX@GJXAIOU",[[-1,2517,"\n"]],[2517,2517],[2516,2516]]],[1566826307686,["GJX@GJXAIOU",[[-1,2516,"\n"]],[2516,2516],[2515,2515]]],[1566826314524,["GJX@GJXAIOU",[[1,1892,"**"],[1,1901,"**"]],[1892,1901],[1892,1905]]],[1566826323611,["GJX@GJXAIOU",[[-1,343,"\n"]],[343,343],[342,342]]],[1566826324172,["GJX@GJXAIOU",[[-1,342,"\n"]],[342,342],[341,341]]],[1566826489380,["GJX@GJXAIOU",[[-1,185,"\n"]],[185,185],[184,184]]],[1566826491525,["GJX@GJXAIOU",[[-1,234,"\n"]],[234,234],[233,233]]],[1566826492180,["GJX@GJXAIOU",[[-1,271,"\n"]],[271,271],[270,270]]],[1566826495637,["GJX@GJXAIOU",[[-1,282,"**"]],[284,284],[282,282]]],[1566826496486,["GJX@GJXAIOU",[[-1,279,"**"]],[281,281],[279,279]]],[1566826497459,["GJX@GJXAIOU",[[-1,314,"**"]],[316,316],[314,314]]],[1566826498558,["GJX@GJXAIOU",[[-1,318,"**"]],[320,320],[318,318]]],[1566826499669,["GJX@GJXAIOU",[[-1,292,"**"]],[294,294],[292,292]]],[1566826501406,["GJX@GJXAIOU",[[-1,289,"**"]],[291,291],[289,289]]],[1566826509752,["GJX@GJXAIOU",[[1,2503,"\n"]],[2501,2501],[2502,2502]]],[1566826509861,["GJX@GJXAIOU",[[1,2504,"\n"]],[2502,2502],[2503,2503]]],[1566826518057,["GJX@GJXAIOU",[[1,2503,"## 总结"]],[2503,2503],[2508,2508]]],[1566826518612,["GJX@GJXAIOU",[[1,2510,"\n"]],[2508,2508],[2509,2509]]],[1566826566549,["GJX@GJXAIOU",[[1,2510,"检查数组中是否存在目标元素。如果存在，我们需要找出它的索引**。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。"]],[2510,2510],[2573,2573]]],[1566826570062,["GJX@GJXAIOU",[[-1,2539,"**"]],[2541,2541],[2539,2539]]],[1566826572300,["GJX@GJXAIOU",[[1,2540,"\n"]],[2540,2540],[2541,2541]]],[1566826576831,["GJX@GJXAIOU",[[1,2541,"**"],[1,2572,"**"]],[2541,2572],[2541,2576]]],[1566826580407,["GJX@GJXAIOU",[[-1,2573,"。"]],[2574,2574],[2573,2573]]],[1566826582461,["GJX@GJXAIOU",[[1,2576,"\n"]],[2575,2575],[2576,2576]]],[1566826639189,["GJX@GJXAIOU",[[1,2577,"\n"]],[2575,2575],[2576,2576]]],[1566826639877,["GJX@GJXAIOU",[[1,2576,"第一次迭代中，我们将每个元素的值和它的索引添加到表中"]],[2576,2576],[2602,2602]]],[1566826643037,["GJX@GJXAIOU",[[1,2576,"**"],[1,2602,"**"]],[2576,2602],[2576,2606]]]],null,"GJX@GJXAIOU"]]}