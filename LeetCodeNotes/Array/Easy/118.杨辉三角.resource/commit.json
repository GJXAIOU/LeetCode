{"compress":true,"commitItems":[["d00e0bd5-822b-4d3e-9b21-612ef530f358",1562333910471,"",[[1562333856525,["GJX@GJXAIOU",[[1,0,"# 118.杨辉三角\n\n\n\n"]],[0,0],[13,13]]],[1562333864065,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1562333865283,["GJX@GJXAIOU",[[1,0,"---\ntags: \n- 简单\n- 参考\n- 数组\nflag: green\nstyle: summer\ndate: '2019-7-5'\n---"]],[0,0],[72,72]]],[1562333881572,["GJX@GJXAIOU",[[1,85,"## 一、题目"]],[85,85],[92,92]]],[1562333882257,["GJX@GJXAIOU",[[1,94,"\n"]],[92,92],[93,93]]],[1562333883617,["GJX@GJXAIOU",[[1,93,"给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/pascals-triangle\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[93,93],[341,341]]],[1562333901192,["GJX@GJXAIOU",[[1,131,"![PascalTriangleAnimated2]($resource/PascalTriangleAnimated2.gif)"]],[131,131],[197,197]]],[1562333907582,["GJX@GJXAIOU",[[-1,130,"\n"]],[130,130],[129,129]]],[1562333934499,["GJX@GJXAIOU",[[-1,227,"\n"]],[227,227],[226,226]]],[1562333937567,["GJX@GJXAIOU",[[-1,101," "],[1,102," "],[-1,118," "],[1,119," "],[-1,126," "],[1,127," "],[1,223,"- "]],[223,223],[225,225]]],[1562333970635,["GJX@GJXAIOU",[[1,408,"\n"]],[407,407],[408,408]]],[1562333970755,["GJX@GJXAIOU",[[1,409,"\n"]],[408,408],[409,409]]],[1562333972238,["GJX@GJXAIOU",[[-1,409,"\n"],[1,410,"2"]],[409,409],[410,410]]],[1562333973339,["GJX@GJXAIOU",[[-1,409,"2"],[1,410,"\n"]],[410,410],[409,409]]],[1562333976195,["GJX@GJXAIOU",[[1,409,"## er "]],[409,409],[415,415]]],[1562333976930,["GJX@GJXAIOU",[[-1,412,"er "]],[415,415],[412,412]]],[1562333979884,["GJX@GJXAIOU",[[1,412,"二、解答"]],[412,412],[416,416]]],[1562333980599,["GJX@GJXAIOU",[[1,417,"\n"]],[416,416],[417,417]]],[1562333980790,["GJX@GJXAIOU",[[1,418,"\n"]],[417,417],[418,418]]],[1562334258761,["GJX@GJXAIOU",[[-1,418,"\n"],[1,419,"-"]],[418,418],[419,419]]],[1562334263285,["GJX@GJXAIOU",[[1,419," 官方题解\n- "]],[419,419],[427,427]]],[1562334264089,["GJX@GJXAIOU",[[-1,426," "]],[427,427],[426,426]]],[1562334264234,["GJX@GJXAIOU",[[-1,425,"-"],[1,426,"\n"]],[426,426],[425,425]]],[1562334266258,["GJX@GJXAIOU",[[1,425,"方法：动态规划\n思路\n\n如果能够知道一行杨辉三角，我们就可以根据每对相邻的值轻松地计算出它的下一行。\n\n算法\n\n虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。\n\n首先，我们会生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。然后，我们会检查行数为 00 的特殊情况，否则我们会返回 [1][1]。如果 numRows > 0numRows>0，那么我们用 [1][1] 作为第一行来初始化 triangle with [1][1]，并按如下方式继续填充：\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yang-hui-san-jiao-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[425,425],[840,840]]],[1562334274370,["GJX@GJXAIOU",[[1,433,"\n"]],[433,433],[434,434]]],[1562334277037,["GJX@GJXAIOU",[[1,434,"**"],[1,436,"**"]],[434,436],[434,440]]],[1562334278778,["GJX@GJXAIOU",[[-1,441,"\n"]],[441,441],[440,440]]],[1562334281913,["GJX@GJXAIOU",[[1,481,"**"],[1,483,"**"]],[481,483],[481,487]]],[1562334283434,["GJX@GJXAIOU",[[-1,488,"\n"]],[488,488],[487,487]]],[1562334290649,["GJX@GJXAIOU",[[-1,701,"作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/yang-hui-san-jiao-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[701,847],[701,701]]],[1562334297533,["GJX@GJXAIOU",[[-1,653,"[1]"]],[656,656],[653,653]]],[1562334299540,["GJX@GJXAIOU",[[-1,616,"[1]"]],[619,619],[616,616]]],[1562334304018,["GJX@GJXAIOU",[[-1,631,"numRows>0"]],[631,640],[631,631]]],[1562334306691,["GJX@GJXAIOU",[[-1,669,"[1]"]],[672,672],[669,669]]],[1562334393550,["GJX@GJXAIOU",[[1,26,"\n"]],[25,25],[26,26]]],[1562334397439,["GJX@GJXAIOU",[[1,26,"- 动态规划"]],[26,26],[32,32]]],[1562334459581,["GJX@GJXAIOU",[[-1,604,"0"]],[605,605],[604,604]]],[1562334674019,["GJX@GJXAIOU",[[1,689,"![杨辉三角]($resource/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.gif)\n"]],[689,689],[749,749]]],[1562335067778,["GJX@GJXAIOU",[[1,750,"\n"]],[749,749],[750,750]]],[1562335070212,["GJX@GJXAIOU",[[-1,750,"\n"],[1,751,"代码"]],[750,750],[752,752]]],[1562335070524,["GJX@GJXAIOU",[[1,752,"："]],[752,752],[753,753]]],[1562335071083,["GJX@GJXAIOU",[[1,753,"\n\n"]],[753,753],[754,754]]],[1562335071748,["GJX@GJXAIOU",[[-1,754,"\n"],[1,755,"1"]],[754,754],[755,755]]],[1562335072250,["GJX@GJXAIOU",[[-1,754,"1"],[1,755,"\n"]],[755,755],[754,754]]],[1562335072398,["GJX@GJXAIOU",[[-1,754,"\n"],[1,755,"`"]],[754,754],[755,755]]],[1562335072812,["GJX@GJXAIOU",[[1,755,"``"]],[755,755],[757,757]]],[1562335072836,["GJX@GJXAIOU",[[1,757,"language\n```\n"]],[757,757],[757,765]]],[1562335073419,["GJX@GJXAIOU",[[-1,757,"language"],[1,765,"j"]],[757,765],[758,758]]],[1562335073859,["GJX@GJXAIOU",[[1,758,"ava"]],[758,758],[761,761]]],[1562335073989,["GJX@GJXAIOU",[[1,762,"\n"]],[761,761],[762,762]]],[1562335075021,["GJX@GJXAIOU",[[1,762,"public class Solution {\n\t public List<List<Integer>> generate(int numRows) {\n\t\t  List<List<Integer>> triangle = new ArrayList<List<Integer>>();\n\n\t        // 合法性判断\n\t        if (numRows == 0) {\n\t            return triangle;\n\t        }\n\n\t        // 将第一行元素值置为1\n\t        triangle.add(new ArrayList<>());\n\t        triangle.get(0).add(1);\n\n\t        for (int rowNum = 1; rowNum < numRows; rowNum++) {\n\t            List<Integer> row = new ArrayList<>();\n\t            List<Integer> prevRow = triangle.get(rowNum-1);\n\n\t            // 每行的第一个元素值总为1.\n\t            row.add(1);\n\n\t            // 除了每行第一个和最后一个的其他三角元素的值\n\t            //总是等于其上一行的左边和上一行的右边元素和 \n\t            for (int j = 1; j < rowNum; j++) {\n\t                row.add(prevRow.get(j-1) + prevRow.get(j));\n\t            }\n\n\t            //每行的最后一个元素值总为1\n\t            row.add(1);\n\n\t            triangle.add(row);\n\t        }\n\n\t        return triangle;\n\n\t\n\t    }\n}\n"]],[762,762],[1663,1663]]],[1562335078522,["GJX@GJXAIOU",[[-1,762,"public "]],[762,769],[762,762]]],[1562335353617,["GJX@GJXAIOU",[[-1,39,"green"]],[44,44],[39,39]]],[1562335356300,["GJX@GJXAIOU",[[1,39,"yell"]],[39,39],[43,43]]],[1562335356906,["GJX@GJXAIOU",[[1,43,"ow"]],[43,43],[45,45]]],[1562335378897,["GJX@GJXAIOU",[[1,1662,"\n"]],[1661,1661],[1662,1662]]],[1562335379634,["GJX@GJXAIOU",[[-1,1662,"\n"],[1,1663,"f"]],[1662,1662],[1663,1663]]],[1562335380412,["GJX@GJXAIOU",[[1,1663,"uda"]],[1663,1663],[1666,1666]]],[1562335381098,["GJX@GJXAIOU",[[-1,1663,"uda"]],[1666,1666],[1663,1663]]],[1562335381225,["GJX@GJXAIOU",[[-1,1662,"f"],[1,1663,"\n"]],[1663,1663],[1662,1662]]],[1562335381348,["GJX@GJXAIOU",[[-1,1662,"\n"]],[1662,1662],[1661,1661]]],[1562335384796,["GJX@GJXAIOU",[[1,1661,"复杂度分析"]],[1661,1661],[1666,1666]]],[1562335388585,["GJX@GJXAIOU",[[1,1661,"\n"]],[1661,1661],[1662,1662]]],[1562335395465,["GJX@GJXAIOU",[[1,1668,"\n"]],[1667,1667],[1668,1668]]],[1562335395941,["GJX@GJXAIOU",[[1,1668,"执行用时 :1 ms, 在所有 Java 提交中击败了99.54%的用户\n\n内存消耗 :35 MB, 在所有 Java 提交中击败了25.70%的用户"]],[1668,1668],[1743,1743]]],[1562335398314,["GJX@GJXAIOU",[[-1,1705,"\n"]],[1705,1705],[1704,1704]]]],null,"GJX@GJXAIOU"]]}