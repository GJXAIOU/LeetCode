{"compress":true,"commitItems":[["fc4a39f6-a7b3-4250-abc2-f5a119cc9c68",1560154382211,"",[[1560154329113,["GJX@GJXAIOU",[[1,0,"# 867.转置矩阵\n\n\n\n"]],[0,0],[13,13]]],[1560154332030,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1560154332140,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1560154332286,["GJX@GJXAIOU",[[1,2,"\n"]],[2,2],[3,3]]],[1560154333865,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1560154334000,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1560154334161,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1560154334183,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1560154345785,["GJX@GJXAIOU",[[1,4,"tags："]],[4,4],[9,9]]],[1560154346706,["GJX@GJXAIOU",[[-1,8,"："]],[9,9],[8,8]]],[1560154347601,["GJX@GJXAIOU",[[1,8,": "]],[8,8],[10,10]]],[1560154353263,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1560154353919,["GJX@GJXAIOU",[[1,11,"- "]],[11,11],[13,13]]],[1560154410514,["GJX@GJXAIOU",[[1,13,"juzhegn"]],[13,13],[20,20]]],[1560154411993,["GJX@GJXAIOU",[[-1,13,"juzhegn"]],[20,20],[13,13]]],[1560154413233,["GJX@GJXAIOU",[[1,13,"数组"]],[13,13],[15,15]]],[1560154415907,["GJX@GJXAIOU",[[-1,13,"数组"]],[15,15],[13,13]]],[1560154417610,["GJX@GJXAIOU",[[1,13,"简单"]],[13,13],[15,15]]],[1560154417977,["GJX@GJXAIOU",[[1,16,"\n"]],[15,15],[16,16]]],[1560154422257,["GJX@GJXAIOU",[[1,16,"- "]],[16,16],[18,18]]],[1560154422790,["GJX@GJXAIOU",[[1,19,"\n"]],[18,18],[19,19]]],[1560154428010,["GJX@GJXAIOU",[[1,19,"- 数组"]],[19,19],[23,23]]],[1560154428760,["GJX@GJXAIOU",[[1,24,"\n"]],[23,23],[24,24]]],[1560154429362,["GJX@GJXAIOU",[[1,25,"\n"]],[24,24],[25,25]]],[1560154433983,["GJX@GJXAIOU",[[1,25,"flag: "]],[25,25],[31,31]]],[1560154446583,["GJX@GJXAIOU",[[1,31,"green"]],[31,31],[36,36]]],[1560154447614,["GJX@GJXAIOU",[[1,37,"\n"]],[36,36],[37,37]]],[1560154448632,["GJX@GJXAIOU",[[-1,37,"\n"]],[37,37],[36,36]]],[1560154449546,["GJX@GJXAIOU",[[-1,31,"green"]],[36,36],[31,31]]],[1560154451215,["GJX@GJXAIOU",[[1,31,"yellow"]],[31,31],[37,37]]],[1560154453023,["GJX@GJXAIOU",[[-1,31,"yellow"]],[37,37],[31,31]]],[1560154453927,["GJX@GJXAIOU",[[1,31,"ge"]],[31,31],[33,33]]],[1560154455402,["GJX@GJXAIOU",[[-1,32,"e"]],[33,33],[32,32]]],[1560154456385,["GJX@GJXAIOU",[[1,32,"reen"]],[32,32],[36,36]]],[1560154456911,["GJX@GJXAIOU",[[1,37,"\n"]],[36,36],[37,37]]],[1560154468223,["GJX@GJXAIOU",[[1,37,"data: '2019-6-10'"]],[37,37],[54,54]]],[1560154478774,["GJX@GJXAIOU",[[-1,61,"\n"]],[60,60],[59,59]]],[1560154478918,["GJX@GJXAIOU",[[-1,60,"\n"]],[59,59],[58,58]]],[1560154483647,["GJX@GJXAIOU",[[1,72,"## yi "]],[72,72],[78,78]]],[1560154484759,["GJX@GJXAIOU",[[-1,75,"yi "]],[78,78],[75,75]]],[1560154488368,["GJX@GJXAIOU",[[1,75,"一、题目："]],[75,75],[80,80]]],[1560154488757,["GJX@GJXAIOU",[[1,82,"\n"]],[80,80],[81,81]]],[1560154488989,["GJX@GJXAIOU",[[1,83,"\n"]],[81,81],[82,82]]],[1560154489136,["GJX@GJXAIOU",[[1,84,"\n"]],[82,82],[83,83]]],[1560154489298,["GJX@GJXAIOU",[[1,85,"\n"]],[83,83],[84,84]]],[1560154495105,["GJX@GJXAIOU",[[1,84,"## 二、解答："]],[84,84],[92,92]]],[1560154495633,["GJX@GJXAIOU",[[1,94,"\n"]],[92,92],[93,93]]],[1560154496213,["GJX@GJXAIOU",[[1,95,"\n"]],[93,93],[94,94]]],[1560154508868,["GJX@GJXAIOU",[[1,84,"\n"]],[82,82],[83,83]]],[1560154509001,["GJX@GJXAIOU",[[1,85,"\n"]],[83,83],[84,84]]],[1560154510126,["GJX@GJXAIOU",[[1,82,"给定一个矩阵 A， 返回 A 的转置矩阵。\n\n矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。\n\n \n\n示例 1：\n\n输入：[[1,2,3],[4,5,6],[7,8,9]]\n输出：[[1,4,7],[2,5,8],[3,6,9]]\n示例 2：\n\n输入：[[1,2,3],[4,5,6]]\n输出：[[1,4],[2,5],[3,6]]\n \n\n提示：\n\n1 <= A.length <= 1000\n1 <= A[0].length <= 1000\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/transpose-matrix\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[82,82],[416,416]]],[1560154515304,["GJX@GJXAIOU",[[-1,313,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/transpose-matrix\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[313,416],[313,313]]],[1560154517194,["GJX@GJXAIOU",[[-1,88," A， 返回 A "],[1,97," A， 返回 A "],[-1,138," "],[1,139," "],[-1,257," "],[1,258," "],[1,260,"-"],[-1,278," "],[1,279," "],[-1,303," "],[1,304," "]],[260,260],[261,261]]],[1560154517342,["GJX@GJXAIOU",[[1,261," "]],[261,261],[262,262]]],[1560154519513,["GJX@GJXAIOU",[[-1,266,"\n"]],[266,266],[266,266]]],[1560154521342,["GJX@GJXAIOU",[[1,266,"- "]],[266,266],[268,268]]],[1560154523606,["GJX@GJXAIOU",[[1,290,"-0 "]],[290,290],[293,293]]],[1560154524754,["GJX@GJXAIOU",[[-1,291,"0 "]],[293,293],[291,291]]],[1560154525314,["GJX@GJXAIOU",[[1,291," "]],[291,291],[292,292]]],[1560154526561,["GJX@GJXAIOU",[[1,266,"  "]],[268,268],[270,270]]],[1560154526993,["GJX@GJXAIOU",[[1,292,"  "]],[296,296],[298,298]]],[1560154530839,["GJX@GJXAIOU",[[1,141,"- "]],[141,141],[143,143]]],[1560154533823,["GJX@GJXAIOU",[[1,208,"- "]],[208,208],[210,210]]],[1560154535946,["GJX@GJXAIOU",[[-1,149,"\n"]],[149,149],[148,148]]],[1560154541177,["GJX@GJXAIOU",[[1,207,"\n"]],[207,207],[208,208]]],[1560154542648,["GJX@GJXAIOU",[[-1,216,"\n"]],[216,216],[215,215]]],[1560156016685,["GJX@GJXAIOU",[[1,341,"\n"]],[339,339],[340,340]]],[1560156017477,["GJX@GJXAIOU",[[1,340,"```"]],[340,340],[343,343]]],[1560156017502,["GJX@GJXAIOU",[[1,343,"language\n```\n"]],[343,343],[343,351]]],[1560156018524,["GJX@GJXAIOU",[[-1,343,"language"],[1,351,"j"]],[343,351],[344,344]]],[1560156018964,["GJX@GJXAIOU",[[1,344,"ava"]],[344,344],[347,347]]],[1560156018987,["GJX@GJXAIOU",[[1,348,"\n"]],[347,347],[348,348]]],[1560156020215,["GJX@GJXAIOU",[[1,348,"class Solution {\n    public int[][] transpose(int[][] A) {\n        int N = A.length;\n        int M = A[0].length;\n        int[][] B = new int[M][N];\n        for (int i = 0; i < B.length; i++) {\n            for (int j = 0; j < B[0].length; j++ ) {\n                B[i][j] = A[j][i];\n            }\n        }\n        return B;\n    }\n}"]],[348,348],[679,679]]],[1560156024869,["GJX@GJXAIOU",[[1,686,"\n"]],[683,683],[684,684]]],[1560156024972,["GJX@GJXAIOU",[[1,687,"\n"]],[684,684],[685,685]]],[1560156032880,["GJX@GJXAIOU",[[1,685,"执行用时 :2 ms, 在所有Java提交中击败了59.00%的用户\n\n内存消耗 :48.6 MB, 在所有Java提交中击败了63.98%的用户"]],[685,685],[758,758]]],[1560156322285,["GJX@GJXAIOU",[[1,340,"\n"]],[339,339],[340,340]]],[1560156322407,["GJX@GJXAIOU",[[1,341,"\n"]],[340,340],[341,341]]],[1560156322524,["GJX@GJXAIOU",[[1,342,"\n"]],[341,341],[342,342]]],[1560156345972,["GJX@GJXAIOU",[[1,339,"- guanfa"]],[339,339],[347,347]]],[1560156347012,["GJX@GJXAIOU",[[-1,341,"guanfa"]],[347,347],[341,341]]],[1560156356133,["GJX@GJXAIOU",[[1,341,"官方解法："]],[341,341],[346,346]]],[1560156356748,["GJX@GJXAIOU",[[1,347,"- \n"]],[346,346],[349,349]]],[1560156357796,["GJX@GJXAIOU",[[-1,347,"- "]],[349,349],[347,347]]],[1560156360996,["GJX@GJXAIOU",[[1,347,"```java"]],[347,347],[354,354]]],[1560156361100,["GJX@GJXAIOU",[[1,358,"\n"]],[354,354],[355,355]]],[1560156362814,["GJX@GJXAIOU",[[1,359,"\n"]],[355,355],[356,356]]],[1560156362948,["GJX@GJXAIOU",[[1,360,"\n"]],[356,356],[357,357]]],[1560156363599,["GJX@GJXAIOU",[[1,357,"```"]],[357,357],[360,360]]],[1560156367462,["GJX@GJXAIOU",[[1,347,"\n"]],[347,347],[348,348]]],[1560156368934,["GJX@GJXAIOU",[[1,356,"方法：直接复制\n思路和算法\n\n尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 ans[c][r] = A[r][c]。\n\n让我们初始化一个新的矩阵 ans 来表示答案。然后，我们将酌情复制矩阵的每个条目。\n\nJavaPython\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n复杂度分析\n\n时间复杂度：O(R * C)O(R∗C)，其中 RR 和 CC 是给定矩阵 A 的行数和列数。\n\n空间复杂度：O(R * C)O(R∗C)，也就是答案所使用的空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhuan-zhi-ju-zhen-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[356,356],[1024,1024]]],[1560156375525,["GJX@GJXAIOU",[[-1,348,"```java"]],[348,355],[348,348]]],[1560156378168,["GJX@GJXAIOU",[[1,472,"```java"]],[472,472],[479,479]]],[1560156382322,["GJX@GJXAIOU",[[-1,1026,"```\n"]],[1025,1029],[1025,1025]]],[1560156385364,["GJX@GJXAIOU",[[1,787,"\n"]],[786,786],[787,787]]],[1560156385811,["GJX@GJXAIOU",[[1,788,"```\n"]],[787,787],[791,791]]],[1560156389331,["GJX@GJXAIOU",[[1,1033,"- zi"]],[1033,1033],[1037,1037]]],[1560156390149,["GJX@GJXAIOU",[[-1,1035,"zi"]],[1037,1037],[1035,1035]]],[1560156391348,["GJX@GJXAIOU",[[1,1035,"子饿哦"]],[1035,1035],[1038,1038]]],[1560156393384,["GJX@GJXAIOU",[[-1,1035,"子饿哦"]],[1038,1038],[1035,1035]]],[1560156396237,["GJX@GJXAIOU",[[1,1035,"自我解法："]],[1035,1035],[1040,1040]]],[1560156451462,["GJX@GJXAIOU",[[-1,339,"- 官方解法："]],[339,346],[339,339]]],[1560156451747,["GJX@GJXAIOU",[[-1,341,"\n"]],[339,339],[338,338]]],[1560156452139,["GJX@GJXAIOU",[[-1,340,"\n"]],[338,338],[337,337]]],[1560156452946,["GJX@GJXAIOU",[[-1,339,"\n"]],[339,339],[338,338]]],[1560156456140,["GJX@GJXAIOU",[[1,339,"**"],[1,346,"**"]],[339,346],[339,350]]],[1560156458100,["GJX@GJXAIOU",[[1,351,"**"],[1,356,"**"]],[351,356],[351,360]]],[1560156470221,["GJX@GJXAIOU",[[1,790,"- "]],[790,790],[792,792]]],[1560156471797,["GJX@GJXAIOU",[[1,790,"\n"]],[789,789],[790,790]]],[1560156474307,["GJX@GJXAIOU",[[-1,799,"\n"]],[799,799],[799,799]]],[1560156475021,["GJX@GJXAIOU",[[-1,847,"\n"]],[847,847],[847,847]]],[1560156483686,["GJX@GJXAIOU",[[1,18,"参考"]],[18,18],[20,20]]]],null,"GJX@GJXAIOU"],["062f3cd4-b1d3-4ad0-ad5a-3ed95def73a7",1560511244777,"---\ntags: \n- 简单\n- 参考\n- 数组\n\nflag: green\ndata: '2019-6-10'\n---\n\n# 867.转置矩阵\n\n## 一、题目：\n\n给定一个矩阵 A， 返回 A 的转置矩阵。\n\n矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。\n\n \n\n- 示例 1：\n输入：[[1,2,3],[4,5,6],[7,8,9]]\n输出：[[1,4,7],[2,5,8],[3,6,9]]\n\n- 示例 2：\n输入：[[1,2,3],[4,5,6]]\n输出：[[1,4],[2,5],[3,6]]\n \n\n- 提示：\n  - 1 <= A.length <= 1000\n  - 1 <= A[0].length <= 1000\n\n\n\n\n\n## 二、解答：\n\n**方法：直接复制**\n**思路和算法**\n\n尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 ans[c][r] = A[r][c]。\n\n让我们初始化一个新的矩阵 ans 来表示答案。然后，我们将酌情复制矩阵的每个条目。\n```java\nJavaPython\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n\n```\n\n- 复杂度分析\n时间复杂度：O(R * C)O(R∗C)，其中 RR 和 CC 是给定矩阵 A 的行数和列数。\n空间复杂度：O(R * C)O(R∗C)，也就是答案所使用的空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhuan-zhi-ju-zhen-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n- 自我解法：\n```java\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int N = A.length;\n        int M = A[0].length;\n        int[][] B = new int[M][N];\n        for (int i = 0; i < B.length; i++) {\n            for (int j = 0; j < B[0].length; j++ ) {\n                B[i][j] = A[j][i];\n            }\n        }\n        return B;\n    }\n}\n```\n\n执行用时 :2 ms, 在所有Java提交中击败了59.00%的用户\n\n内存消耗 :48.6 MB, 在所有Java提交中击败了63.98%的用户\n\n\n",[[1560511221911,["GJX@GJXAIOU",[[-1,330,"\n"]],[326,326],[325,325]]],[1560511228231,["GJX@GJXAIOU",[[-1,329,"\n"]],[328,328],[327,327]]],[1560511228407,["GJX@GJXAIOU",[[-1,328,"\n"]],[327,327],[326,326]]],[1560511231550,["GJX@GJXAIOU",[[-1,272," "]],[273,273],[272,272]]],[1560511233759,["GJX@GJXAIOU",[[-1,297," "]],[297,297],[296,296]]],[1560511235887,["GJX@GJXAIOU",[[-1,296," "]],[297,297],[296,296]]],[1560511237921,["GJX@GJXAIOU",[[1,296," "]],[296,296],[297,297]]],[1560511239522,["GJX@GJXAIOU",[[1,272," "]],[272,272],[273,273]]],[1560511240728,["GJX@GJXAIOU",[[1,298," "]],[298,298],[299,299]]]],null,"GJX@GJXAIOU"],["a5ad97bb-3f15-4868-b091-3eb7a4ea4998",1560511310750,"---\ntags: \n- 简单\n- 参考\n- 数组\n\nflag: green\ndata: '2019-6-10'\n---\n\n# 867.转置矩阵\n\n## 一、题目：\n\n给定一个矩阵 A， 返回 A 的转置矩阵。\n\n矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。\n\n \n\n- 示例 1：\n输入：[[1,2,3],[4,5,6],[7,8,9]]\n输出：[[1,4,7],[2,5,8],[3,6,9]]\n\n- 示例 2：\n输入：[[1,2,3],[4,5,6]]\n输出：[[1,4],[2,5],[3,6]]\n \n\n- 提示：\n  - 1 <= A.length <= 1000\n  - 1 <= A[0].length <= 1000\n\n\n## 二、解答：\n\n**方法：直接复制**\n**思路和算法**\n\n尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 ans[c][r] = A[r][c]。\n\n让我们初始化一个新的矩阵 ans 来表示答案。然后，我们将酌情复制矩阵的每个条目。\n```java\nJavaPython\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n\n```\n\n- 复杂度分析\n时间复杂度：O(R * C)O(R∗C)，其中 RR 和 CC 是给定矩阵 A 的行数和列数。\n空间复杂度：O(R * C)O(R∗C)，也就是答案所使用的空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhuan-zhi-ju-zhen-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n- 自我解法：\n```java\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int N = A.length;\n        int M = A[0].length;\n        int[][] B = new int[M][N];\n        for (int i = 0; i < B.length; i++) {\n            for (int j = 0; j < B[0].length; j++ ) {\n                B[i][j] = A[j][i];\n            }\n        }\n        return B;\n    }\n}\n```\n\n执行用时 :2 ms, 在所有Java提交中击败了59.00%的用户\n\n内存消耗 :48.6 MB, 在所有Java提交中击败了63.98%的用户\n\n\n",[[1560511256443,["GJX@GJXAIOU",[[-1,142,"\n"]],[142,142],[141,141]]],[1560511269692,["GJX@GJXAIOU",[[1,274,"·"]],[274,274],[275,275]]],[1560511270712,["GJX@GJXAIOU",[[-1,274,"·"]],[275,275],[274,274]]],[1560511271187,["GJX@GJXAIOU",[[1,274,"`"]],[274,274],[275,275]]],[1560511272289,["GJX@GJXAIOU",[[1,301,"`"]],[301,301],[302,302]]],[1560511273984,["GJX@GJXAIOU",[[1,296,"`"]],[296,296],[297,297]]],[1560511274776,["GJX@GJXAIOU",[[1,327,"`"]],[327,327],[328,328]]],[1560511285923,["GJX@GJXAIOU",[[1,57,"\n"]],[56,56],[57,57]]],[1560511298865,["GJX@GJXAIOU",[[1,409,"`"]],[409,409],[410,410]]],[1560511300175,["GJX@GJXAIOU",[[1,429,"`"]],[429,429],[430,430]]],[1560511303991,["GJX@GJXAIOU",[[1,342,"\n"]],[341,341],[342,342]]],[1560511305250,["GJX@GJXAIOU",[[1,335," "]],[335,335],[336,336]]]],null,"GJX@GJXAIOU"],["4697d52b-d336-4479-bca3-73c1fd46788c",1560512078264,"---\ntags: \n- 简单\n- 参考\n- 数组\n\nflag: green\ndata: '2019-6-10'\n\n---\n\n# 867.转置矩阵\n\n## 一、题目：\n\n给定一个矩阵 A， 返回 A 的转置矩阵。\n\n矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。\n\n \n- 示例 1：\n输入：[[1,2,3],[4,5,6],[7,8,9]]\n输出：[[1,4,7],[2,5,8],[3,6,9]]\n\n- 示例 2：\n输入：[[1,2,3],[4,5,6]]\n输出：[[1,4],[2,5],[3,6]]\n \n\n- 提示：\n  - `1 <= A.length <= 1000`\n  - `1 <= A[0].length <= 1000`\n\n\n##  二、解答：\n\n\n**方法：直接复制**\n**思路和算法**\n\n尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 `ans[c][r] = A[r][c]`。\n\n让我们初始化一个新的矩阵 ans 来表示答案。然后，我们将酌情复制矩阵的每个条目。\n```java\nJavaPython\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n\n```\n\n- 复杂度分析\n时间复杂度：O(R * C)O(R∗C)，其中 RR 和 CC 是给定矩阵 A 的行数和列数。\n空间复杂度：O(R * C)O(R∗C)，也就是答案所使用的空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhuan-zhi-ju-zhen-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n- 自我解法：\n```java\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int N = A.length;\n        int M = A[0].length;\n        int[][] B = new int[M][N];\n        for (int i = 0; i < B.length; i++) {\n            for (int j = 0; j < B[0].length; j++ ) {\n                B[i][j] = A[j][i];\n            }\n        }\n        return B;\n    }\n}\n```\n\n执行用时 :2 ms, 在所有Java提交中击败了59.00%的用户\n\n内存消耗 :48.6 MB, 在所有Java提交中击败了63.98%的用户\n\n\n",[[1560512032522,["GJX@GJXAIOU",[[-1,332,"##  二、解答：\n\n\n**方法：直接复制**\n**思路和算法**\n\n尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 `ans[c][r] = A[r][c]`。\n\n让我们初始化一个新的矩阵 ans 来表示答案。然后，我们将酌情复制矩阵的每个条目。\n```java\nJavaPython\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n\n```\n\n- 复杂度分析\n时间复杂度：O(R * C)O(R∗C)，其中 RR 和 CC 是给定矩阵 A 的行数和列数。\n空间复杂度：O(R * C)O(R∗C)，也就是答案所使用的空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhuan-zhi-ju-zhen-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n- 自我解法：\n```java\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int N = A.length;\n        int M = A[0].length;\n        int[][] B = new int[M][N];\n        for (int i = 0; i < B.length; i++) {\n            for (int j = 0; j < B[0].length; j++ ) {\n                B[i][j] = A[j][i];\n            }\n        }\n        return B;\n    }\n}\n```\n\n执行用时 :2 ms, 在所有Java提交中击败了59.00%的用户\n\n内存消耗 :48.6 MB, 在所有Java提交中击败了63.98%的用户\n"]],[332,1466],[332,332]]],[1560512034473,["GJX@GJXAIOU",[[1,334,"\n"]],[332,332],[333,333]]],[1560512034944,["GJX@GJXAIOU",[[1,333,"##  二、解答：\n\n\n**方法：直接复制**\n**思路和算法**\n\n尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 `ans[c][r] = A[r][c]`。\n\n让我们初始化一个新的矩阵 ans 来表示答案。然后，我们将酌情复制矩阵的每个条目。\n```java\nJavaPython\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n\n```\n\n- 复杂度分析\n时间复杂度：O(R * C)O(R∗C)，其中 RR 和 CC 是给定矩阵 A 的行数和列数。\n空间复杂度：O(R * C)O(R∗C)，也就是答案所使用的空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhuan-zhi-ju-zhen-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n- 自我解法：\n```java\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int N = A.length;\n        int M = A[0].length;\n        int[][] B = new int[M][N];\n        for (int i = 0; i < B.length; i++) {\n            for (int j = 0; j < B[0].length; j++ ) {\n                B[i][j] = A[j][i];\n            }\n        }\n        return B;\n    }\n}\n```\n\n执行用时 :2 ms, 在所有Java提交中击败了59.00%的用户\n\n内存消耗 :48.6 MB, 在所有Java提交中击败了63.98%的用户\n"]],[333,333],[1467,1467]]]],null,"GJX@GJXAIOU"],["976368c3-17a1-4188-a715-f3b50e88142f",1561358943517,"---\ntags: \n- 简单\n- 参考\n- 数组\n\nflag: green\ndata: '2019-6-10'\n\n---\n\n# 867.转置矩阵\n\n## 一、题目：\n\n给定一个矩阵 A， 返回 A 的转置矩阵。\n\n矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。\n\n \n- 示例 1：\n输入：[[1,2,3],[4,5,6],[7,8,9]]\n输出：[[1,4,7],[2,5,8],[3,6,9]]\n\n- 示例 2：\n输入：[[1,2,3],[4,5,6]]\n输出：[[1,4],[2,5],[3,6]]\n \n\n- 提示：\n  - `1 <= A.length <= 1000`\n  - `1 <= A[0].length <= 1000`\n\n\n\n##  二、解答：\n\n\n**方法：直接复制**\n**思路和算法**\n\n尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 `ans[c][r] = A[r][c]`。\n\n让我们初始化一个新的矩阵 ans 来表示答案。然后，我们将酌情复制矩阵的每个条目。\n```java\nJavaPython\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n\n```\n\n- 复杂度分析\n时间复杂度：O(R * C)O(R∗C)，其中 RR 和 CC 是给定矩阵 A 的行数和列数。\n空间复杂度：O(R * C)O(R∗C)，也就是答案所使用的空间。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zhuan-zhi-ju-zhen-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n- 自我解法：\n```java\nclass Solution {\n    public int[][] transpose(int[][] A) {\n        int N = A.length;\n        int M = A[0].length;\n        int[][] B = new int[M][N];\n        for (int i = 0; i < B.length; i++) {\n            for (int j = 0; j < B[0].length; j++ ) {\n                B[i][j] = A[j][i];\n            }\n        }\n        return B;\n    }\n}\n```\n\n执行用时 :2 ms, 在所有Java提交中击败了59.00%的用户\n\n内存消耗 :48.6 MB, 在所有Java提交中击败了63.98%的用户\n\n\n",[[1561358908615,["GJX@GJXAIOU",[[1,39,"\n"]],[38,38],[39,39]]],[1561358915562,["GJX@GJXAIOU",[[1,39,"style: summer"]],[39,39],[52,52]]]],null,"GJX@GJXAIOU"]]}