{"compress":true,"commitItems":[["e149d01f-bb61-4df3-8728-f369d2ddd71d",1560059514529,"",[[1560059507305,["GJX@GJXAIOU",[[1,0,"# 832.翻转图像\n\n\n\n"]],[0,0],[13,13]]],[1560059510922,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1560059511039,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1560059512508,["GJX@GJXAIOU",[[1,2,"--"]],[2,2],[4,4]]],[1560059514509,["GJX@GJXAIOU",[[-1,2,"--"]],[4,4],[2,2]]],[1560059516411,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1560059516571,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1560059516699,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1560059516722,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1560059524021,["GJX@GJXAIOU",[[1,4,"tage"]],[4,4],[8,8]]],[1560059524754,["GJX@GJXAIOU",[[-1,7,"e"]],[8,8],[7,7]]],[1560059526996,["GJX@GJXAIOU",[[1,7,"s: "]],[7,7],[10,10]]],[1560059527523,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1560059532603,["GJX@GJXAIOU",[[1,11,"  - jian"]],[11,11],[19,19]]],[1560059533747,["GJX@GJXAIOU",[[-1,15,"jian"]],[19,19],[15,15]]],[1560059536541,["GJX@GJXAIOU",[[1,15,"简单"]],[15,15],[17,17]]],[1560059537258,["GJX@GJXAIOU",[[1,18,"  \n"]],[17,17],[20,20]]],[1560059541958,["GJX@GJXAIOU",[[1,20,"- 完成"]],[20,20],[24,24]]],[1560059542722,["GJX@GJXAIOU",[[1,25,"  \n"]],[24,24],[27,27]]],[1560059547007,["GJX@GJXAIOU",[[1,27,"- 数组"]],[27,27],[31,31]]],[1560059548130,["GJX@GJXAIOU",[[1,32,"  \n"]],[31,31],[34,34]]],[1560059551653,["GJX@GJXAIOU",[[1,34,"-shuzu"]],[34,34],[40,40]]],[1560059553117,["GJX@GJXAIOU",[[-1,35,"shuzu"]],[40,40],[35,35]]],[1560059554936,["GJX@GJXAIOU",[[1,35," 数组"]],[35,35],[38,38]]],[1560059560991,["GJX@GJXAIOU",[[-1,36,"数组"]],[38,38],[36,36]]],[1560059566857,["GJX@GJXAIOU",[[1,37,"  \n"]],[36,36],[39,39]]],[1560059567021,["GJX@GJXAIOU",[[-1,37,"  "],[1,39,"\n"]],[39,39],[38,38]]],[1560059574213,["GJX@GJXAIOU",[[1,38,"flags: green"]],[38,38],[50,50]]],[1560059575555,["GJX@GJXAIOU",[[1,51,"\n"]],[50,50],[51,51]]],[1560059578821,["GJX@GJXAIOU",[[1,51,"data"]],[51,51],[55,55]]],[1560059580685,["GJX@GJXAIOU",[[-1,54,"a"]],[55,55],[54,54]]],[1560059582475,["GJX@GJXAIOU",[[1,54,"e "]],[54,54],[56,56]]],[1560059583014,["GJX@GJXAIOU",[[-1,55," "]],[56,56],[55,55]]],[1560059592820,["GJX@GJXAIOU",[[1,55,": '2019-6-9'"]],[55,55],[67,67]]],[1560059598034,["GJX@GJXAIOU",[[-1,42,"s"]],[43,43],[42,42]]],[1560062946872,["GJX@GJXAIOU",[[1,85,"## 一、题目"]],[85,85],[92,92]]],[1560062947256,["GJX@GJXAIOU",[[1,94,"\n"]],[92,92],[93,93]]],[1560062961053,["GJX@GJXAIOU",[[1,95,"\n"]],[94,94],[95,95]]],[1560062961183,["GJX@GJXAIOU",[[1,96,"\n"]],[95,95],[96,96]]],[1560062961327,["GJX@GJXAIOU",[[1,97,"\n"]],[96,96],[97,97]]],[1560062961445,["GJX@GJXAIOU",[[1,98,"\n"]],[97,97],[98,98]]],[1560062961565,["GJX@GJXAIOU",[[1,99,"\n"]],[98,98],[99,99]]],[1560062961688,["GJX@GJXAIOU",[[1,100,"\n"]],[99,99],[100,100]]],[1560062965642,["GJX@GJXAIOU",[[1,100,"## 二、解答"]],[100,100],[107,107]]],[1560062966173,["GJX@GJXAIOU",[[1,108,"\n"]],[107,107],[108,108]]],[1560062966301,["GJX@GJXAIOU",[[1,109,"\n"]],[108,108],[109,109]]],[1560062967854,["GJX@GJXAIOU",[[1,109,"执行用时 : 1 ms, 在Flipping an Image的Java提交中击败了99.71% 的用户 内存消耗 : 37.4 MB, 在Flipping an Image的Java提交中击败了95.91% 的用户\n\n用位运算，速度会比较快。1.对称位置上如果两数相等，要么都为1，要么都为0，交换数据没有意义，直接与1异或来翻转数据。2.对称位置上两数不等，则先交换再翻转的结果与不做任何运算时的结果是相同的。\n\n```\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int h=A.length;\n        int w=A[0].length;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w/2;j++){\n                if(A[i][j]==A[i][w-j-1]) {\n                    A[i][j]^=1;\n                    A[i][w-j-1]^=1;\n                }\n            }\n            if(w%2==1){\n                A[i][w/2]^=1;\n            }\n        }\n        return A;\n    }\n}\n```"]],[109,109],[757,757]]],[1560062983787,["GJX@GJXAIOU",[[1,93,"给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。\n\n水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。\n\n反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。\n\n示例 1:\n\n输入: [[1,1,0],[1,0,1],[0,0,0]]\n输出: [[1,0,0],[0,1,0],[1,1,1]]\n解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n示例 2:\n\n输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n说明:\n\n1 <= A.length = A[0].length <= 20\n0 <= A[i][j] <= 1\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/flipping-an-image\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[93,93],[777,777]]],[1560062989659,["GJX@GJXAIOU",[[-1,102," "],[1,103," "],[1,130,"-"],[-1,162," "],[1,163," "],[-1,172," "],[1,173," "],[-1,177," "],[1,178," "],[-1,202," 0 全部被 1 替换， 1 全部被 0 "],[1,223," 0 全部被 1 替换， 1 全部被 0 "],[-1,231," "],[1,232," "],[-1,241," "],[1,242," "],[-1,246," "],[1,247," "],[-1,666," <= "],[1,670," <= "]],[130,130],[131,131]]],[1560062989821,["GJX@GJXAIOU",[[1,131," "]],[131,131],[132,132]]],[1560062991727,["GJX@GJXAIOU",[[1,192,"- "]],[192,192],[194,194]]],[1560062995550,["GJX@GJXAIOU",[[1,263,"- "]],[263,263],[265,265]]],[1560062997933,["GJX@GJXAIOU",[[1,411,"- "]],[411,411],[413,413]]],[1560063004043,["GJX@GJXAIOU",[[1,411,"     \n"]],[410,410],[416,416]]],[1560063007789,["GJX@GJXAIOU",[[1,629,"\n"]],[629,629],[630,630]]],[1560063008462,["GJX@GJXAIOU",[[1,630,"- "]],[630,630],[632,632]]],[1560063011558,["GJX@GJXAIOU",[[1,637,"  - "]],[637,637],[641,641]]],[1560063014407,["GJX@GJXAIOU",[[1,675,"  - "]],[675,675],[679,679]]],[1560063018709,["GJX@GJXAIOU",[[-1,698,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/flipping-an-image\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[698,802],[698,698]]],[1560064415444,["GJX@GJXAIOU",[[1,1363,"\n"]],[1362,1362],[1363,1363]]],[1560064415562,["GJX@GJXAIOU",[[1,1364,"\n"]],[1363,1363],[1364,1364]]],[1560064415705,["GJX@GJXAIOU",[[1,1365,"\n"]],[1364,1364],[1365,1365]]],[1560064417420,["GJX@GJXAIOU",[[1,1366,"\n"]],[1365,1365],[1366,1366]]],[1560064417789,["GJX@GJXAIOU",[[-1,1366,"\n"],[1,1367,"-"]],[1366,1366],[1367,1367]]],[1560064422740,["GJX@GJXAIOU",[[1,1367," 个人解答：（）"]],[1367,1367],[1375,1375]]],[1560064427660,["GJX@GJXAIOU",[[1,1374,"结果有问题"]],[1374,1374],[1379,1379]]],[1560064429018,["GJX@GJXAIOU",[[1,1380,"\n- "]],[1380,1380],[1383,1383]]],[1560064429130,["GJX@GJXAIOU",[[-1,1381,"- "],[1,1383,"\n\n"]],[1383,1383],[1382,1382]]],[1560064431403,["GJX@GJXAIOU",[[-1,1382,"\n"],[1,1383,"`"]],[1382,1382],[1383,1383]]],[1560064431754,["GJX@GJXAIOU",[[1,1383,"``"]],[1383,1383],[1385,1385]]],[1560064431780,["GJX@GJXAIOU",[[1,1385,"language\n```\n"]],[1385,1385],[1385,1393]]],[1560064433051,["GJX@GJXAIOU",[[-1,1385,"language"],[1,1393,"j"]],[1385,1393],[1386,1386]]],[1560064433709,["GJX@GJXAIOU",[[1,1386,"ava"]],[1386,1386],[1389,1389]]],[1560064433941,["GJX@GJXAIOU",[[1,1390,"\n"]],[1389,1389],[1390,1390]]],[1560064434092,["GJX@GJXAIOU",[[1,1391,"\n"]],[1390,1390],[1391,1391]]],[1560064443788,["GJX@GJXAIOU",[[1,1390,"class Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        if (A.length == 0 || A.length != A[0].length) {\n        \tint [][]a = new int[A.length][A.length];\n        \treturn a;\n        }else{\n        \tfor (int i = 0; i < A.length; i++) {\n        \t\tfor (int j = 0; j < A[i].length; j++) {\n        \t\t\t//int temp = A[i][j];\n        \t\t\tA[i][j] = A[i][A[i].length - 1 - j];\n        \t\t\t//A[i][A[i].length - 1 - j] = temp;\n        \t\t}\n        \t}\n\n\n        \tfor (int i = 0; i < A.length; i++) {\n        \t\tfor (int j = 0; j < A[i].length; j++) {\n        \t\t\tswitch (A[i][j]){\n        \t\t\t\tcase 0:\n        \t\t\t\t\tA[i][j] = 1;\n        \t\t\t\t\tbreak;\n        \t\t\t\tcase 1:\n        \t\t\t\t\tA[i][j] = 0;\n        \t\t\t\t\tbreak;\n        \t\t\t}\n        \t\t\t\t\n        \t\t}\n        \t}\n        }\n        return A;\n    }\n}\n"]],[1390,1390],[2189,2189]]],[1560064496738,["GJX@GJXAIOU",[[1,714,"\n"]],[713,713],[714,714]]],[1560064501234,["GJX@GJXAIOU",[[1,714,"- fangafj"]],[714,714],[723,723]]],[1560064502475,["GJX@GJXAIOU",[[-1,716,"fangafj"]],[723,723],[716,716]]],[1560064505836,["GJX@GJXAIOU",[[1,716,"方法一："]],[716,716],[720,720]]],[1560064509363,["GJX@GJXAIOU",[[1,1373,"\n"]],[1371,1371],[1372,1372]]],[1560064514998,["GJX@GJXAIOU",[[1,1372,"- 方法二："]],[1372,1372],[1378,1378]]],[1560064515441,["GJX@GJXAIOU",[[1,1379,"- \n"]],[1378,1378],[1381,1381]]],[1560064516453,["GJX@GJXAIOU",[[-1,1379,"- "]],[1381,1381],[1379,1379]]],[1560064517850,["GJX@GJXAIOU",[[1,1379,"遍历一次即可，，比如【110】。水平翻转后，是011，那么再反转就会变为100，会发现，两边的值只要不相等，水平翻转后再反转就会和之前一样。 假如是【101】，经过两次后维【010】，所以截半判断两处的值是否相等，相等就不处理，不相等就可以让他们取反。 不过要记得判断是否是奇数个数，奇数个数，就把最中间的数取反即可。\n\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int rows=A.length;\n        int columns=A[0].length;\n        boolean flag=false;\n        if(columns%2==1)\n            flag=true;\n        for(int i=0;i<rows;i++)\n        {\n            for(int j=0;j<columns/2;j++)\n            {\n                \n                int temp1=A[i][j];\n                int temp2=A[i][columns-j-1];\n                if(temp1==temp2)\n                {\n        \n                    A[i][j]=A[i][j]==0?1:0;\n                    A[i][columns-j-1]=A[i][columns-j-1]==0?1:0;\n                }\n             \n            }\n            if(flag)\n            {\n               \n                A[i][columns/2]=A[i][columns/2]==0?1:0;\n            }\n        }\n     return A;\n    }\n}\n\n作者：aimaomidexiaomo\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-ci-bian-li-de-suan-fa-javachao-xiang-xi-ban-ben/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1379,1379],[2481,2481]]],[1560064521561,["GJX@GJXAIOU",[[1,1540,"\n"]],[1539,1539],[1540,1540]]],[1560064522356,["GJX@GJXAIOU",[[1,1540,"··"]],[1540,1540],[1542,1542]]],[1560064523359,["GJX@GJXAIOU",[[-1,1540,"··"]],[1542,1542],[1540,1540]]],[1560064524538,["GJX@GJXAIOU",[[1,1540,"```"]],[1540,1540],[1543,1543]]],[1560064528274,["GJX@GJXAIOU",[[1,2310,"```"]],[2310,2310],[2313,2313]]],[1560064533225,["GJX@GJXAIOU",[[-1,2314,"作者：aimaomidexiaomo\n链接：https://leetcode-cn.com/problems/two-sum/solution/yi-ci-bian-li-de-suan-fa-javachao-xiang-xi-ban-ben/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[2314,2488],[2314,2314]]]],null,"GJX@GJXAIOU"],["bcf4c6e5-d441-4296-989e-3bd03281a637",1561361168295,"---\ntags: \n  - 简单\n  - 完成\n  - 数组\n  - \n\nflag: green\ndate: '2019-6-9'\n---\n\n\n# 832.翻转图像\n\n## 一、题目\n给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。\n\n- 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。\n\n- 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。\n\n- 示例 1:\n\n输入: [[1,1,0],[1,0,1],[0,0,0]]\n输出: [[1,0,0],[0,1,0],[1,1,1]]\n解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n     \n- 示例 2:\n\n输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n- 说明:\n\n  - 1 <= A.length = A[0].length <= 20\n  - 0 <= A[i][j] <= 1\n\n\n\n\n\n\n\n\n## 二、解答\n\n- 方法一：\n执行用时 : 1 ms, 在Flipping an Image的Java提交中击败了99.71% 的用户 内存消耗 : 37.4 MB, 在Flipping an Image的Java提交中击败了95.91% 的用户\n\n用位运算，速度会比较快。1.对称位置上如果两数相等，要么都为1，要么都为0，交换数据没有意义，直接与1异或来翻转数据。2.对称位置上两数不等，则先交换再翻转的结果与不做任何运算时的结果是相同的。\n\n```\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int h=A.length;\n        int w=A[0].length;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w/2;j++){\n                if(A[i][j]==A[i][w-j-1]) {\n                    A[i][j]^=1;\n                    A[i][w-j-1]^=1;\n                }\n            }\n            if(w%2==1){\n                A[i][w/2]^=1;\n            }\n        }\n        return A;\n    }\n}\n```\n\n\n- 方法二：\n遍历一次即可，，比如【110】。水平翻转后，是011，那么再反转就会变为100，会发现，两边的值只要不相等，水平翻转后再反转就会和之前一样。 假如是【101】，经过两次后维【010】，所以截半判断两处的值是否相等，相等就不处理，不相等就可以让他们取反。 不过要记得判断是否是奇数个数，奇数个数，就把最中间的数取反即可。\n\n```\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int rows=A.length;\n        int columns=A[0].length;\n        boolean flag=false;\n        if(columns%2==1)\n            flag=true;\n        for(int i=0;i<rows;i++)\n        {\n            for(int j=0;j<columns/2;j++)\n            {\n                \n                int temp1=A[i][j];\n                int temp2=A[i][columns-j-1];\n                if(temp1==temp2)\n                {\n        \n                    A[i][j]=A[i][j]==0?1:0;\n                    A[i][columns-j-1]=A[i][columns-j-1]==0?1:0;\n                }\n             \n            }\n            if(flag)\n            {\n               \n                A[i][columns/2]=A[i][columns/2]==0?1:0;\n            }\n        }\n     return A;\n    }\n}\n```\n\n\n- 个人解答：（结果有问题）\n\n```java\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        if (A.length == 0 || A.length != A[0].length) {\n        \tint [][]a = new int[A.length][A.length];\n        \treturn a;\n        }else{\n        \tfor (int i = 0; i < A.length; i++) {\n        \t\tfor (int j = 0; j < A[i].length; j++) {\n        \t\t\t//int temp = A[i][j];\n        \t\t\tA[i][j] = A[i][A[i].length - 1 - j];\n        \t\t\t//A[i][A[i].length - 1 - j] = temp;\n        \t\t}\n        \t}\n\n\n        \tfor (int i = 0; i < A.length; i++) {\n        \t\tfor (int j = 0; j < A[i].length; j++) {\n        \t\t\tswitch (A[i][j]){\n        \t\t\t\tcase 0:\n        \t\t\t\t\tA[i][j] = 1;\n        \t\t\t\t\tbreak;\n        \t\t\t\tcase 1:\n        \t\t\t\t\tA[i][j] = 0;\n        \t\t\t\t\tbreak;\n        \t\t\t}\n        \t\t\t\t\n        \t\t}\n        \t}\n        }\n        return A;\n    }\n}\n\n\n```\n",[[1561361141709,["GJX@GJXAIOU",[[1,50,"\n"]],[49,49],[50,50]]],[1561361142390,["GJX@GJXAIOU",[[1,50,"sy"]],[50,50],[52,52]]],[1561361142903,["GJX@GJXAIOU",[[-1,51,"y"]],[52,52],[51,51]]],[1561361145286,["GJX@GJXAIOU",[[1,51,"tyle:summer"]],[51,51],[62,62]]]],null,"GJX@GJXAIOU"],["2a58d633-1375-478d-9b0f-a7a6e3211df8",1561423016403,"---\ntags: \n  - 简单\n  - 完成\n  - 数组\n  - \n\nflag: green\nstyle:summer\ndate: '2019-6-9'\n---\n\n\n# 832.翻转图像\n\n## 一、题目\n给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。\n\n- 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。\n\n- 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。\n\n- 示例 1:\n\n输入: [[1,1,0],[1,0,1],[0,0,0]]\n输出: [[1,0,0],[0,1,0],[1,1,1]]\n解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n     \n- 示例 2:\n\n输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n- 说明:\n\n  - 1 <= A.length = A[0].length <= 20\n  - 0 <= A[i][j] <= 1\n\n\n\n\n\n\n\n\n## 二、解答\n\n- 方法一：\n执行用时 : 1 ms, 在Flipping an Image的Java提交中击败了99.71% 的用户 内存消耗 : 37.4 MB, 在Flipping an Image的Java提交中击败了95.91% 的用户\n\n用位运算，速度会比较快。1.对称位置上如果两数相等，要么都为1，要么都为0，交换数据没有意义，直接与1异或来翻转数据。2.对称位置上两数不等，则先交换再翻转的结果与不做任何运算时的结果是相同的。\n\n```\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int h=A.length;\n        int w=A[0].length;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w/2;j++){\n                if(A[i][j]==A[i][w-j-1]) {\n                    A[i][j]^=1;\n                    A[i][w-j-1]^=1;\n                }\n            }\n            if(w%2==1){\n                A[i][w/2]^=1;\n            }\n        }\n        return A;\n    }\n}\n```\n\n\n- 方法二：\n遍历一次即可，，比如【110】。水平翻转后，是011，那么再反转就会变为100，会发现，两边的值只要不相等，水平翻转后再反转就会和之前一样。 假如是【101】，经过两次后维【010】，所以截半判断两处的值是否相等，相等就不处理，不相等就可以让他们取反。 不过要记得判断是否是奇数个数，奇数个数，就把最中间的数取反即可。\n\n```\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int rows=A.length;\n        int columns=A[0].length;\n        boolean flag=false;\n        if(columns%2==1)\n            flag=true;\n        for(int i=0;i<rows;i++)\n        {\n            for(int j=0;j<columns/2;j++)\n            {\n                \n                int temp1=A[i][j];\n                int temp2=A[i][columns-j-1];\n                if(temp1==temp2)\n                {\n        \n                    A[i][j]=A[i][j]==0?1:0;\n                    A[i][columns-j-1]=A[i][columns-j-1]==0?1:0;\n                }\n             \n            }\n            if(flag)\n            {\n               \n                A[i][columns/2]=A[i][columns/2]==0?1:0;\n            }\n        }\n     return A;\n    }\n}\n```\n\n\n- 个人解答：（结果有问题）\n\n```java\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        if (A.length == 0 || A.length != A[0].length) {\n        \tint [][]a = new int[A.length][A.length];\n        \treturn a;\n        }else{\n        \tfor (int i = 0; i < A.length; i++) {\n        \t\tfor (int j = 0; j < A[i].length; j++) {\n        \t\t\t//int temp = A[i][j];\n        \t\t\tA[i][j] = A[i][A[i].length - 1 - j];\n        \t\t\t//A[i][A[i].length - 1 - j] = temp;\n        \t\t}\n        \t}\n\n\n        \tfor (int i = 0; i < A.length; i++) {\n        \t\tfor (int j = 0; j < A[i].length; j++) {\n        \t\t\tswitch (A[i][j]){\n        \t\t\t\tcase 0:\n        \t\t\t\t\tA[i][j] = 1;\n        \t\t\t\t\tbreak;\n        \t\t\t\tcase 1:\n        \t\t\t\t\tA[i][j] = 0;\n        \t\t\t\t\tbreak;\n        \t\t\t}\n        \t\t\t\t\n        \t\t}\n        \t}\n        }\n        return A;\n    }\n}\n\n\n```\n",[[1561422961967,["GJX@GJXAIOU",[[1,56," "]],[56,56],[57,57]]],[1561422965607,["GJX@GJXAIOU",[[-1,32,"  - "]],[36,36],[32,32]]],[1561422965910,["GJX@GJXAIOU",[[-1,33,"\n"]],[32,32],[31,31]]]],null,"GJX@GJXAIOU"]]}