{"compress":true,"commitItems":[["5dd5896f-328f-4cad-a8ae-65b6bcd92252",1559716263613,"---\n\ntags:\n\n  - \n\nflag: green\n\ndate: '2019-06-05 09:38'\n\n---\n\n\n\n\n\n# 1.两数之和\n\n\n\n\n\n## 一、题目\n\n\n\n\n\n\n\n## 二、解答\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1559716217002,["GJX@GJXAIOU",[[1,88,"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n\n示例 1:\n\n输入: 123\n输出: 321\n 示例 2:\n\n输入: -123\n输出: -321\n示例 3:\n\n输入: 120\n输出: 21\n注意:\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。"]],[88,88],[277,277]]],[1559716221460,["GJX@GJXAIOU",[[-1,56,"\n"]],[56,56],[55,55]]],[1559716222750,["GJX@GJXAIOU",[[-1,30,"\n"]],[30,30],[29,29]]],[1559716224253,["GJX@GJXAIOU",[[-1,17,"\n"]],[17,17],[16,16]]],[1559716225945,["GJX@GJXAIOU",[[-1,4,"\n"]],[4,4],[3,3]]],[1559716230809,["GJX@GJXAIOU",[[-1,65,".两数之和"],[1,70,"2"]],[65,70],[66,66]]],[1559716230959,["GJX@GJXAIOU",[[1,66,"."]],[66,66],[67,67]]],[1559716232393,["GJX@GJXAIOU",[[-1,64,"12."]],[67,67],[64,64]]],[1559716237865,["GJX@GJXAIOU",[[1,64,"2.整数倒置"]],[64,64],[70,70]]],[1559716242657,["GJX@GJXAIOU",[[-1,68,"倒置"]],[70,70],[68,68]]],[1559716245481,["GJX@GJXAIOU",[[1,68,"反转"]],[68,68],[70,70]]],[1559716267509,["GJX@GJXAIOU",[[-1,46,"09:38"]],[46,51],[46,46]]],[1559716331538,["GJX@GJXAIOU",[[1,108,"**"],[1,114,"**"]],[108,114],[108,118]]],[1559716337911,["GJX@GJXAIOU",[[1,89,"**"],[1,94,"**"]],[89,94],[89,98]]],[1559719149889,["GJX@GJXAIOU",[[-1,237,"31"]],[239,239],[237,237]]],[1559719155203,["GJX@GJXAIOU",[[1,237,"^31"]],[237,237],[240,240]]],[1559719157597,["GJX@GJXAIOU",[[-1,244,"31"]],[246,246],[244,244]]],[1559719166138,["GJX@GJXAIOU",[[1,244,"^31"]],[244,244],[247,247]]],[1559719229631,["GJX@GJXAIOU",[[1,294,"方法：弹出和推入数字 & 溢出前进行检查\n思路\n\n我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n算法\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 \\text{rev}rev 的后面。最后，\\text{rev}rev 将与 xx 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n\n//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n但是，这种方法很危险，因为当 \\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 时会导致溢出。\n\n幸运的是，事先检查这个语句是否会导致溢出很容易。\n\n为了便于解释，我们假设 \\text{rev}rev 是正数。\n\n如果 temp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 导致溢出，那么一定有 \\text{rev} \\geq \\frac{INTMAX}{10}rev≥ \n10\nINTMAX\n​\t\n 。\n如果 \\text{rev} > \\frac{INTMAX}{10}rev> \n10\nINTMAX\n​\t\n ，那么 temp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 一定会溢出。\n如果 \\text{rev} == \\frac{INTMAX}{10}rev== \n10\nINTMAX\n​\t\n ，那么只要 \\text{pop} > 7pop>7，temp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 就会溢出。\n当 \\text{rev}rev 为负时可以应用类似的逻辑。\n\nC++Java\nclass Solution {\n    public int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;\n            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n}\n复杂度分析\n\n时间复杂度：O(\\log(x))O(log(x))，xx 中大约有 \\log_{10}(x)log \n10\n​\t\n (x) 位数字。\n空间复杂度：O(1)O(1)。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[294,294],[1841,1841]]],[1559719240079,["GJX@GJXAIOU",[[1,1603,"\n"]],[1602,1602],[1603,1603]]],[1559719241045,["GJX@GJXAIOU",[[1,1603,"··"]],[1603,1603],[1605,1605]]],[1559719242196,["GJX@GJXAIOU",[[-1,1603,"··"]],[1605,1605],[1603,1603]]],[1559719243636,["GJX@GJXAIOU",[[1,1603,"```"]],[1603,1603],[1606,1606]]],[1559719243662,["GJX@GJXAIOU",[[1,1606,"language\n```\n"]],[1606,1606],[1606,1614]]],[1559719245364,["GJX@GJXAIOU",[[-1,1606,"language"],[1,1614,"j"]],[1606,1614],[1607,1607]]],[1559719245739,["GJX@GJXAIOU",[[1,1607,"ava"]],[1607,1607],[1610,1610]]],[1559719248436,["GJX@GJXAIOU",[[-1,1603,"```java"]],[1603,1610],[1603,1603]]],[1559719251768,["GJX@GJXAIOU",[[-1,1176,"C++J"],[1,1180,"```j"]],[1176,1183],[1183,1183]]],[1559719289803,["GJX@GJXAIOU",[[1,315,"**"],[1,317,"**"]],[315,317],[315,321]]],[1559719292169,["GJX@GJXAIOU",[[1,294,"**"],[1,296,"**"]],[294,296],[294,300]]],[1559719298610,["GJX@GJXAIOU",[[1,382,"**"],[1,384,"**"]],[382,384],[382,388]]],[1559719326971,["GJX@GJXAIOU",[[-1,423,"x"]],[423,423],[422,422]]],[1559719336162,["GJX@GJXAIOU",[[-1,441,"\\text{rev}"]],[441,451],[441,441]]],[1559719340915,["GJX@GJXAIOU",[[-1,452,"\\text{rev}"]],[452,462],[452,452]]],[1559719343288,["GJX@GJXAIOU",[[-1,460,"x"]],[460,460],[459,459]]],[1559719357059,["GJX@GJXAIOU",[[1,511,"```java"]],[511,511],[518,518]]],[1559719359812,["GJX@GJXAIOU",[[1,559,"```"]],[559,559],[562,562]]],[1559719367482,["GJX@GJXAIOU",[[-1,559,"```"]],[559,562],[559,559]]],[1559719368904,["GJX@GJXAIOU",[[1,613,"\n"]],[612,612],[613,613]]],[1559719369344,["GJX@GJXAIOU",[[1,613,"```"]],[613,613],[616,616]]],[1559719454109,["GJX@GJXAIOU",[[-1,632,"\\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}"]],[632,678],[632,632]]],[1559719456358,["GJX@GJXAIOU",[[1,632,"·"]],[632,632],[633,633]]],[1559719458077,["GJX@GJXAIOU",[[-1,632,"·"]],[633,633],[632,632]]],[1559719460800,["GJX@GJXAIOU",[[-1,640,"⋅"]],[641,641],[640,640]]],[1559719461237,["GJX@GJXAIOU",[[1,640,"*"]],[640,640],[641,641]]],[1559719463621,["GJX@GJXAIOU",[[1,632,"·"]],[632,632],[633,633]]],[1559719465533,["GJX@GJXAIOU",[[-1,632,"·"]],[633,633],[632,632]]],[1559719467044,["GJX@GJXAIOU",[[1,632,"`"]],[632,632],[633,633]]],[1559719469516,["GJX@GJXAIOU",[[1,648,"`"]],[648,648],[649,649]]],[1559719477617,["GJX@GJXAIOU",[[-1,697,"\\text{rev}"]],[697,707],[697,697]]],[1559719501436,["GJX@GJXAIOU",[[1,710,"$"]],[710,710],[711,711]]],[1559719505963,["GJX@GJXAIOU",[[1,765,"$"]],[765,765],[766,766]]],[1559719524238,["GJX@GJXAIOU",[[1,777,"$"]],[777,777],[778,778]]],[1559719529052,["GJX@GJXAIOU",[[1,817,"$"]],[817,817],[818,818]]],[1559719531248,["GJX@GJXAIOU",[[-1,816," "]],[817,817],[816,816]]],[1559719534894,["GJX@GJXAIOU",[[-1,778," "]],[779,779],[778,778]]],[1559719549019,["GJX@GJXAIOU",[[-1,811,"rev≥"]],[815,815],[811,811]]],[1559719552925,["GJX@GJXAIOU",[[-1,816,"INTMAX"]],[816,822],[816,816]]],[1559719554212,["GJX@GJXAIOU",[[-1,816,"\n"]],[816,816],[815,815]]],[1559719554815,["GJX@GJXAIOU",[[-1,813,"10"]],[815,815],[813,813]]],[1559719555190,["GJX@GJXAIOU",[[-1,813,"\n"]],[813,813],[812,812]]],[1559719566494,["GJX@GJXAIOU",[[-1,813,"​\t\n 。"]],[813,818],[813,813]]],[1559719570179,["GJX@GJXAIOU",[[1,707,"- "]],[707,707],[709,709]]],[1559719572326,["GJX@GJXAIOU",[[1,816,"- "]],[816,816],[818,818]]],[1559719583244,["GJX@GJXAIOU",[[1,821,"$"]],[821,821],[822,822]]],[1559719586636,["GJX@GJXAIOU",[[1,852,"$"]],[852,852],[853,853]]],[1559719590048,["GJX@GJXAIOU",[[-1,853,"rev> \n10\nINTMAX"]],[853,868],[853,853]]],[1559719595098,["GJX@GJXAIOU",[[-1,857," "]],[858,858],[857,857]]],[1559719595438,["GJX@GJXAIOU",[[-1,856,"\n"]],[857,857],[856,856]]],[1559719596332,["GJX@GJXAIOU",[[-1,854,"​\t"]],[856,856],[854,854]]],[1559719596884,["GJX@GJXAIOU",[[-1,853,"\n"]],[854,854],[853,853]]],[1559719601163,["GJX@GJXAIOU",[[1,857,"$"]],[857,857],[858,858]]],[1559719608492,["GJX@GJXAIOU",[[1,897,"$"]],[897,897],[898,898]]],[1559719613905,["GJX@GJXAIOU",[[-1,898,"temp=rev⋅10+pop"]],[898,913],[898,898]]],[1559719623452,["GJX@GJXAIOU",[[1,909,"$"]],[909,909],[910,910]]],[1559719625991,["GJX@GJXAIOU",[[1,906,"- "]],[906,906],[908,908]]],[1559719639631,["GJX@GJXAIOU",[[-1,943,"rev== \n10\nINTMAX\n​\t"]],[943,962],[943,943]]],[1559719641484,["GJX@GJXAIOU",[[1,943,"$"]],[943,943],[944,944]]],[1559719645405,["GJX@GJXAIOU",[[-1,944,"\n"]],[945,945],[944,944]]],[1559719649180,["GJX@GJXAIOU",[[1,951,"$"]],[951,951],[952,952]]],[1559719651842,["GJX@GJXAIOU",[[1,966,"$"]],[966,966],[967,967]]],[1559719661054,["GJX@GJXAIOU",[[-1,966,"$pop>7"]],[967,972],[966,966]]],[1559719665969,["GJX@GJXAIOU",[[1,1006,"$"]],[1006,1006],[1007,1007]]],[1559719670679,["GJX@GJXAIOU",[[-1,1007,"temp=rev⋅10+pop"]],[1007,1022],[1007,1007]]],[1559719676743,["GJX@GJXAIOU",[[-1,1015," \\text{rev}"]],[1015,1026],[1015,1015]]],[1559719696003,["GJX@GJXAIOU",[[1,1474,"#### "]],[1508,1508],[1529,1529]]],[1559719699494,["GJX@GJXAIOU",[[-1,1474,"#### "]],[1529,1529],[1508,1508]]],[1559719703620,["GJX@GJXAIOU",[[1,1508,"$"]],[1508,1508],[1509,1509]]],[1559719712969,["GJX@GJXAIOU",[[-1,1521,"log \n10\n​\t\n(x) "]],[1521,1536],[1521,1521]]],[1559719715101,["GJX@GJXAIOU",[[1,1521,"$"]],[1521,1521],[1522,1522]]],[1559719721652,["GJX@GJXAIOU",[[1,1480,"$"]],[1480,1480],[1481,1481]]],[1559719724668,["GJX@GJXAIOU",[[1,1491,"$"]],[1491,1491],[1492,1492]]],[1559719728754,["GJX@GJXAIOU",[[-1,1492,"O(log(x))"]],[1492,1501],[1492,1492]]],[1559719729906,["GJX@GJXAIOU",[[-1,1494,"x"]],[1495,1495],[1494,1494]]],[1559719732132,["GJX@GJXAIOU",[[-1,1529,"O(1)"]],[1529,1533],[1529,1529]]],[1559719827557,[null,[[-1,1514," "]],[1514,1514],[1514,1514]]],[1559719827557,[null,[[1,1514," "]],[1514,1514],[1514,1514]]],[1559719783067,["GJX@GJXAIOU",[[-1,717," = \\text{rev} \\cdot 10 + \\text{pop}temp"]],[713,752],[713,713]]],[1559719788842,["GJX@GJXAIOU",[[1,717," = \\text{rev} \\cdot 10 + \\text{pop}temp"]],[713,713],[752,752]]],[1559719800489,["GJX@GJXAIOU",[[-1,752,"temp=rev⋅10+pop"]],[752,767],[752,752]]],[1559720307598,[null,[[-1,1499," "]],[1499,1499],[1499,1499]]],[1559720307598,[null,[[1,1499," "]],[1499,1499],[1499,1499]]],[1559720271438,["GJX@GJXAIOU",[[1,234,"$"]],[234,234],[235,235]]],[1559720274612,["GJX@GJXAIOU",[[1,253,"$"]],[253,253],[254,254]]],[1559720281949,["GJX@GJXAIOU",[[1,241,")"]],[241,241],[242,242]]],[1559720285477,["GJX@GJXAIOU",[[1,239,"("]],[239,239],[240,240]]],[1559720295829,["GJX@GJXAIOU",[[1,235,"$"]],[234,234],[235,235]]],[1559720301125,["GJX@GJXAIOU",[[-1,256,"$"]],[257,257],[256,256]]],[1559720306314,["GJX@GJXAIOU",[[-1,235,"$"]],[235,235],[234,234]]],[1559720367612,[null,[[-1,1502," "]],[1502,1502],[1502,1502]]],[1559720367612,[null,[[1,1502," "]],[1502,1502],[1502,1502]]],[1559720312914,["GJX@GJXAIOU",[[1,255,"$"]],[255,255],[256,256]]],[1559720322492,["GJX@GJXAIOU",[[-1,239,"("]],[240,240],[239,239]]],[1559720324136,["GJX@GJXAIOU",[[-1,241,")"]],[242,242],[241,241]]],[1559720357212,["GJX@GJXAIOU",[[1,235,"\\"]],[235,235],[236,236]]],[1559720359374,["GJX@GJXAIOU",[[-1,235,"\\"]],[236,236],[235,235]]],[1559720361660,["GJX@GJXAIOU",[[1,236,"\\"]],[236,236],[237,237]]],[1559720362838,["GJX@GJXAIOU",[[-1,236,"\\"]],[237,237],[236,236]]],[1559720364700,["GJX@GJXAIOU",[[1,239,"\\"]],[239,239],[240,240]]],[1559720365882,["GJX@GJXAIOU",[[-1,239,"\\"]],[240,240],[239,239]]],[1559720427616,[null,[[-1,1501," "]],[1501,1501],[1501,1501]]],[1559720427616,[null,[[1,1501," "]],[1501,1501],[1501,1501]]],[1559720369013,["GJX@GJXAIOU",[[1,240,"\\"]],[240,240],[241,241]]],[1559720369618,["GJX@GJXAIOU",[[-1,240,"\\"]],[241,241],[240,240]]],[1559720374668,["GJX@GJXAIOU",[[1,235,"\\text"]],[235,235],[240,240]]],[1559720379806,["GJX@GJXAIOU",[[-1,235,"\\text"]],[240,240],[235,235]]],[1559720847679,[null,[[-1,1501," "]],[1501,1501],[1501,1501]]],[1559720847679,[null,[[1,1501," "]],[1501,1501],[1501,1501]]],[1559720790368,["GJX@GJXAIOU",[[1,1001,"- \n"]],[1000,1000],[1003,1003]]],[1559720790503,["GJX@GJXAIOU",[[-1,1001,"- "]],[1003,1003],[1002,1002]]],[1559720790635,["GJX@GJXAIOU",[[1,1002,"\n"]],[1002,1002],[1003,1003]]],[1559720793843,["GJX@GJXAIOU",[[1,1002,"()"]],[1002,1002],[1004,1004]]],[1559720795630,["GJX@GJXAIOU",[[1,1003,"zehh"]],[1003,1003],[1007,1007]]],[1559720798911,["GJX@GJXAIOU",[[-1,1002,"(zehh)"]],[1007,1007],[1002,1002]]],[1559720800888,["GJX@GJXAIOU",[[1,1002,"****"]],[1002,1002],[1004,1004]]],[1559720818229,["GJX@GJXAIOU",[[1,1004,"这里pop为什么大于7:"]],[1004,1004],[1016,1016]]],[1559720822178,["GJX@GJXAIOU",[[1,1019,"\n"]],[1018,1018],[1019,1019]]],[1559720823521,["GJX@GJXAIOU",[[1,1019,"2^31-1=2147483647,-2^31=-2147483648"]],[1019,1019],[1054,1054]]],[1559720829133,["GJX@GJXAIOU",[[1,1019,"yinwe"]],[1019,1019],[1024,1024]]],[1559720830411,["GJX@GJXAIOU",[[-1,1019,"yinwe"]],[1024,1024],[1019,1019]]],[1559720832520,["GJX@GJXAIOU",[[1,1019,"因为："]],[1019,1019],[1022,1022]]],[1559720842301,["GJX@GJXAIOU",[[1,1057,"，就是最后一位"]],[1057,1057],[1064,1064]]],[1559720907697,[null,[[-1,1565," "]],[1565,1565],[1565,1565]]],[1559720907697,[null,[[1,1565," "]],[1565,1565],[1565,1565]]],[1559720855533,["GJX@GJXAIOU",[[1,1064,"是7huzo"]],[1064,1064],[1070,1070]]],[1559720856404,["GJX@GJXAIOU",[[-1,1066,"huzo"]],[1070,1070],[1066,1066]]],[1559720858989,["GJX@GJXAIOU",[[1,1066,"或者8"]],[1066,1066],[1069,1069]]],[1559721027704,[null,[[-1,1570," "]],[1570,1570],[1570,1570]]],[1559721027704,[null,[[1,1570," "]],[1570,1570],[1570,1570]]],[1559721025106,["GJX@GJXAIOU",[[1,1755,"\n"]],[1735,1735],[1736,1736]]],[1559721025238,["GJX@GJXAIOU",[[1,1756,"\n"]],[1736,1736],[1737,1737]]],[1559721025355,["GJX@GJXAIOU",[[1,1757,"\n"]],[1737,1737],[1738,1738]]],[1559721025470,["GJX@GJXAIOU",[[1,1758,"\n"]],[1738,1738],[1739,1739]]],[1559721025612,["GJX@GJXAIOU",[[1,1759,"\n"]],[1739,1739],[1740,1740]]],[1559721025739,["GJX@GJXAIOU",[[1,1760,"\n"]],[1740,1740],[1741,1741]]],[1559721026956,["GJX@GJXAIOU",[[1,1741,"sili"]],[1741,1741],[1745,1745]]],[1559721027564,["GJX@GJXAIOU",[[-1,1743,"li"]],[1745,1745],[1743,1743]]],[1559721087695,[null,[[-1,1570," "],[1,1741,"\n"],[-1,1743,"\n"]],[1570,1570],[1743,1743]]],[1559721087695,[null,[[1,1570," "],[-1,1740,"\n"],[1,1743,"\n"]],[1743,1743],[1570,1570]]],[1559721028083,["GJX@GJXAIOU",[[-1,1741,"s"]],[1742,1742],[1741,1741]]],[1559721029109,["GJX@GJXAIOU",[[1,1741,"silu"]],[1741,1741],[1745,1745]]],[1559721029701,["GJX@GJXAIOU",[[-1,1741,"silu"]],[1745,1745],[1741,1741]]],[1559721029833,["GJX@GJXAIOU",[[-1,1760,"\n"]],[1741,1741],[1740,1740]]],[1559721033304,["GJX@GJXAIOU",[[1,1740,"思路二："]],[1740,1740],[1744,1744]]],[1559721033725,["GJX@GJXAIOU",[[1,1764,"\n"]],[1744,1744],[1745,1745]]],[1559721034700,["GJX@GJXAIOU",[[1,1745,"统一转为正整数处理。\n使用long处理正整数溢出问题。\nclass Solution {\n    public int reverse(int x) {\n        if(x == 0 ){\n            return x;\n        }\n\n        long  result = 0;\n\n        // 转为正数统一出处理，使用long类型处理溢出问题。\n        long a = x > 0 ? x: -x;\n\n        long pop;\n\n        while(a > 0){\n            pop = a % 10;\n            result = result * 10 + pop;\n            a = a/10;  \n        }\n        result =  x > 0 ? result : -result;\n        \n        if(result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE){\n            return (int)result;\n        }\n        return 0;\n    }\n}\n作者：tsiangleo\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-java-by-tsiangleo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1745,1745],[2462,2462]]],[1559721039255,["GJX@GJXAIOU",[[1,1745,"* "],[1,1756,"* "]],[1745,1772],[1747,1776]]],[1559721044263,["GJX@GJXAIOU",[[1,1740,"### "]],[1740,1740],[1748,1748]]],[1559721051206,["GJX@GJXAIOU",[[1,1781,"* \n"]],[1780,1780],[1783,1783]]],[1559721052741,["GJX@GJXAIOU",[[1,1783,"··、"]],[1783,1783],[1786,1786]]],[1559721054000,["GJX@GJXAIOU",[[-1,1781,"* ··、"]],[1786,1786],[1781,1781]]],[1559721054876,["GJX@GJXAIOU",[[1,1782,"\n"]],[1781,1781],[1782,1782]]],[1559721055653,["GJX@GJXAIOU",[[1,1782,"```"]],[1782,1782],[1785,1785]]],[1559721055680,["GJX@GJXAIOU",[[1,1785,"language\n```\n"]],[1785,1785],[1785,1793]]],[1559721056749,["GJX@GJXAIOU",[[-1,1785,"language"],[1,1793,"j"]],[1785,1793],[1786,1786]]],[1559721057181,["GJX@GJXAIOU",[[1,1786,"ava"]],[1786,1786],[1789,1789]]],[1559721057555,["GJX@GJXAIOU",[[1,1790,"\n"]],[1789,1789],[1790,1790]]],[1559721060722,["GJX@GJXAIOU",[[-1,1791,"```"]],[1791,1794],[1791,1791]]],[1559721063000,["GJX@GJXAIOU",[[1,2327,"\n"]],[2326,2326],[2327,2327]]],[1559721063423,["GJX@GJXAIOU",[[1,2327,"```"]],[2327,2327],[2330,2330]]],[1559721066313,["GJX@GJXAIOU",[[-1,1792,"\n"]],[1792,1792],[1791,1791]]],[1559721066429,["GJX@GJXAIOU",[[-1,1791,"\n"]],[1791,1791],[1790,1790]]],[1559721067097,["GJX@GJXAIOU",[[-1,1790,"\n"]],[1790,1790],[1789,1789]]]],null,"GJX@GJXAIOU"],["08515134-ab99-480e-ac03-c84749f7e2ef",1559782042748,"---\ntags:\n\n  - \nflag: green\ndate: '2019-06-05 '\n---\n\n\n\n\n\n# 2.整数反转\n\n\n\n\n\n## 一、题目\n给出一个 32 位的**有符号整数**，你需要将这个整数中每位上的**数字进行反转**。\n\n示例 1:\n\n输入: 123\n输出: 321\n 示例 2:\n\n输入: -123\n输出: -321\n示例 3:\n\n输入: 120\n输出: 21\n注意:\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 $[−2^31,  2^31 − 1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n\n\n\n\n\n## 二、解答\n\n**方法**：弹出和推入数字 & 溢出前进行检查\n**思路**\n\n我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n**算法**\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n```java\n//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n```\n但是，这种方法很危险，因为当 `temp=rev*10+pop` 时会导致溢出。\n\n幸运的是，事先检查这个语句是否会导致溢出很容易。\n\n为了便于解释，我们假设 rev 是正数。\n\n- 如果 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 导致溢出，那么一定有$\\text{rev} \\geq \\frac{INTMAX}{10}$\n\n- 如果 $\\text{rev} > \\frac{INTMAX}{10}$，那么 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 一定会溢出。\n- 如果 $\\text{rev} == \\frac{INTMAX}{10}$ ，那么只要 $\\text{pop} > 7，temp = \\text{rev} \\cdot 10 + \\text{pop}$ 就会溢出。\n\n**这里pop为什么大于7:**\n因为：2^31-1=2147483647,-2^31=-2147483648，就是最后一位是7或者8\n当rev 为负时可以应用类似的逻辑。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;\n            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n}\n\n```\n\n复杂度分析\n\n时间复杂度：$O(\\log(x))$，x 中大约有 $\\log_{10}(x)$位数字。\n空间复杂度：O(1)。\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n### 思路二：\n* 统一转为正整数处理。\n* 使用long处理正整数溢出问题。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        if(x == 0 ){\n            return x;\n        }\n\n        long  result = 0;\n\n        // 转为正数统一出处理，使用long类型处理溢出问题。\n        long a = x > 0 ? x: -x;\n\n        long pop;\n\n        while(a > 0){\n            pop = a % 10;\n            result = result * 10 + pop;\n            a = a/10;  \n        }\n        result =  x > 0 ? result : -result;\n        \n        if(result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE){\n            return (int)result;\n        }\n        return 0;\n    }\n}\n```\n作者：tsiangleo\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-java-by-tsiangleo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1559781983353,["GJX@GJXAIOU",[[1,1587,"\n"]],[1586,1586],[1587,1587]]],[1559781983840,["GJX@GJXAIOU",[[1,1588,"\n"]],[1587,1587],[1588,1588]]]],null,"GJX@GJXAIOU"],["f3a9ee8f-8d0a-46d9-9a7b-e87eb81afae7",1560058678128,"---\ntags:\n\n  - \nflag: green\ndate: '2019-06-05 '\n---\n\n\n\n\n\n# 2.整数反转\n\n\n\n\n\n## 一、题目\n给出一个 32 位的**有符号整数**，你需要将这个整数中每位上的**数字进行反转**。\n\n示例 1:\n\n输入: 123\n输出: 321\n 示例 2:\n\n输入: -123\n输出: -321\n示例 3:\n\n输入: 120\n输出: 21\n注意:\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 $[−2^31,  2^31 − 1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n\n\n\n\n\n## 二、解答\n\n**方法**：弹出和推入数字 & 溢出前进行检查\n**思路**\n\n我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n**算法**\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n```java\n//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n```\n但是，这种方法很危险，因为当 `temp=rev*10+pop` 时会导致溢出。\n\n幸运的是，事先检查这个语句是否会导致溢出很容易。\n\n为了便于解释，我们假设 rev 是正数。\n\n- 如果 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 导致溢出，那么一定有$\\text{rev} \\geq \\frac{INTMAX}{10}$\n\n- 如果 $\\text{rev} > \\frac{INTMAX}{10}$，那么 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 一定会溢出。\n- 如果 $\\text{rev} == \\frac{INTMAX}{10}$ ，那么只要 $\\text{pop} > 7，temp = \\text{rev} \\cdot 10 + \\text{pop}$ 就会溢出。\n\n**这里pop为什么大于7:**\n因为：2^31-1=2147483647,-2^31=-2147483648，就是最后一位是7或者8\n当rev 为负时可以应用类似的逻辑。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;\n            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n}\n\n```\n\n复杂度分析\n\n时间复杂度：$O(\\log(x))$，x 中大约有 $\\log_{10}(x)$位数字。\n空间复杂度：O(1)。\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n### 思路二：\n* 统一转为正整数处理。\n* 使用long处理正整数溢出问题。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        if(x == 0 ){\n            return x;\n        }\n\n        long  result = 0;\n\n        // 转为正数统一出处理，使用long类型处理溢出问题。\n        long a = x > 0 ? x: -x;\n\n        long pop;\n\n        while(a > 0){\n            pop = a % 10;\n            result = result * 10 + pop;\n            a = a/10;  \n        }\n        result =  x > 0 ? result : -result;\n        \n        if(result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE){\n            return (int)result;\n        }\n        return 0;\n    }\n}\n```\n作者：tsiangleo\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-java-by-tsiangleo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1560058657050,["GJX@GJXAIOU",[[1,15,"简单"]],[15,15],[17,17]]],[1560058658492,["GJX@GJXAIOU",[[-1,10,"\n"]],[10,10],[9,9]]]],null,"GJX@GJXAIOU"],["3e321518-50b0-4a2f-ae7a-93b88cdbd226",1560157781328,"---\ntags:\n  - 简单\nflag: green\ndate: '2019-06-05 '\n---\n\n\n\n\n\n# 2.整数反转\n\n\n\n\n\n## 一、题目\n给出一个 32 位的**有符号整数**，你需要将这个整数中每位上的**数字进行反转**。\n\n示例 1:\n\n输入: 123\n输出: 321\n 示例 2:\n\n输入: -123\n输出: -321\n示例 3:\n\n输入: 120\n输出: 21\n注意:\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 $[−2^31,  2^31 − 1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n\n\n\n\n\n## 二、解答\n\n**方法**：弹出和推入数字 & 溢出前进行检查\n**思路**\n\n我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n**算法**\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n```java\n//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n```\n但是，这种方法很危险，因为当 `temp=rev*10+pop` 时会导致溢出。\n\n幸运的是，事先检查这个语句是否会导致溢出很容易。\n\n为了便于解释，我们假设 rev 是正数。\n\n- 如果 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 导致溢出，那么一定有$\\text{rev} \\geq \\frac{INTMAX}{10}$\n\n- 如果 $\\text{rev} > \\frac{INTMAX}{10}$，那么 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 一定会溢出。\n- 如果 $\\text{rev} == \\frac{INTMAX}{10}$ ，那么只要 $\\text{pop} > 7，temp = \\text{rev} \\cdot 10 + \\text{pop}$ 就会溢出。\n\n**这里pop为什么大于7:**\n因为：2^31-1=2147483647,-2^31=-2147483648，就是最后一位是7或者8\n当rev 为负时可以应用类似的逻辑。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;\n            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n}\n\n```\n\n复杂度分析\n\n时间复杂度：$O(\\log(x))$，x 中大约有 $\\log_{10}(x)$位数字。\n空间复杂度：O(1)。\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n### 思路二：\n* 统一转为正整数处理。\n* 使用long处理正整数溢出问题。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        if(x == 0 ){\n            return x;\n        }\n\n        long  result = 0;\n\n        // 转为正数统一出处理，使用long类型处理溢出问题。\n        long a = x > 0 ? x: -x;\n\n        long pop;\n\n        while(a > 0){\n            pop = a % 10;\n            result = result * 10 + pop;\n            a = a/10;  \n        }\n        result =  x > 0 ? result : -result;\n        \n        if(result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE){\n            return (int)result;\n        }\n        return 0;\n    }\n}\n```\n作者：tsiangleo\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-java-by-tsiangleo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1560157733855,["GJX@GJXAIOU",[[-1,60,"2"]],[61,61],[60,60]]],[1560157734832,["GJX@GJXAIOU",[[1,60,"7"]],[60,60],[61,61]]]],null,"GJX@GJXAIOU"],["c5f3fa9f-dd40-43ca-a182-760df3297005",1561422912914,"---\ntags:\n  - 简单\nflag: green\ndate: '2019-06-05 '\n---\n\n\n\n\n\n# 7.整数反转\n\n\n\n\n\n## 一、题目\n给出一个 32 位的**有符号整数**，你需要将这个整数中每位上的**数字进行反转**。\n\n示例 1:\n\n输入: 123\n输出: 321\n 示例 2:\n\n输入: -123\n输出: -321\n示例 3:\n\n输入: 120\n输出: 21\n注意:\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 $[−2^31,  2^31 − 1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n\n\n\n\n\n## 二、解答\n\n**方法**：弹出和推入数字 & 溢出前进行检查\n**思路**\n\n我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n**算法**\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” x 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev 将与 x 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n```java\n//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n```\n但是，这种方法很危险，因为当 `temp=rev*10+pop` 时会导致溢出。\n\n幸运的是，事先检查这个语句是否会导致溢出很容易。\n\n为了便于解释，我们假设 rev 是正数。\n\n- 如果 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 导致溢出，那么一定有$\\text{rev} \\geq \\frac{INTMAX}{10}$\n\n- 如果 $\\text{rev} > \\frac{INTMAX}{10}$，那么 $temp = \\text{rev} \\cdot 10 + \\text{pop}$ 一定会溢出。\n- 如果 $\\text{rev} == \\frac{INTMAX}{10}$ ，那么只要 $\\text{pop} > 7，temp = \\text{rev} \\cdot 10 + \\text{pop}$ 就会溢出。\n\n**这里pop为什么大于7:**\n因为：2^31-1=2147483647,-2^31=-2147483648，就是最后一位是7或者8\n当rev 为负时可以应用类似的逻辑。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;\n            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n}\n\n```\n\n复杂度分析\n\n时间复杂度：$O(\\log(x))$，x 中大约有 $\\log_{10}(x)$位数字。\n空间复杂度：O(1)。\n\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n### 思路二：\n* 统一转为正整数处理。\n* 使用long处理正整数溢出问题。\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        if(x == 0 ){\n            return x;\n        }\n\n        long  result = 0;\n\n        // 转为正数统一出处理，使用long类型处理溢出问题。\n        long a = x > 0 ? x: -x;\n\n        long pop;\n\n        while(a > 0){\n            pop = a % 10;\n            result = result * 10 + pop;\n            a = a/10;  \n        }\n        result =  x > 0 ? result : -result;\n        \n        if(result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE){\n            return (int)result;\n        }\n        return 0;\n    }\n}\n```\n作者：tsiangleo\n链接：https://leetcode-cn.com/problems/two-sum/solution/zheng-shu-fan-zhuan-java-by-tsiangleo/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",[[1561422855645,["GJX@GJXAIOU",[[1,17,"  \n"]],[16,16],[19,19]]],[1561422857088,["GJX@GJXAIOU",[[1,19,"- shu"]],[19,19],[24,24]]],[1561422857998,["GJX@GJXAIOU",[[-1,21,"shu"]],[24,24],[21,21]]],[1561422859884,["GJX@GJXAIOU",[[1,21,"完成"]],[21,21],[23,23]]],[1561422860148,["GJX@GJXAIOU",[[1,24,"  \n"]],[23,23],[26,26]]],[1561422861856,["GJX@GJXAIOU",[[1,26,"- 数组"]],[26,26],[30,30]]],[1561422864372,["GJX@GJXAIOU",[[1,43,"\n"]],[42,42],[43,43]]],[1561422865857,["GJX@GJXAIOU",[[1,43,"styel"]],[43,43],[48,48]]],[1561422866750,["GJX@GJXAIOU",[[-1,46,"el"]],[48,48],[46,46]]],[1561422869903,["GJX@GJXAIOU",[[1,46,"le: summer"]],[46,46],[56,56]]]],null,"GJX@GJXAIOU"]]}