{"compress":true,"commitItems":[["d8550815-ed3d-40ac-8a63-889c8ec682be",1559895122790,"",[[1559895090811,["GJX@GJXAIOU",[[1,0,"# 8.删除排序数组中的重复项\n\n\n\n"]],[0,0],[18,18]]],[1559895097546,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1559895097673,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1559895097810,["GJX@GJXAIOU",[[1,2,"\n"]],[2,2],[3,3]]],[1559895099986,["GJX@GJXAIOU",[[1,0,"`"]],[0,0],[1,1]]],[1559895100186,["GJX@GJXAIOU",[[1,0,"`"]],[1,1],[2,2]]],[1559895101353,["GJX@GJXAIOU",[[-1,0,"``"]],[2,2],[0,0]]],[1559895101722,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1559895101882,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1559895102033,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1559895102056,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1559895108644,["GJX@GJXAIOU",[[1,4,"tags: "]],[4,4],[10,10]]],[1559895110732,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1559895112107,["GJX@GJXAIOU",[[1,11," "]],[11,11],[12,12]]],[1559895112859,["GJX@GJXAIOU",[[-1,11," "]],[12,12],[11,11]]],[1559895115267,["GJX@GJXAIOU",[[1,11,"  - kua"]],[11,11],[18,18]]],[1559895116204,["GJX@GJXAIOU",[[-1,15,"kua"]],[18,18],[15,15]]],[1559895120646,["GJX@GJXAIOU",[[1,15,"快慢指针"]],[15,15],[19,19]]],[1559895124017,["GJX@GJXAIOU",[[1,20,"  \n"]],[19,19],[22,22]]],[1559895124177,["GJX@GJXAIOU",[[-1,20,"  "],[1,22,"\n"]],[22,22],[21,21]]],[1559895125665,["GJX@GJXAIOU",[[-1,21,"\n"]],[21,21],[20,20]]],[1559895132185,["GJX@GJXAIOU",[[1,20,"flag: grenn"]],[20,20],[31,31]]],[1559895133220,["GJX@GJXAIOU",[[-1,29,"nn"]],[31,31],[29,29]]],[1559895133565,["GJX@GJXAIOU",[[1,29,"en"]],[29,29],[31,31]]],[1559895134977,["GJX@GJXAIOU",[[1,32,"\n"]],[31,31],[32,32]]],[1559895140115,["GJX@GJXAIOU",[[1,32,"data: ‘’"]],[32,32],[40,40]]],[1559895140705,["GJX@GJXAIOU",[[-1,39,"’"]],[40,40],[39,39]]],[1559895141612,["GJX@GJXAIOU",[[1,39,"‘"]],[39,39],[40,40]]],[1559895142521,["GJX@GJXAIOU",[[-1,38,"‘‘"]],[40,40],[38,38]]],[1559895143355,["GJX@GJXAIOU",[[1,38,"''"]],[38,38],[40,40]]],[1559895156484,["GJX@GJXAIOU",[[1,39,"2019-6-7"]],[39,39],[47,47]]],[1559895160617,["GJX@GJXAIOU",[[-1,55,"\n"]],[55,55],[54,54]]],[1559895429897,["GJX@GJXAIOU",[[1,72,"## yi"]],[72,72],[77,77]]],[1559895430648,["GJX@GJXAIOU",[[-1,75,"yi"]],[77,77],[75,75]]],[1559895434875,["GJX@GJXAIOU",[[1,75,"一、题目"]],[75,75],[79,79]]],[1559895435236,["GJX@GJXAIOU",[[1,81,"\n"]],[79,79],[80,80]]],[1559895435387,["GJX@GJXAIOU",[[1,82,"\n"]],[80,80],[81,81]]],[1559895435531,["GJX@GJXAIOU",[[1,83,"\n"]],[81,81],[82,82]]],[1559895437217,["GJX@GJXAIOU",[[1,82,"##  "]],[82,82],[86,86]]],[1559895437780,["GJX@GJXAIOU",[[-1,85," "]],[86,86],[85,85]]],[1559895440970,["GJX@GJXAIOU",[[1,85,"二、解答"]],[85,85],[89,89]]],[1559895442826,["GJX@GJXAIOU",[[1,82,"\n"]],[80,80],[81,81]]],[1559895442953,["GJX@GJXAIOU",[[1,83,"\n"]],[81,81],[82,82]]],[1559895443065,["GJX@GJXAIOU",[[1,84,"\n"]],[82,82],[83,83]]],[1559895445865,["GJX@GJXAIOU",[[1,85,"\n"]],[80,80],[81,81]]],[1559895467865,["GJX@GJXAIOU",[[1,81,"给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n示例 1:\n\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n示例 2:\n\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[81,81],[785,785]]],[1559895473249,["GJX@GJXAIOU",[[1,85,"**"],[1,89,"**"]],[85,89],[85,93]]],[1559895481013,["GJX@GJXAIOU",[[-1,185," "],[1,186," "],[1,189,"·"],[-1,280," "],[1,281," "],[-1,644,"   "],[1,647,"   "]],[189,189],[190,190]]],[1559895481454,["GJX@GJXAIOU",[[1,190,"·"]],[190,190],[191,191]]],[1559895482674,["GJX@GJXAIOU",[[-1,190,"·"]],[191,191],[190,190]]],[1559895482844,["GJX@GJXAIOU",[[-1,189,"·"]],[190,190],[189,189]]],[1559895484354,["GJX@GJXAIOU",[[1,189,"```"]],[189,189],[192,192]]],[1559895484377,["GJX@GJXAIOU",[[1,192,"language\n```\n"]],[192,192],[192,200]]],[1559895490257,["GJX@GJXAIOU",[[-1,189,"```language\n```"]],[189,204],[189,189]]],[1559895492211,["GJX@GJXAIOU",[[1,183,"- "]],[183,183],[185,185]]],[1559895495005,["GJX@GJXAIOU",[[-1,192,"\n"]],[192,192],[191,191]]],[1559895495193,["GJX@GJXAIOU",[[-1,191,"\n"]],[191,191],[190,190]]],[1559895497907,["GJX@GJXAIOU",[[-1,213,"\n"]],[213,213],[212,212]]],[1559895501634,["GJX@GJXAIOU",[[-1,256,"\n"]],[256,256],[255,255]]],[1559895505507,["GJX@GJXAIOU",[[1,277,"-"]],[277,277],[278,278]]],[1559895505930,["GJX@GJXAIOU",[[1,278,"\n"]],[278,278],[279,279]]],[1559895508764,["GJX@GJXAIOU",[[-1,277,"-"]],[278,278],[277,277]]],[1559895510898,["GJX@GJXAIOU",[[1,278,"- "]],[278,278],[280,280]]],[1559895517926,["GJX@GJXAIOU",[[1,399,"- "]],[399,399],[401,401]]],[1559895520322,["GJX@GJXAIOU",[[-1,320,"\n"]],[320,320],[319,319]]],[1559895523242,["GJX@GJXAIOU",[[-1,371,"\n"]],[371,371],[370,370]]],[1559895524764,["GJX@GJXAIOU",[[-1,286,"\n"]],[286,286],[285,285]]],[1559895530993,["GJX@GJXAIOU",[[-1,421,"\n"]],[421,421],[420,420]]],[1559895544006,["GJX@GJXAIOU",[[1,480,"```"]],[480,480],[483,483]]],[1559895544030,["GJX@GJXAIOU",[[1,483,"language\n```\n"]],[483,483],[483,491]]],[1559895545062,["GJX@GJXAIOU",[[-1,483,"language"],[1,491,"j"]],[483,491],[484,484]]],[1559895547533,["GJX@GJXAIOU",[[1,484,"ava"]],[484,484],[487,487]]],[1559895550593,["GJX@GJXAIOU",[[-1,488,"```"]],[488,491],[488,488]]],[1559895552892,["GJX@GJXAIOU",[[1,675,"```"]],[675,675],[678,678]]],[1559895556331,["GJX@GJXAIOU",[[-1,489,"\n"]],[489,489],[488,488]]],[1559895556721,["GJX@GJXAIOU",[[-1,488,"\n"]],[488,488],[487,487]]],[1559895563115,["GJX@GJXAIOU",[[-1,677,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n"]],[677,800],[677,677]]],[1559895578553,["GJX@GJXAIOU",[[1,690,"\n"]],[689,689],[690,690]]],[1559895578945,["GJX@GJXAIOU",[[1,690,"方法：双指针法\n算法\n\n数组完成排序后，我们可以放置两个指针 ii 和 jj，其中 ii 是慢指针，而 jj 是快指针。只要 nums[i] = nums[j]nums[i]=nums[j]，我们就增加 jj 以跳过重复项。\n\n当我们遇到 nums[j] \\neq nums[i]nums[j] \n\n​\t\n =nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]nums[j]）的值复制到 nums[i + 1]nums[i+1]。然后递增 ii，接着我们将再次重复相同的过程，直到 jj 到达数组的末尾为止。\n\nJava\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n复杂度分析\n\n时间复杂度：O(n)O(n)，假设数组的长度是 nn，那么 ii 和 jj 分别最多遍历 nn 步。\n\n空间复杂度：O(1)O(1)。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[690,690],[1464,1464]]],[1559895585187,["GJX@GJXAIOU",[[1,690,"**"],[1,697,"**"]],[690,697],[690,701]]],[1559895586706,["GJX@GJXAIOU",[[1,702,"**"],[1,704,"**"]],[702,704],[702,708]]],[1559895594521,["GJX@GJXAIOU",[[1,818,"$"]],[818,818],[819,819]]],[1559895597218,["GJX@GJXAIOU",[[1,839,"$"]],[839,839],[840,840]]],[1559895606721,["GJX@GJXAIOU",[[-1,840,"\n​\t\n =nums[i] "]],[840,854],[840,840]]],[1559895612801,["GJX@GJXAIOU",[[-1,871,"nums[j]"]],[871,878],[871,871]]],[1559895616945,["GJX@GJXAIOU",[[-1,889,"nums[i+1]"]],[889,898],[889,889]]],[1559895618360,["GJX@GJXAIOU",[[-1,896,"i"]],[896,897],[896,896]]],[1559895620018,["GJX@GJXAIOU",[[-1,916,"j"]],[916,916],[915,915]]],[1559895628768,["GJX@GJXAIOU",[[-1,768," = nums[j]nums[i]"]],[761,778],[761,761]]],[1559895630016,["GJX@GJXAIOU",[[-1,751,"j"]],[752,752],[751,751]]],[1559895632345,["GJX@GJXAIOU",[[-1,730,"i"]],[730,730],[729,729]]],[1559895633633,["GJX@GJXAIOU",[[-1,734,"j"]],[734,734],[733,733]]],[1559895634896,["GJX@GJXAIOU",[[-1,739,"i"]],[739,739],[738,738]]],[1559895639352,["GJX@GJXAIOU",[[-1,780,"j"]],[781,781],[780,780]]],[1559895647124,["GJX@GJXAIOU",[[1,907,"```"]],[907,907],[910,910]]],[1559895647149,["GJX@GJXAIOU",[[1,910,"language\n```\n"]],[910,910],[910,918]]],[1559895649233,["GJX@GJXAIOU",[[-1,910,"language"],[1,918,"j"]],[910,918],[911,911]]],[1559895649644,["GJX@GJXAIOU",[[1,911,"ava"]],[911,911],[914,914]]],[1559895649939,["GJX@GJXAIOU",[[1,915,"\n"]],[914,914],[915,915]]],[1559895653306,["GJX@GJXAIOU",[[-1,916,"```\nJava"]],[916,924],[916,916]]],[1559895656345,["GJX@GJXAIOU",[[1,1172,"\n"]],[1171,1171],[1172,1172]]],[1559895656844,["GJX@GJXAIOU",[[1,1172,"```\nJava"]],[1172,1172],[1180,1180]]],[1559895661281,["GJX@GJXAIOU",[[-1,916,"\n"]],[916,916],[915,915]]],[1559895661419,["GJX@GJXAIOU",[[-1,915,"\n"]],[915,915],[914,914]]],[1559895722813,[null,[[-1,818," =nums[i] "],[-1,849,"[j]"],[1,852,"把它（"],[-1,867,"]n"],[1,874," + "],[-1,883,"i"],[1,894,"相"],[-1,902,"j"],[-1,907,"```java\n"],[1,915,"数组的末尾"],[-1,920,"J"],[1,921,"```j"],[-1,1170,"```\nJava\n"],[1,1188,"\n```\nJava"]],[818,818],[1197,1197]]],[1559895722813,[null,[[1,818," =nums[i] "],[1,839,"[j]"],[-1,839,"把它（"],[1,857,"]n"],[-1,862," + "],[1,874,"i"],[-1,884,"相"],[1,893,"j"],[1,897,"```java\n"],[-1,897,"数组的末尾"],[1,907,"J"],[-1,907,"```j"],[1,1160,"```\nJava\n"],[-1,1169,"\n```\nJava"]],[1197,1197],[818,818]]],[1559895673716,["GJX@GJXAIOU",[[-1,1174,"Java"]],[1174,1178],[1174,1174]]],[1559895675891,["GJX@GJXAIOU",[[1,1175,"**"],[1,1180,"**"]],[1175,1180],[1175,1184]]],[1559895678523,["GJX@GJXAIOU",[[1,1186,"- "]],[1186,1186],[1188,1188]]],[1559895681011,["GJX@GJXAIOU",[[1,1240,"- "]],[1240,1240],[1242,1242]]],[1559895684306,["GJX@GJXAIOU",[[-1,1195,"(n)O"]],[1198,1198],[1194,1194]]],[1559895685378,["GJX@GJXAIOU",[[-1,1230,"n"]],[1231,1231],[1230,1230]]],[1559895686860,["GJX@GJXAIOU",[[-1,1209,"n"]],[1209,1209],[1208,1208]]],[1559895687849,["GJX@GJXAIOU",[[-1,1214,"i"]],[1214,1215],[1214,1214]]],[1559895689522,["GJX@GJXAIOU",[[-1,1218,"j"]],[1218,1218],[1217,1217]]],[1559895691850,["GJX@GJXAIOU",[[-1,1244,"O(1)"]],[1248,1248],[1244,1244]]],[1559895696188,["GJX@GJXAIOU",[[1,1415,"\n"]],[1414,1414],[1415,1415]]],[1559895696329,["GJX@GJXAIOU",[[1,1416,"\n"]],[1415,1415],[1416,1416]]],[1559895696506,["GJX@GJXAIOU",[[1,1417,"\n"]],[1416,1416],[1417,1417]]],[1559895696705,["GJX@GJXAIOU",[[1,1418,"\n"]],[1417,1417],[1418,1418]]],[1559895696877,["GJX@GJXAIOU",[[1,1419,"\n"]],[1418,1418],[1419,1419]]],[1559895697501,["GJX@GJXAIOU",[[-1,1419,"\n"],[1,1420,"-"]],[1419,1419],[1420,1420]]],[1559895698861,["GJX@GJXAIOU",[[1,1420," ji"]],[1420,1420],[1423,1423]]],[1559895699329,["GJX@GJXAIOU",[[-1,1421,"ji"]],[1423,1423],[1421,1421]]],[1559895700664,["GJX@GJXAIOU",[[1,1421,"zixinhg"]],[1421,1421],[1428,1428]]],[1559895701818,["GJX@GJXAIOU",[[-1,1421,"zixinhg"]],[1428,1428],[1421,1421]]],[1559895707884,["GJX@GJXAIOU",[[1,1421,"自行解法同上"]],[1421,1421],[1427,1427]]],[1559895842816,[null,[[-1,818," =nums[i] "],[-1,849,"[j]"],[1,852,"把它（"],[-1,867,"]n"],[1,874," + "],[-1,883,"i"],[1,894,"相"],[-1,902,"j"],[-1,907,"```java\n"],[1,915,"数组的末尾"],[-1,920,"J"],[1,921,"```j"],[-1,1170,"```\n\n**"],[-1,1182,"**"],[-1,1186,"- "],[1,1191,"```\n\n**"],[1,1195,"析**\n\n- 时"],[-1,1200,"O(n)"],[1,1209,"假"],[1,1214,"度"],[-1,1217,"n"],[1,1218,"，"],[-1,1221,"i"],[-1,1232,"- "],[-1,1237,"n"],[1,1244,"- 空间复杂"],[-1,1246,"O(1)"],[1,1415,"业转载请注明出处。\n"],[-1,1427,"业转载请注明出处。\n"]],[818,818],[1427,1427]]],[1559895842816,[null,[[1,818," =nums[i] "],[1,839,"[j]"],[-1,839,"把它（"],[1,857,"]n"],[-1,862," + "],[1,874,"i"],[-1,884,"相"],[1,893,"j"],[1,897,"```java\n"],[-1,897,"数组的末尾"],[1,907,"J"],[-1,907,"```j"],[1,1160,"```\n\n**"],[1,1165,"**"],[1,1167,"- "],[-1,1170,"```\n\n**"],[-1,1181,"析**\n\n- 时"],[1,1194,"O(n)"],[-1,1199,"假"],[-1,1205,"度"],[1,1209,"n"],[-1,1209,"，"],[1,1213,"i"],[1,1223,"- "],[1,1226,"n"],[-1,1232,"- 空间复杂"],[1,1240,"O(1)"],[-1,1405,"业转载请注明出处。\n"],[1,1427,"业转载请注明出处。\n"]],[1427,1427],[818,818]]],[1559895788954,["GJX@GJXAIOU",[[1,1427,"\n- "]],[1427,1427],[1430,1430]]],[1559895789122,["GJX@GJXAIOU",[[-1,1428,"- "],[1,1430,"\n\n"]],[1430,1430],[1429,1429]]],[1559895791075,["GJX@GJXAIOU",[[1,1429,"思路：与选择排序的思想相似，把数组分成左右两块。利用两个指针（索引）移动，pre指向非重复的最后一个元素，find去查找下一个非重复的元素，然后覆盖到pre的下一个地址最后返回pre指针之前的长度 pre + 1\n\n作者：shiddong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yu-xuan-ze-pai-xu-de-si-xiang-xiang-si-ba-shu-zu-f/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1429,1429],[1704,1704]]],[1559895796560,["GJX@GJXAIOU",[[-1,1654,"来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[1654,1704],[1654,1654]]],[1559895800640,["GJX@GJXAIOU",[[1,1537,"\n"]],[1535,1535],[1536,1536]]],[1559895822771,["GJX@GJXAIOU",[[1,1536,"这里的pre和find初始值分比为0,1,其他想听"]],[1536,1536],[1561,1561]]],[1559895823385,["GJX@GJXAIOU",[[-1,1559,"想听"]],[1561,1561],[1559,1559]]],[1559895825324,["GJX@GJXAIOU",[[1,1559,"相同；"]],[1559,1559],[1562,1562]]]],null,"GJX@GJXAIOU"],["989ccb50-5857-4474-8807-d4ea87d3977f",1560058558413,"---\ntags: \n  - 快慢指针\nflag: green\ndata: '2019-6-7'\n---\n\n\n# 8.删除排序数组中的重复项\n\n## 一、题目\n\n给定一个**排序数组**，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n- 示例 1:\n给定数组 nums = [1,1,2], \n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n你不需要考虑数组中超出新长度后面的元素。\n\n- 示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。\n说明:\n\n- 为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n```java\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n\n\n\n## 二、解答\n\n**方法：双指针法**\n**算法**\n\n数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i]=nums[j]，我们就增加 j 以跳过重复项。\n\n当我们遇到 $nums[j] \\neq nums[i]$时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。\n\n```java\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n\n- 空间复杂度：O(1)。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n- 自行解法同上\n\n思路：与选择排序的思想相似，把数组分成左右两块。利用两个指针（索引）移动，pre指向非重复的最后一个元素，find去查找下一个非重复的元素，然后覆盖到pre的下一个地址最后返回pre指针之前的长度 pre + 1\n这里的pre和find初始值分比为0,1,其他相同；\n\n作者：shiddong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yu-xuan-ze-pai-xu-de-si-xiang-xiang-si-ba-shu-zu-f/\n\n",[[1560058543237,["GJX@GJXAIOU",[[1,20,"  \n"]],[19,19],[22,22]]],[1560058545756,["GJX@GJXAIOU",[[1,22,"- sh"]],[22,22],[26,26]]],[1560058546348,["GJX@GJXAIOU",[[-1,24,"sh"]],[26,26],[24,24]]],[1560058547791,["GJX@GJXAIOU",[[1,24,"数组"]],[24,24],[26,26]]],[1560058550485,["GJX@GJXAIOU",[[1,27,"  \n"]],[26,26],[29,29]]],[1560058552804,["GJX@GJXAIOU",[[-1,27,"  "]],[29,29],[27,27]]],[1560058553159,["GJX@GJXAIOU",[[-1,27,"\n"]],[27,27],[26,26]]],[1560058555268,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1560058556296,["GJX@GJXAIOU",[[1,11,"="]],[11,11],[12,12]]],[1560058557077,["GJX@GJXAIOU",[[-1,11,"="]],[12,12],[11,11]]],[1560058562138,["GJX@GJXAIOU",[[1,11,"  - 简单"]],[11,11],[17,17]]]],null,"GJX@GJXAIOU"],["aed8b4b2-c0d7-4d6e-9e6d-179c3716b530",1561361262217,"---\ntags: \n  - 简单\n  - 快慢指针\n  - 数组\nflag: green\ndata: '2019-6-7'\n---\n\n\n# 8.删除排序数组中的重复项\n\n## 一、题目\n\n给定一个**排序数组**，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n- 示例 1:\n给定数组 nums = [1,1,2], \n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n你不需要考虑数组中超出新长度后面的元素。\n\n- 示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。\n说明:\n\n- 为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n```java\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n```\n\n\n\n\n## 二、解答\n\n**方法：双指针法**\n**算法**\n\n数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i]=nums[j]，我们就增加 j 以跳过重复项。\n\n当我们遇到 $nums[j] \\neq nums[i]$时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。\n\n```java\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n\n- 空间复杂度：O(1)。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n- 自行解法同上\n\n思路：与选择排序的思想相似，把数组分成左右两块。利用两个指针（索引）移动，pre指向非重复的最后一个元素，find去查找下一个非重复的元素，然后覆盖到pre的下一个地址最后返回pre指针之前的长度 pre + 1\n这里的pre和find初始值分比为0,1,其他相同；\n\n作者：shiddong\n链接：https://leetcode-cn.com/problems/two-sum/solution/yu-xuan-ze-pai-xu-de-si-xiang-xiang-si-ba-shu-zu-f/\n\n",[[1561361204765,["GJX@GJXAIOU",[[1,46,"\n"]],[45,45],[46,46]]],[1561361205512,["GJX@GJXAIOU",[[1,46,"sy"]],[46,46],[48,48]]],[1561361206021,["GJX@GJXAIOU",[[-1,47,"y"]],[48,48],[47,47]]],[1561361209511,["GJX@GJXAIOU",[[1,47,"tyle: summer"]],[47,47],[59,59]]]],null,"GJX@GJXAIOU"]]}