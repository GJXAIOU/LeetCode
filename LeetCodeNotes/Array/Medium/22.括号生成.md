---
layout:     post
title:      22. 括号生成
subtitle:   Array.medium
date:       2020-04-19
author:     GJXAIOU
header-img: img/post-bg-leetcode.png
catalog: true
tags:
    - 数组
	- 回溯算法
	- 深度优先搜索
	- 广度优先搜索
	- 动态规划
	- 完成
---



# 22. 括号生成

## 一、题目

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例：**

```
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```

## 二、解答

![image.png](22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.resource/6be56bc36dd8427757cb12b814656665fd9b39d856108809d3b6344e8cf50112-image.png)

### 方法一：深度优先遍历

我们以 `n = 2` 为例，画树形结构图。方法是 “做减法”。

![LeetCode 第 22 题：“括号生出”题解配图.png](https://pic.leetcode-cn.com/7ec04f84e936e95782aba26c4663c5fe7aaf94a2a80986a97d81574467b0c513-LeetCode%20%E7%AC%AC%2022%20%E9%A2%98%EF%BC%9A%E2%80%9C%E6%8B%AC%E5%8F%B7%E7%94%9F%E5%87%BA%E2%80%9D%E9%A2%98%E8%A7%A3%E9%85%8D%E5%9B%BE.png)

画图以后，可以分析出的结论：

- 当前左右括号都有大于0 个可以使用的时候，才产生分支；

- 产生左分支的时候，只看当前是否还有左括号可以使用；

- 产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；

- 在左边和右边剩余的括号数都等于 0 的时候结算。

**参考代码 1**：

```java
package array.medium;

import java.util.ArrayList;
import java.util.List;

/**
 * @author GJXAIOU
 * @create 2020/04/19 18:07
 */
public class LeetCode22 {
    // 方法一：做减法
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        // 特判
        if (n == 0) {
            return res;
        }

        // 执行深度优先遍历，搜索可能的结果
        dfs(n, n, "", res);
        return res;
    }

    /**
     * @param curStr      当前递归得到的结果
     * @param leftRemain  左括号还有几个可以使用
     * @param rightRemain 右括号还有几个可以使用
     * @param res         结果集
     */

    private void dfs(int leftRemain, int rightRemain, String curStr, List<String> res) {
        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯
        // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分
        if (leftRemain == 0 && rightRemain == 0) {
            res.add(curStr);
            return;
        }

        // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）
        if (leftRemain > rightRemain) {
            return;
        }

        if (leftRemain > 0) {
            dfs(leftRemain - 1, rightRemain, curStr + "(", res);
        }

        if (rightRemain > 0) {
            dfs(leftRemain, rightRemain - 1, curStr + ")", res);
        }
    }

}

```

我们运行 `n = 2` 的情况，得到结果 `[(()), ()()]` ，说明分析的结果是正确的。

**方法二：做加法**==更好理解==

如果我们不用减法，使用加法，**即 `leftUsed` 表示“左括号已经用掉几个”，`rightUsed` 表示“右括号还已经用掉几个”**，可以画出另一棵递归树。

- 生成左枝叶的条件：左括号已经用掉的数目小于总数目；
- 生成右枝叶的条件：右括号已经用掉的数目小于左括号已经用掉的数目。

![image.png](22.%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.resource/efbe574e5e6addcd1c9dc5c13a50c6f162a2b14a95d6aed2c394e18287a067fa-image.png)

下面是参考代码。

**参考代码 2**：

```java
package array.medium;

import java.util.ArrayList;
import java.util.List;

/**
 * @author GJXAIOU
 * @create 2020/04/19 18:07
 */
public class LeetCode22 {
    // 方法二：做加法
    public List<String> generateParenthesis(int n) {
        List<String> resList = new ArrayList<>();
        if (n <= 0) {
            return resList;
        }
        dfs(0, 0, n, "", resList);
        return resList;
    }

    /**
     * @param curStr    当前递归得到的结果
     * @param leftUsed  左括号已经用了几个
     * @param rightUsed 右括号已经用了几个
     * @param total     左括号、右括号分别一共有几个
     * @param resList   结果集
     */
    public void dfs(int leftUsed, int rightUsed, int total, String curStr, List<String> resList) {
        if ((leftUsed == total) && (rightUsed == total)) {
            // 因为 String 是不可变，所以每次都会产生新的
            resList.add(curStr);
            return;
        }
        if (leftUsed < rightUsed) {
            return;
        }

        if (leftUsed < total) {
            dfs(leftUsed++, rightUsed, total, curStr + "(", resList);
        }
        if (rightUsed < total) {
            dfs(leftUsed, rightUsed++, total, curStr + ")", resList);
        }
    }
}
```

#### 方法二：广度优先遍历

通过编写广度优先遍历的代码，读者可以体会一下，为什么搜索几乎都是用深度优先遍历（回溯算法）。

广度优先遍历，得程序员自己编写结点类，显示使用队列这个数据结构。深度优先遍历的时候，就可以直接使用系统栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显示使用栈。

下面的代码，读者可以把 `Queue` 换成 `Stack`，提交以后，也可以得到 Accept。

读者可以通过比较：

1、广度优先遍历；

2、自己使用栈编写深度优先遍历；

3、使用系统栈的深度优先遍历（回溯算法）。

来理解 “回溯算法” 作为一种 “搜索算法” 的合理性。

还是上面的题解配图（1），使用广度优先遍历，结果集都在最后一层，即叶子结点处得到所有的结果集，编写代码如下。

感谢 [@liu-ren-you](https://leetcode-cn.com/u/liu-ren-you/) 朋友帮我优化了代码。

**参考代码 3**：（前 2 个 Java 代码写法没有本质不同，仅供参考。第 3 个 Java 代码仅仅是把 `Queue` 换成了 `Stack` ，广度优先遍历就改成了深度优先遍历。）

```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Solution {

    class Node {
        /**
         * 当前得到的字符串
         */
        private String res;
        /**
         * 剩余左括号数量
         */
        private int left;
        /**
         * 剩余右括号数量
         */
        private int right;

        public Node(String str, int left, int right) {
            this.res = str;
            this.left = left;
            this.right = right;
        }
    }

    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        if (n == 0) {
            return res;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.offer(new Node("", n, n));

        while (!queue.isEmpty()) {

            Node curNode = queue.poll();
            if (curNode.left == 0 && curNode.right == 0) {
                res.add(curNode.res);
            }
            if (curNode.left > 0) {
                queue.offer(new Node(curNode.res + "(", curNode.left - 1, curNode.right));
            }
            if (curNode.right > 0 && curNode.left < curNode.right) {
                queue.offer(new Node(curNode.res + ")", curNode.left, curNode.right - 1));
            }
        }
        return res;
    }
}
```

#### 方法三：动态规划

参考了本题的 [「官方题解」](https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode/) 中的 “闭合数方法” 和 [「精选题解」](https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/)，同样的方法也可以用来完成 [「力扣」第 95 题：“不同的二叉搜索树 II”](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)。

**第 1 步：定义状态 `dp[i]`**：使用 `i` 对括号能够生成的组合。

**注意**：每一个状态都是列表的形式。

**第 2 步：状态转移方程**：

- `i` 对括号的一个组合，在 `i - 1` 对括号的基础上得到，这是思考 “状态转移方程” 的基础；
- `i` 对括号的一个组合，一定以左括号 "(" 开始，不一定以 ")" 结尾。为此，我们可以枚举新的右括号 ")" 可能所处的位置，得到所有的组合；
- 枚举的方式就是枚举左括号 "(" 和右括号 ")" **中间可能的合法的括号对数**，而剩下的合法的括号对数在与第一个左括号 "(" 配对的右括号 ")" 的后面，这就用到了以前的状态。

状态转移方程是：

```
dp[i] = "(" + dp[可能的括号对数] + ")" + dp[剩下的括号对数]
```

- “可能的括号对数” 与 “剩下的括号对数” 之和得为 `i - 1`（感谢 [@xuyik](https://leetcode-cn.com/u/xuyik/) 朋友纠正了我的错误），故 “可能的括号对数” `j` 可以从 `0` 开始，最多不能超过 `i`， 即 `i - 1`；
- “剩下的括号对数” + `j` = `i - 1`，故 “剩下的括号对数” = `i - j - 1`。

整理得：

```
dp[i] = "(" + dp[j] + ")" + dp[i- j - 1] , j = 0, 1, ..., i - 1
```

**第 3 步： 思考初始状态和输出**：

- 初始状态：因为我们需要 `0` 对括号这种状态，因此状态数组 `dp` 从 `0` 开始，`0` 个括号当然就是 `[""]`。
- 输出：`dp[n]` 。

这个方法暂且就叫它动态规划，这么用也是很神奇的，它有下面两个特点：

1、自底向上：从小规模问题开始，逐渐得到大规模问题的解集；

2、无后效性：后面的结果的得到，不会影响到前面的结果。

**参考代码 4**：

```
import java.util.ArrayList;
import java.util.List;

public class Solution {

    // 把结果集保存在动态规划的数组里

    public List<String> generateParenthesis(int n) {
        if (n == 0) {
            return new ArrayList<>();
        }
        // 这里 dp 数组我们把它变成列表的样子，方便调用而已
        List<List<String>> dp = new ArrayList<>(n);

        List<String> dp0 = new ArrayList<>();
        dp0.add("");
        dp.add(dp0);

        for (int i = 1; i <= n; i++) {
            List<String> cur = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                List<String> str1 = dp.get(j);
                List<String> str2 = dp.get(i - 1 - j);
                for (String s1 : str1) {
                    for (String s2 : str2) {
                        // 枚举右括号的位置
                        cur.add("(" + s1 + ")" + s2);
                    }
                }
            }
            dp.add(cur);
        }
        return dp.get(n);
    }
}
```