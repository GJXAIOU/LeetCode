{"compress":true,"commitItems":[["fe7a84b4-c54c-4eb2-a131-e400cdab859b",1566913891153,"---\n\ntags: \n\n- 简单\n\n- 完成\n\n- 数组\n\n- 双指针\n\nflag: green\n\nstyle: summer\n\ndate: '2019-8-27'\n\n---",[[1566913848474,["GJX@GJXAIOU",[[-1,37,"\n"]],[37,37],[36,36]]],[1566913849338,["GJX@GJXAIOU",[[-1,24,"\n"]],[24,24],[23,23]]],[1566913849793,["GJX@GJXAIOU",[[-1,18,"\n"]],[18,18],[17,17]]],[1566913850251,["GJX@GJXAIOU",[[-1,12,"\n"]],[12,12],[11,11]]],[1566913850769,["GJX@GJXAIOU",[[-1,4,"\n"]],[4,4],[3,3]]],[1566913851497,["GJX@GJXAIOU",[[-1,26,"\n"]],[26,26],[25,25]]],[1566913852828,["GJX@GJXAIOU",[[-1,44,"\n"]],[44,44],[43,43]]],[1566913853425,["GJX@GJXAIOU",[[-1,58,"\n"]],[58,58],[57,57]]],[1566913854042,["GJX@GJXAIOU",[[-1,76,"\n"]],[76,76],[75,75]]],[1566913892220,["GJX@GJXAIOU",[[1,26,"\n"]],[25,25],[26,26]]],[1566913895167,["GJX@GJXAIOU",[[1,26,"- 排序"]],[26,26],[30,30]]],[1566913899322,["GJX@GJXAIOU",[[1,84,"\n\n"]],[84,84],[85,85]]],[1566913900290,["GJX@GJXAIOU",[[1,86,"\n"]],[85,85],[86,86]]],[1566913909403,["GJX@GJXAIOU",[[1,86,"# 75. yanse"]],[86,86],[97,97]]],[1566913910321,["GJX@GJXAIOU",[[-1,91," yanse"]],[97,97],[91,91]]],[1566913913877,["GJX@GJXAIOU",[[1,91," 颜色分类"]],[91,91],[96,96]]],[1566913914163,["GJX@GJXAIOU",[[1,97,"\n"]],[96,96],[97,97]]],[1566913924058,["GJX@GJXAIOU",[[1,98,"\n"]],[97,97],[98,98]]],[1566913924378,["GJX@GJXAIOU",[[1,98,"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意:\n不能使用代码库中的排序函数来解决这道题。\n\n示例:\n\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n进阶：\n\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sort-colors\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[98,98],[462,462]]],[1566913926353,["GJX@GJXAIOU",[[1,98,"\n"]],[97,97],[98,98]]],[1566913927627,["GJX@GJXAIOU",[[1,97,"## "]],[97,97],[100,100]]],[1566913929356,["GJX@GJXAIOU",[[1,100,"一"],[-1,119," "],[1,120," "],[-1,182," "],[1,183," "]],[100,100],[101,101]]],[1566913930948,["GJX@GJXAIOU",[[1,101,"、题目"]],[101,101],[104,104]]],[1566913933450,["GJX@GJXAIOU",[[1,97,"\n"]],[97,97],[98,98]]],[1566913935049,["GJX@GJXAIOU",[[-1,106,"\n"]],[106,106],[105,105]]],[1566913940315,["GJX@GJXAIOU",[[-1,238,"\n"]],[238,238],[237,237]]],[1566913942353,["GJX@GJXAIOU",[[1,234,"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意:\n不能使用代码库中的排序函数来解决这道题。\n\n"],[1,237,"\n\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n进阶：\n\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sort-colors\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[234,237],[598,598]]],[1566913943913,["GJX@GJXAIOU",[[-1,234,"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意:\n不能使用代码库中的排序函数来解决这道题。\n\n"],[-1,365,"\n\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n进阶：\n\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sort-colors\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[598,598],[234,237]]],[1566913945314,["GJX@GJXAIOU",[[1,234,"**"],[1,237,"**"]],[234,237],[234,241]]],[1566913964236,["GJX@GJXAIOU",[[1,208,"**"],[1,211,"**"]],[208,211],[208,215]]],[1566914332058,["GJX@GJXAIOU",[[-1,379,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sort-colors\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n"]],[378,477],[378,378]]],[1566914333330,["GJX@GJXAIOU",[[1,379,"\n"]],[378,378],[379,379]]],[1566914338175,["GJX@GJXAIOU",[[1,379,"## 二、题解"]],[379,379],[386,386]]],[1566914339394,["GJX@GJXAIOU",[[1,387,"\n"]],[386,386],[387,387]]],[1566914342106,["GJX@GJXAIOU",[[1,388,"\n"]],[387,387],[388,388]]],[1566914342749,["GJX@GJXAIOU",[[-1,388,"\n"],[1,389,"·"]],[388,388],[389,389]]],[1566914342997,["GJX@GJXAIOU",[[1,389,"·"]],[389,389],[390,390]]],[1566914343689,["GJX@GJXAIOU",[[-1,389,"·"]],[390,390],[389,389]]],[1566914344410,["GJX@GJXAIOU",[[1,389,"`"]],[389,389],[390,390]]],[1566914344923,["GJX@GJXAIOU",[[-1,389,"`"]],[390,390],[389,389]]],[1566914345082,["GJX@GJXAIOU",[[-1,388,"·"],[1,389,"\n"]],[389,389],[388,388]]],[1566914345523,["GJX@GJXAIOU",[[-1,388,"\n"],[1,389,"`"]],[388,388],[389,389]]],[1566914345877,["GJX@GJXAIOU",[[1,389,"``"]],[389,389],[391,391]]],[1566914345902,["GJX@GJXAIOU",[[1,391,"language\n```\n"]],[391,391],[391,399]]],[1566914346676,["GJX@GJXAIOU",[[-1,391,"language"],[1,399,"j"]],[391,399],[392,392]]],[1566914347021,["GJX@GJXAIOU",[[1,392,"ava"]],[392,392],[395,395]]],[1566914347123,["GJX@GJXAIOU",[[1,396,"\n"]],[395,395],[396,396]]],[1566914353943,["GJX@GJXAIOU",[[1,396,"/**\n* 空间复杂度：O(n)\n* 时间复杂度：O(1)\n* 仅仅遍历一次\n* @Author ：GJXAIOU\n*/\nclass Solution {\n    public void sortColors(int[] nums) {\n\n        // 表示 nums[0...zero] = 0\n        int zero = -1;\n        // 表示 nums[two...nums.length - 1] = 2\n        int two = nums.length;\n        \n        for(int i = 0; i < two; ){\n            // 新加入的元素为 1，则直接 i++\n            if(nums[i] == 1){\n                i++;\n                \n            // 新加入的元素为 2，则与 two-- 位置元素交换\n            }else if(nums[i] == 2){\n                two--;\n                int tmp = nums[i];\n                nums[i] = nums[two];\n                nums[two] = tmp;\n                \n            // 新加入的元素值为 0\n            }else{\n                zero++;\n                int tmp = nums[zero];\n                nums[zero] = nums[i];\n                nums[i] = tmp;\n                i++;\n            }\n        }        \n    }    \n}"]],[396,396],[1256,1256]]],[1566914458425,["GJX@GJXAIOU",[[1,388,"\n"]],[386,386],[387,387]]],[1566914458547,["GJX@GJXAIOU",[[1,389,"\n"]],[387,387],[388,388]]],[1566914459618,["GJX@GJXAIOU",[[1,388,"****"]],[388,388],[390,390]]],[1566914460700,["GJX@GJXAIOU",[[1,390,"timu"]],[390,390],[394,394]]],[1566914462225,["GJX@GJXAIOU",[[-1,390,"**timu"]],[394,394],[388,388]]],[1566914464089,["GJX@GJXAIOU",[[-1,388,"**"]],[390,390],[388,388]]],[1566914467682,["GJX@GJXAIOU",[[1,388,"### ()"]],[388,388],[394,394]]],[1566914469761,["GJX@GJXAIOU",[[-1,392,"()"]],[394,394],[392,392]]],[1566914470364,["GJX@GJXAIOU",[[1,392,"（）"]],[392,392],[394,394]]],[1566914471894,["GJX@GJXAIOU",[[1,393,"一"]],[393,393],[394,394]]],[1566914473701,["GJX@GJXAIOU",[[1,395,"思路"]],[395,395],[397,397]]],[1566914474049,["GJX@GJXAIOU",[[1,399,"\n"]],[397,397],[398,398]]],[1566914482547,["GJX@GJXAIOU",[[1,398,"结合三路快排 partition 思路的应用。\n\n设定两个索引，一个从左往右滑动`zero`，一个从右往左滑动`two`。\n\n*   遍历`nums`，当`nums[i]`的值为1时，`i++`；\n*   当`nums[i]`的值为2时，`two`的值先减1，而后交换`nums[i]`与`nums[two]`，此时在观察`nums[i]`的值；\n*   当`nums[i]`的值为0时，`zero++`，而后交换`nums[i]`与`nums[zero]`，`i++`;当 `i = two`时，结束循环。"]],[398,398],[652,652]]],[1566914484657,["GJX@GJXAIOU",[[-1,422,"\n"]],[422,422],[421,421]]],[1566914510761,["GJX@GJXAIOU",[[1,653,"\n"]],[652,652],[653,653]]],[1566914510881,["GJX@GJXAIOU",[[1,654,"\n"]],[653,653],[654,654]]],[1566914511002,["GJX@GJXAIOU",[[1,655,"\n"]],[654,654],[655,655]]],[1566914513909,["GJX@GJXAIOU",[[-1,634," "],[1,635," "],[1,654,"3"]],[654,654],[655,655]]],[1566914514987,["GJX@GJXAIOU",[[-1,654,"3"]],[655,655],[654,654]]],[1566914517331,["GJX@GJXAIOU",[[1,654,"### （）"]],[654,654],[660,660]]],[1566914519260,["GJX@GJXAIOU",[[1,659,"二"]],[659,659],[660,660]]],[1566914523748,["GJX@GJXAIOU",[[1,661,"动画"]],[661,661],[663,663]]],[1566914524394,["GJX@GJXAIOU",[[1,665,"\n"]],[663,663],[664,664]]],[1566914533081,["GJX@GJXAIOU",[[1,664,"![LeetCode75]($resource/LeetCode75.gif)"]],[664,664],[704,704]]]],null,"GJX@GJXAIOU"],["9467665f-a23b-4ad9-bc5e-26b955cf08de",1566970641047,"---\ntags: \n- 简单\n- 完成\n- 数组\n- 排序\n- 双指针\nflag: green\nstyle: summer\ndate: '2019-8-27'\n---\n\n# 75. 颜色分类\n\n## 一、题目\n给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n**注意:**\n不能使用代码库中的排序函数来解决这道题。\n\n**示例:**\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n进阶：\n\n一个直观的解决方案是使用计数排序的两趟扫描算法。\n首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n## 二、题解\n\n### （一）思路\n结合三路快排 partition 思路的应用。\n设定两个索引，一个从左往右滑动`zero`，一个从右往左滑动`two`。\n\n*   遍历`nums`，当`nums[i]`的值为1时，`i++`；\n*   当`nums[i]`的值为2时，`two`的值先减1，而后交换`nums[i]`与`nums[two]`，此时在观察`nums[i]`的值；\n*   当`nums[i]`的值为0时，`zero++`，而后交换`nums[i]`与`nums[zero]`，`i++`;当 `i = two`时，结束循环。\n\n\n### （二）动画\n![LeetCode75]($resource/LeetCode75.gif)\n\n```java\n/**\n* 空间复杂度：O(n)\n* 时间复杂度：O(1)\n* 仅仅遍历一次\n* @Author ：GJXAIOU\n*/\nclass Solution {\n    public void sortColors(int[] nums) {\n\n        // 表示 nums[0...zero] = 0\n        int zero = -1;\n        // 表示 nums[two...nums.length - 1] = 2\n        int two = nums.length;\n        \n        for(int i = 0; i < two; ){\n            // 新加入的元素为 1，则直接 i++\n            if(nums[i] == 1){\n                i++;\n                \n            // 新加入的元素为 2，则与 two-- 位置元素交换\n            }else if(nums[i] == 2){\n                two--;\n                int tmp = nums[i];\n                nums[i] = nums[two];\n                nums[two] = tmp;\n                \n            // 新加入的元素值为 0\n            }else{\n                zero++;\n                int tmp = nums[zero];\n                nums[zero] = nums[i];\n                nums[i] = tmp;\n                i++;\n            }\n        }        \n    }    \n}\n```\n",[[1566970628250,["GJX@GJXAIOU",[[1,705,"\n"]],[703,703],[704,704]]],[1566970628349,["GJX@GJXAIOU",[[1,706,"\n"]],[704,704],[705,705]]],[1566970628474,["GJX@GJXAIOU",[[1,707,"\n"]],[705,705],[706,706]]],[1566970636948,["GJX@GJXAIOU",[[1,706,"![LeetCode75动画]($resource/LeetCode75%E5%8A%A8%E7%94%BB.gif)"]],[706,706],[766,766]]]],null,"GJX@GJXAIOU"]]}