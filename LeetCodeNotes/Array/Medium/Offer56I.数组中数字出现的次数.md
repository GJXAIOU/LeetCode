---
layout:     post
title:      Offer56I. 数组中数字出现的次数
subtitle:   Array.medium
date:       2020-04-13
author:     GJXAIOU
header-img: img/post-bg-leetcode.png
catalog: true
tags:
    - 数组
	- 完成
---

# Offer56I. 数组中数字出现的次数

## 一、题目

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这**两个只出现一次的数字**。要求时间复杂度是O(n)，空间复杂度是O(1)。

**示例 1：**

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

**示例 2：**

```
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

 

**限制：**

- `2 <= nums <= 10000`

## 二、解答

### 方法一：HashMap：

代码省略

### ==方法二：位运算==

#### （一）异或知识补充

- 两个数字异或的结果 `a^b` 是将 a 和 b 的二进制每一位进行运算，得出的数字。 运算的逻辑是：如果同一位的数字相同则为 0，不同则为 1。

- **任何数和本身异或则为 0**

- **任何数和 0 异或是本身**

#### （二）解答过程 

**问题一**：本题如果是一个数组中除**一个数字只出现一次**外，其他数字都出现2次。那么如何找出这个只出现一次的数字？
答：由于一个数异或他本身等于0，那么将**这个数组中的数依次异或，最终就可以得到那个只出现一次的数。**

本例中，这个数组中有两个数字只出现一次，剩下的数字都是出现两次的。如何找到这两个只出现一次的数字。
答：同样将整个数组异或，异或之后，得到一个数字，这个数字从二进制数的角度看，一定有位数为 1。
这个 1 是怎么来的？就是那两个只出现一次的数字，异或得到的，他们对应的位不一样，肯定是一个数对应位数出现的是 0，另一个数字对应位置上出现的数字是1.据此，将这个数组分成两个部分。

- 一部分是，对应位置出现的数是 0 的数组
- 一部分是，对应位置出现的数是 1 的数组
    这样，整个数据就分成了两个数组，且这两个数组的特点是，数组中只有1个数只出现了一次。因此就可以求出那两个数字。


```java
package array.medium;

import java.util.Arrays;

/**
 * @author GJXAIOU
 * @create 2020/04/13 22:13
 */
public class Offer56I {
    public int[] singleNumbers(int[] nums) {
        // xorNumber为对整个数组求异或，用于求出分组条件。
        int xorNumber = nums[0];
        for (int k = 1; k < nums.length; k++) {
            xorNumber ^= nums[k];
        }

        // onePosition表示最低位1的位置的数，n&-n是求一个二进制数的最低位的1对应的数。（除其所在最低位为1，其他位为0的一个数）
        int onePosition = xorNumber & (-xorNumber);
        int ans1 = 0, ans2 = 0;
        // 最后利用onePosition作为划分条件，将数组分成两个数组，最终求得ans1与ans2的值。

        for (int i = 0; i < nums.length; i++) {
            if ((nums[i] & onePosition) == onePosition) {
                ans1 ^= nums[i];
            } else {
                ans2 ^= nums[i];
            }
        }
        //因为ans1与ans2的初始值为0，最终结果也应当异或一下0，不过由于0异或任何数都是，其本身，因此有没有都可以。
        return new int[]{ans1, ans2};
    }
}
```



**复杂度分析**

- 时间复杂度：O(N)，其中N为数组长度。
- 空间复杂度：O(1)

