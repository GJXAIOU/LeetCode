---
layout:     post
title:      110.平衡二叉树
subtitle:   Tree.easy
date:       2020-02-12
author:     GJXAIOU
header-img: img/post-bg-leetcode.png
catalog: true
tags:
    - 树
	- 深度优先搜索
	- 完成
---

# 110.平衡二叉树

## 一、题目

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

```java
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```java
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。



## 二、解答

方法一：自顶向下的递归
算法

定义方法height，用于计算任意一个节点  $p\in T$  的高度：

$\texttt{height}(p) = \begin{cases} -1 & p \text{ is an empty subtree i.e. } \texttt{null}\\ 1 + \max(\texttt{height}(p.left), \texttt{height}(p.right)) & \text{ otherwise} \end{cases}$
	

接下来就是比较每个节点左右子树的高度。在一棵以 r 为根节点的树 T 中，只有每个节点左右子树高度差不大于 1 时，该树才是平衡的。因此可以比较每个节点左右两棵子树的高度差，然后向上递归。

```java
package tree.easy;

/**
 * @Author GJXAIOU
 * @Date 2020/2/12 15:58
 */
public class LeetCode110 {
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    // 方法一：自顶向下的递归
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return (Math.abs(height(root.left) - height(root.right)) <= 1) && isBalanced(root.left) && isBalanced(root.right);
    }

    public int height(TreeNode root) {
        // 如果空树则高度为 -1
        if (root == null) {
            return -1;
        }
        // 以该结点为根的树的高度等于该结点 + 左右树中最高的那个
        return 1 + Math.max(height(root.left), height(root.right));
    }
}

```

复杂度分析

- 时间复杂度：O(nlogn)。

    - 对于每个深度为 d 的节点 p，height(p) 被调用 p 次。

    - 首先，需要知道一棵平衡二叉树可以拥有的节点数量。令 f(h) 表示一棵高度为 h 的平衡二叉树需要的最少节点数量。

        f(h) = f(h - 1) + f(h - 2) + 1

        这与斐波那契数列的递归关系几乎相同。实际上，它的复杂度分析方法也和斐波那契数列一样。f(h) 的下界是 $f(h) = \Omega\left(\left(\frac{3}{2}\right)^h\right)$。

        $\begin{align} f(h+1) &= f(h) + f(h-1) + 1 \\ &> f(h) + f(h-1) & \qquad\qquad \text{This is the fibonacci sequence}\\ &\geq \left(\frac{3}{2}\right)^{h} + \left(\frac{3}{2}\right)^{h-1} & \text{via our claim} \\ &= \frac{5}{2} \left(\frac{3}{2}\right)^{h-1}\\ &> \frac{9}{4} \left(\frac{3}{2}\right)^{h-1} & \frac{9}{4} < \frac{5}{2}\\ &> \left(\frac{3}{2}\right)^{h+1} \end{align}$

    因此，平衡二叉树的高度 hh 不大于 $\mathcal{O}(\log_{1.5}(n))$。有了这个限制，可以保证方法 height 在每个节点上调用不超过 O(logn) 次。

    - 如果树是倾斜的，高度达到 $\mathcal{O}(n)$，算法没有尽早结束，最终会达到 $\mathcal{O}(n^2)$ 的复杂度。
        但是请注意：只要有子节点的两棵子树高度差大于 1，就会停止递归。实际上，如果树是完全倾斜的，仅需要检查最开始的两棵子树。

- 空间复杂度：O(n)。如果树完全倾斜，递归栈可能包含所有节点。

一个有趣的事实：$f( n ) = f(n − 1) + f(n − 2) + 1$ 被称为斐波那契数列。

代码形式二：

```java
package tree.easy;

import javax.xml.stream.FactoryConfigurationError;

/**
 * @Author GJXAIOU
 * @Date 2020/2/12 15:58
 */
public class LeetCode110 {
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    // 自顶向下递归写法二：解释将 AlgorithmNotes 笔记
    public boolean isBalanced2(TreeNode root) {
        boolean[] res = new boolean[1];
        res[0] = true;
        getHeight(root, 1, res);
        return res[0];

    }

    public int getHeight(TreeNode root, int level, boolean[] res) {
        if (root == null) {
            return level;
        }

        int leftHeight = getHeight(root.left, level + 1, res);
        if (!res[0]) {
            return level;
        }
        int rightHeight = getHeight(root.right, level + 1, res);
        if (!res[0]) {
            return level;
        }
        if (Math.abs(leftHeight - rightHeight) > 1) {
            res[0] = false;
        }
        return Math.max(leftHeight, rightHeight);

    }
}
```



**方法二：自底向上的递归**
思路

方法一计算 height 存在大量冗余。每次调用 height 时，要同时计算其子树高度。但是自底向上计算，每个子树的高度只会计算一次。可以递归先计算当前节点的子节点高度，然后再通过子节点高度判断当前节点是否平衡，从而消除冗余。

算法

使用与方法一中定义的 height 方法。自底向上与自顶向下的逻辑相反，首先判断子树是否平衡，然后比较子树高度判断父节点是否平衡。算法如下：

> 检查子树是否平衡。如果平衡，则使用它们的高度判断父节点是否平衡，并计算父节点的高度。

```java
package tree.easy;

/**
 * @Author GJXAIOU
 * @Date 2020/2/12 15:58
 */
public class LeetCode110 {
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    // 方法二：自底向上的递归
// Utility class to store information from recursive calls
    final class TreeInfo {
        public final int height;
        public final boolean balanced;

        public TreeInfo(int height, boolean balanced) {
            this.height = height;
            this.balanced = balanced;
        }
    }

    class Solution {
        // Return whether or not the tree at root is balanced while also storing
        // the tree's height in a reference variable.
        private TreeInfo isBalancedTreeHelper(TreeNode root) {
            // An empty tree is balanced and has height = -1
            if (root == null) {
                return new TreeInfo(-1, true);
            }

            // Check subtrees to see if they are balanced.
            TreeInfo left = isBalancedTreeHelper(root.left);
            if (!left.balanced) {
                return new TreeInfo(-1, false);
            }
            TreeInfo right = isBalancedTreeHelper(root.right);
            if (!right.balanced) {
                return new TreeInfo(-1, false);
            }

            // Use the height obtained from the recursive calls to
            // determine if the current node is also balanced.
            if (Math.abs(left.height - right.height) < 2) {
                return new TreeInfo(Math.max(left.height, right.height) + 1, true);
            }
            return new TreeInfo(-1, false);
        }

        public boolean isBalanced(TreeNode root) {
            return isBalancedTreeHelper(root).balanced;
        }
    }

}
```

- 复杂度分析
    - 时间复杂度：O(n)，计算每棵子树的高度和判断平衡操作都在恒定时间内完成。
    - 空间复杂度：O(n)，如果树不平衡，递归栈可能达到 O(n)。

