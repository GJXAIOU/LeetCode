{"compress":true,"commitItems":[["3c34b820-4f9a-478b-a395-d6b9e7377161",1567344810356,"",[[1567344752408,["GJX@GJXAIOU",[[1,0,"# 438. 找到字符串中所有字母异位词\n\n\n\n"]],[0,0],[23,23]]],[1567344760046,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1567344761296,["GJX@GJXAIOU",[[1,0,"---\ntags: \n- 简单\n- 完成\n- 字符串\n- 双指针\nflag: green\nstyle: summer\ndate: '2019-8-28'\n---"]],[0,0],[80,80]]],[1567345195157,["GJX@GJXAIOU",[[1,104,"## yi "]],[104,104],[110,110]]],[1567345195693,["GJX@GJXAIOU",[[-1,107,"yi "]],[110,110],[107,107]]],[1567345197624,["GJX@GJXAIOU",[[1,107,"一、题目"]],[107,107],[111,111]]],[1567345197840,["GJX@GJXAIOU",[[1,112,"\n"]],[111,111],[112,112]]],[1567345197935,["GJX@GJXAIOU",[[1,113,"\n"]],[112,112],[113,113]]],[1567345198065,["GJX@GJXAIOU",[[1,114,"\n"]],[113,113],[114,114]]],[1567345198172,["GJX@GJXAIOU",[[1,115,"\n"]],[114,114],[115,115]]],[1567345198294,["GJX@GJXAIOU",[[1,116,"\n"]],[115,115],[116,116]]],[1567345201418,["GJX@GJXAIOU",[[1,116,"## 二、解答"]],[116,116],[123,123]]],[1567345203646,["GJX@GJXAIOU",[[1,113,"给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。\n\n说明：\n\n字母异位词指字母相同，但排列不同的字符串。\n不考虑答案输出的顺序。\n示例 1:\n\n输入:\ns: \"cbaebabacd\" p: \"abc\"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。\n 示例 2:\n\n输入:\ns: \"abab\" p: \"ab\"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[113,113],[654,654]]],[1567345233871,["GJX@GJXAIOU",[[1,173,"**"],[1,182,"**"]],[173,182],[173,186]]],[1567345235925,["GJX@GJXAIOU",[[-1,219,"\n"]],[219,219],[218,218]]],[1567345241500,["GJX@GJXAIOU",[[1,253,"\n"]],[253,253],[254,254]]],[1567345242719,["GJX@GJXAIOU",[[-1,260,"\n"]],[260,260],[259,259]]],[1567345244694,["GJX@GJXAIOU",[[-1,289,"\n"]],[289,289],[288,288]]],[1567345245652,["GJX@GJXAIOU",[[-1,300,"\n"]],[300,300],[299,299]]],[1567345248117,["GJX@GJXAIOU",[[1,381,"\n "]],[381,381],[383,383]]],[1567345249165,["GJX@GJXAIOU",[[-1,389,"\n"]],[389,389],[388,388]]],[1567345251038,["GJX@GJXAIOU",[[-1,382," "]],[382,383],[382,382]]],[1567345251703,["GJX@GJXAIOU",[[-1,120," s "],[1,123," s "],[-1,131," "],[1,132," "],[-1,136," s "],[1,139," s "],[-1,143," p "],[1,146," p "],[-1,192," s 和 p "],[1,199," s 和 p "],[-1,256," "],[1,257," "],[-1,380," \n"],[1,382," \n-"]],[382,382],[383,383]]],[1567345252249,["GJX@GJXAIOU",[[1,383," "]],[383,383],[384,384]]],[1567345254297,["GJX@GJXAIOU",[[1,254,"- "]],[254,254],[256,256]]],[1567345256609,["GJX@GJXAIOU",[[1,215,"- "]],[215,215],[217,217]]],[1567345259285,["GJX@GJXAIOU",[[-1,416,"\n"]],[416,416],[415,415]]],[1567345261530,["GJX@GJXAIOU",[[1,431,"- "]],[431,431],[433,433]]],[1567345269093,["GJX@GJXAIOU",[[-1,546,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[546,662],[546,546]]],[1567345270614,["GJX@GJXAIOU",[[-1,548,"\n"]],[547,547],[546,546]]],[1567345270749,["GJX@GJXAIOU",[[-1,547,"\n"]],[546,546],[545,545]]],[1567345732118,["GJX@GJXAIOU",[[1,555,"\n"]],[554,554],[555,555]]],[1567345732248,["GJX@GJXAIOU",[[1,556,"\n"]],[555,555],[556,556]]],[1567345732365,["GJX@GJXAIOU",[[1,557,"\n"]],[556,556],[557,557]]],[1567345733583,["GJX@GJXAIOU",[[-1,557,"\n"],[1,558,"-"]],[557,557],[558,558]]],[1567345735302,["GJX@GJXAIOU",[[1,558," 准备工作：\n\n 1. 设置两个指针 起始坐标start=0，一个结束坐标end=0\n\n  2. 建立两个长度为26的int数组，p_letter记录p里面的字母分别都有多少个，between_letter记录两个指针中的字母分别都有多少个\n正式开始：\n\n1. 做一个循环，start先不动，拿到end指针对应的字母，between_letter中字母对应的数量加1，并让end自增\n2. 判断一下，这个字母的数字是不是比p_letter要多了，如果是，表示出现了下面两种情况中的一种\n     1.start到end中的字母数量比p的length大,那么肯定至少会有一个字母的数量比p_letter里多\n     2.start到end的距离小于等于p的length，但是里面的某一个字母比p多\n     不管是上述情况中哪一种，start都应该前进，直到这个字母的数量等于p中的字母数量。（做完这一步start和end之间的字母数量一定小于等于p的length）\n\n3. 然后再判断一下，start和end之间的字母数量是不是等于p的length。如果是，表示两个坐标之间的字母和p的字母构成一样\n     因为第二步中，一出现start和end之间的字母比p多，我们就让start前进，直到这个字母数量等于p里面的数量，确保了没有任何一个字母比p里面多\n     当start和end之间的字母数量和p里面的一样，且start和end之间没有任何一个字母比p多，就说明他们的字母组成一模一样\n    （因为数量一样的情况下，如果出现某个字母比p少，就一定会有另外一个字母比p多，这是充要条件）\npublic List<Integer> findAnagrams(String s, String p) {\n            List<Integer> result = new ArrayList<>();\n            int[] p_letter = new int[26];\n            for (int i = 0; i < p.length(); i++) {//记录p里面的数字分别有几个\n                p_letter[p.charAt(i) - 'a']++;\n            }\n            int start = 0;\n            int end = 0;\n            int[] between_letter = new int[26];//记录两个指针之间的数字都有几个\n            while (end < s.length()) {\n                int c = s.charAt(end++) - 'a';//每一次拿到end指针对应的字母\n                between_letter[c]++;//让这个字母的数量+1\n                \n                //如果这个字母的数量比p里面多了,说明这个start坐标需要排除\n                while (between_letter[c] > p_letter[c]) {\n                    between_letter[s.charAt(start++) - 'a']--;\n                }\n                if (end - start == p.length()) {\n                    result.add(start);\n                }\n            }\n            return result;\n        }        \n\n作者：bugFactor\n链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/shuang-zhi-zhen-hua-kuai-by-mr_tao/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[558,558],[2352,2352]]],[1567345739684,["GJX@GJXAIOU",[[-1,602,"  "]],[602,604],[602,602]]],[1567345743512,["GJX@GJXAIOU",[[-1,566," "]],[567,567],[566,566]]],[1567345758685,["GJX@GJXAIOU",[[-1,600,"\n"]],[600,600],[599,599]]],[1567345900285,["GJX@GJXAIOU",[[1,1254,"    \n"]],[1253,1253],[1258,1258]]],[1567345901202,["GJX@GJXAIOU",[[1,1258,"·"]],[1258,1258],[1259,1259]]],[1567345903373,["GJX@GJXAIOU",[[-1,1255,"   ·"]],[1259,1259],[1255,1255]]],[1567345906169,["GJX@GJXAIOU",[[1,1255,"```java"]],[1255,1255],[1262,1262]]],[1567345908775,["GJX@GJXAIOU",[[-1,1254," "]],[1254,1255],[1254,1254]]],[1567345911873,["GJX@GJXAIOU",[[1,2181,"```"]],[2181,2181],[2184,2184]]],[1567345920061,["GJX@GJXAIOU",[[1,675,"\n"]],[675,675],[676,676]]],[1567346261686,["GJX@GJXAIOU",[[-1,1466,"/记录p里面的数字分别有几个"]],[1466,1480],[1466,1466]]],[1567346263845,["GJX@GJXAIOU",[[1,1427,"\n            "]],[1414,1414],[1427,1427]]],[1567346264268,["GJX@GJXAIOU",[[1,1427,"/记录p里面的数字分别有几个"]],[1427,1427],[1441,1441]]],[1567346266021,["GJX@GJXAIOU",[[-1,1492,"/"]],[1493,1493],[1492,1492]]],[1567346270167,["GJX@GJXAIOU",[[1,1428,"/"]],[1427,1427],[1428,1428]]],[1567346270197,["GJX@GJXAIOU",[[1,1428,"."]],[1428,1428],[1429,1429]]],[1567346270796,["GJX@GJXAIOU",[[-1,1428,"."]],[1429,1429],[1428,1428]]],[1567346271826,["GJX@GJXAIOU",[[1,1429," "]],[1429,1429],[1430,1430]]],[1567346274199,["GJX@GJXAIOU",[[-1,1436,"数字"]],[1438,1438],[1436,1436]]],[1567346275185,["GJX@GJXAIOU",[[1,1436,"zimu"]],[1436,1436],[1440,1440]]],[1567346275845,["GJX@GJXAIOU",[[-1,1436,"zimu"]],[1440,1440],[1436,1436]]],[1567346277857,["GJX@GJXAIOU",[[1,1436,"字母 "]],[1436,1436],[1439,1439]]],[1567346279285,["GJX@GJXAIOU",[[-1,1438," "]],[1439,1439],[1438,1438]]],[1567346281545,["GJX@GJXAIOU",[[1,1433," "]],[1433,1433],[1434,1434]]],[1567346282222,["GJX@GJXAIOU",[[1,1432," "]],[1432,1432],[1433,1433]]],[1567346315662,["GJX@GJXAIOU",[[1,1570,"\n            "]],[1557,1557],[1570,1570]]],[1567346356888,["GJX@GJXAIOU",[[-1,1763,"++"]],[1765,1765],[1763,1763]]],[1567346366672,["GJX@GJXAIOU",[[-1,1771,"//每一次拿到end指针对应的字母"]],[1771,1788],[1771,1771]]],[1567346367909,["GJX@GJXAIOU",[[1,1739,"\n            "]],[1726,1726],[1739,1739]]],[1567346368350,["GJX@GJXAIOU",[[1,1739,"//每一次拿到end指针对应的字母"]],[1739,1739],[1756,1756]]],[1567346370329,["GJX@GJXAIOU",[[1,1739,"  "]],[1739,1739],[1741,1741]]],[1567346370727,["GJX@GJXAIOU",[[1,1741,"  "]],[1741,1741],[1743,1743]]],[1567346372188,["GJX@GJXAIOU",[[1,1822,"\n                "]],[1805,1805],[1822,1822]]],[1567346375863,["GJX@GJXAIOU",[[1,1822,"end++;"]],[1822,1822],[1828,1828]]]],null,"GJX@GJXAIOU"]]}