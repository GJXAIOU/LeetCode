{"compress":true,"commitItems":[["93d73abf-8247-4918-b2de-6248845b791e",1559891437735,"",[[1559891395682,["GJX@GJXAIOU",[[1,0,"# 7.合并两个有序链表\n\n\n\n"]],[0,0],[15,15]]],[1559891398429,["GJX@GJXAIOU",[[1,0,"\n"]],[0,0],[1,1]]],[1559891398564,["GJX@GJXAIOU",[[1,0,"\n"]],[1,1],[2,2]]],[1559891398693,["GJX@GJXAIOU",[[1,2,"\n"]],[2,2],[3,3]]],[1559891401781,["GJX@GJXAIOU",[[1,0,"-"]],[0,0],[1,1]]],[1559891401919,["GJX@GJXAIOU",[[1,0,"-"]],[1,1],[2,2]]],[1559891402069,["GJX@GJXAIOU",[[1,2,"-"]],[2,2],[3,3]]],[1559891402091,["GJX@GJXAIOU",[[1,5,"---\n\n\n"]],[3,3],[4,4]]],[1559891403806,["GJX@GJXAIOU",[[1,4,"tao"]],[4,4],[7,7]]],[1559891404527,["GJX@GJXAIOU",[[-1,6,"o"]],[7,7],[6,6]]],[1559891406671,["GJX@GJXAIOU",[[1,6,"gs: "]],[6,6],[10,10]]],[1559891407687,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1559891408741,["GJX@GJXAIOU",[[1,11," "]],[11,11],[12,12]]],[1559891409566,["GJX@GJXAIOU",[[-1,11," "]],[12,12],[11,11]]],[1559891411863,["GJX@GJXAIOU",[[1,11,"  - xian"]],[11,11],[19,19]]],[1559891413141,["GJX@GJXAIOU",[[-1,15,"xian"]],[19,19],[15,15]]],[1559891415822,["GJX@GJXAIOU",[[1,15,"线性表"]],[15,15],[18,18]]],[1559891416410,["GJX@GJXAIOU",[[1,19,"  \n"]],[18,18],[21,21]]],[1559891420842,["GJX@GJXAIOU",[[1,21,"- 单链表"]],[21,21],[26,26]]],[1559891423661,["GJX@GJXAIOU",[[1,27,"  \n"]],[26,26],[29,29]]],[1559891429737,["GJX@GJXAIOU",[[1,29,"- 链表合并"]],[29,29],[35,35]]],[1559891433445,["GJX@GJXAIOU",[[1,36,"  \n"]],[35,35],[38,38]]],[1559891433576,["GJX@GJXAIOU",[[-1,36,"  "],[1,38,"\n"]],[38,38],[37,37]]],[1559891435408,["GJX@GJXAIOU",[[1,37,"g"]],[37,37],[38,38]]],[1559891435941,["GJX@GJXAIOU",[[-1,37,"g"]],[38,38],[37,37]]],[1559891437143,["GJX@GJXAIOU",[[1,37,"flag"]],[37,37],[41,41]]],[1559891443813,["GJX@GJXAIOU",[[1,41,": green"]],[41,41],[48,48]]],[1559891444751,["GJX@GJXAIOU",[[1,49,"\n"]],[48,48],[49,49]]],[1559891445461,["GJX@GJXAIOU",[[1,50,"\n"]],[49,49],[50,50]]],[1559891447798,["GJX@GJXAIOU",[[1,50,"fata"]],[50,50],[54,54]]],[1559891448670,["GJX@GJXAIOU",[[-1,50,"fata"]],[54,54],[50,50]]],[1559891450391,["GJX@GJXAIOU",[[1,50,"data "]],[50,50],[55,55]]],[1559891451301,["GJX@GJXAIOU",[[-1,54," "]],[55,55],[54,54]]],[1559891464957,["GJX@GJXAIOU",[[1,54,":'2019-6-7'"]],[54,54],[65,65]]],[1559891497477,["GJX@GJXAIOU",[[1,88,"## "]],[88,88],[91,91]]],[1559891498725,["GJX@GJXAIOU",[[1,91,"er"]],[91,91],[93,93]]],[1559891499269,["GJX@GJXAIOU",[[-1,91,"er"]],[93,93],[91,91]]],[1559891503442,["GJX@GJXAIOU",[[1,91,"一、题目"]],[91,91],[95,95]]],[1559891504206,["GJX@GJXAIOU",[[1,96,"\n"]],[95,95],[96,96]]],[1559891504337,["GJX@GJXAIOU",[[1,97,"\n"]],[96,96],[97,97]]],[1559891504452,["GJX@GJXAIOU",[[1,98,"\n"]],[97,97],[98,98]]],[1559891504571,["GJX@GJXAIOU",[[1,99,"\n"]],[98,98],[99,99]]],[1559891504688,["GJX@GJXAIOU",[[1,100,"\n"]],[99,99],[100,100]]],[1559891504807,["GJX@GJXAIOU",[[1,101,"\n"]],[100,100],[101,101]]],[1559891512846,["GJX@GJXAIOU",[[1,101,"## 二、解答"]],[101,101],[108,108]]],[1559891513229,["GJX@GJXAIOU",[[1,109,"\n"]],[108,108],[109,109]]],[1559891513364,["GJX@GJXAIOU",[[1,110,"\n"]],[109,109],[110,110]]],[1559891515068,["GJX@GJXAIOU",[[1,111,"\n"]],[110,110],[111,111]]],[1559891515191,["GJX@GJXAIOU",[[1,112,"\n"]],[111,111],[112,112]]],[1559891515301,["GJX@GJXAIOU",[[1,113,"\n"]],[112,112],[113,113]]],[1559891515420,["GJX@GJXAIOU",[[1,114,"\n"]],[113,113],[114,114]]],[1559891515540,["GJX@GJXAIOU",[[1,115,"\n"]],[114,114],[115,115]]],[1559891515672,["GJX@GJXAIOU",[[1,116,"\n"]],[115,115],[116,116]]],[1559891515796,["GJX@GJXAIOU",[[1,117,"\n"]],[116,116],[117,117]]],[1559891515929,["GJX@GJXAIOU",[[1,118,"\n"]],[117,117],[118,118]]],[1559891516053,["GJX@GJXAIOU",[[1,119,"\n"]],[118,118],[119,119]]],[1559891516189,["GJX@GJXAIOU",[[1,120,"\n"]],[119,119],[120,120]]],[1559891516300,["GJX@GJXAIOU",[[1,121,"\n"]],[120,120],[121,121]]],[1559891518334,["GJX@GJXAIOU",[[-1,121,"\n"],[1,122,"`"]],[121,121],[122,122]]],[1559891518678,["GJX@GJXAIOU",[[1,122,"``"]],[122,122],[124,124]]],[1559891518701,["GJX@GJXAIOU",[[1,124,"language\n```\n"]],[124,124],[124,132]]],[1559891519920,["GJX@GJXAIOU",[[-1,124,"language"],[1,132,"j"]],[124,132],[125,125]]],[1559891520318,["GJX@GJXAIOU",[[1,125,"ava"]],[125,125],[128,128]]],[1559891528773,["GJX@GJXAIOU",[[1,120,"- gere"]],[120,120],[126,126]]],[1559891529862,["GJX@GJXAIOU",[[-1,122,"gere"]],[126,126],[122,122]]],[1559891533065,["GJX@GJXAIOU",[[1,122,"个人解法"]],[122,122],[126,126]]],[1559891535093,["GJX@GJXAIOU",[[1,135,"\n"]],[134,134],[135,135]]],[1559891535213,["GJX@GJXAIOU",[[1,136,"\n"]],[135,135],[136,136]]],[1559891568301,["GJX@GJXAIOU",[[1,135,"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode rspHead = new ListNode(0);\n        ListNode rsp = rspHead;\n\n        while(l1 != null && l2 != null){\n        \tif (l1.val < l2.val) {\n        \t\trspHead.next = l1;\n        \t\tl1 = l1.next;\n        \t}else{\n        \t\trspHead.next = l2;\n        \t\tl2 = l2.next;\n        \t}\n        \trspHead = rspHead.next;\n\n        }\n        \n        //当l1为空的况就是，l1链表中最后一个元素是小于l2中最后一个元素，\n        //所以当l1取完之后，实际上l2还剩下最后一个元素，因此指向l2\n        if (l1 == null) {\n        \trspHead.next = l2;\n        }else{\n        \trspHead.next = l1;\n        }\n\n        return rsp.next;\n    }\n}"]],[135,135],[929,929]]],[1559891588407,["GJX@GJXAIOU",[[1,101,"\n"]],[96,96],[97,97]]],[1559891588871,["GJX@GJXAIOU",[[1,97,"将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n示例：\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/merge-two-sorted-lists\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[97,97],[301,301]]],[1559891592208,["GJX@GJXAIOU",[[-1,143," "],[1,144," "],[1,154,"·"]],[154,154],[155,155]]],[1559891593483,["GJX@GJXAIOU",[[-1,154,"·"]],[155,155],[154,154]]],[1559891595941,["GJX@GJXAIOU",[[1,154,"`"]],[154,154],[155,155]]],[1559891597222,["GJX@GJXAIOU",[[1,175,"`"]],[175,175],[176,176]]],[1559891599101,["GJX@GJXAIOU",[[1,171,"`"]],[171,171],[172,172]]],[1559891599765,["GJX@GJXAIOU",[[1,193,"`"]],[193,193],[194,194]]],[1559891604270,["GJX@GJXAIOU",[[-1,196,"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/merge-two-sorted-lists\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。"]],[196,305],[196,196]]],[1559891622661,["GJX@GJXAIOU",[[1,210,"方法 1：递归\n想法\n\n我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：\n\n\\left\\{ \\begin{array}{ll} list1[0] + merge(list1[1:], list2) & list1[0] < list2[0] \\\\ list2[0] + merge(list1, list2[1:]) & otherwise \\end{array} \\right.\n{ \nlist1[0]+merge(list1[1:],list2)\nlist2[0]+merge(list1,list2[1:])\n​\t\n  \nlist1[0]<list2[0]\notherwise\n​\t\n \n\n也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。\n\n算法 我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。\n\nJavaPython\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n\n    }\n}\n复杂度分析\n\n时间复杂度：O(n + m)O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。\n\n空间复杂度：O(n + m)O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + mn+m 个栈帧会消耗 O(n + m)O(n+m) 的空间。\n\n方法 2：迭代\n想法\n\n我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。\n\n算法\n\n首先，我们设定一个哨兵节点 \"prehead\" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。\n\n在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。\n\n\n1 / 35\nJavaPython\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        ListNode prehead = new ListNode(-1);\n\n        ListNode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n\n        return prehead.next;\n    }\n}\n复杂度分析\n\n时间复杂度：O(n + m)O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。\n\n空间复杂度：O(1)O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[210,210],[2906,2906]]],[1559891629361,["GJX@GJXAIOU",[[1,210,"**"],[1,217,"**"]],[210,217],[210,221]]],[1559891631204,["GJX@GJXAIOU",[[1,222,"**"],[1,224,"**"]],[222,224],[222,228]]],[1559891637422,["GJX@GJXAIOU",[[1,275,"$"]],[275,275],[276,276]]],[1559891656093,["GJX@GJXAIOU",[[1,275,"#### "]],[428,428],[433,433]]],[1559891661646,["GJX@GJXAIOU",[[1,433,"$"]],[433,433],[434,434]]],[1559891667213,["GJX@GJXAIOU",[[-1,435,"{ \nlist1[0]+merge(list1[1:],list2)\nlist2[0]+merge(list1,list2[1:])"]],[435,501],[435,435]]],[1559891669493,["GJX@GJXAIOU",[[-1,275,"#### "]],[275,280],[275,275]]],[1559891679380,["GJX@GJXAIOU",[[-1,431,"​\t\n  \nlist1[0]<list2[0]\notherwise\n​\t\n"]],[430,467],[430,430]]],[1559891680596,["GJX@GJXAIOU",[[-1,433,"\n"]],[433,433],[432,432]]],[1559891680804,["GJX@GJXAIOU",[[-1,431," "]],[432,432],[431,431]]],[1559891681188,["GJX@GJXAIOU",[[-1,431,"\n"]],[431,431],[430,430]]],[1559891681575,["GJX@GJXAIOU",[[-1,430,"\n"]],[430,430],[429,429]]],[1559891686854,["GJX@GJXAIOU",[[1,453,"`"]],[453,453],[454,454]]],[1559891688230,["GJX@GJXAIOU",[[1,459,"`"]],[459,459],[460,460]]],[1559891692429,["GJX@GJXAIOU",[[1,470,"**"],[1,472,"**"]],[470,472],[470,476]]],[1559891694229,["GJX@GJXAIOU",[[1,477,"\n"]],[477,477],[478,478]]],[1559891699720,["GJX@GJXAIOU",[[1,509,"`"]],[509,509],[510,510]]],[1559891700350,["GJX@GJXAIOU",[[1,512,"`"]],[512,512],[513,513]]],[1559891703040,["GJX@GJXAIOU",[[1,517,"`"]],[517,517],[518,518]]],[1559891704094,["GJX@GJXAIOU",[[1,520,"`"]],[520,520],[521,521]]],[1559891705494,["GJX@GJXAIOU",[[1,528,"`"]],[528,528],[529,529]]],[1559891706550,["GJX@GJXAIOU",[[1,533,"`"]],[533,533],[534,534]]],[1559891709693,["GJX@GJXAIOU",[[1,572,"`"]],[572,572],[573,573]]],[1559891710790,["GJX@GJXAIOU",[[1,575,"`"]],[575,575],[576,576]]],[1559891712157,["GJX@GJXAIOU",[[1,579,"`"]],[579,579],[580,580]]],[1559891712854,["GJX@GJXAIOU",[[1,582,"`"]],[582,582],[583,583]]],[1559891719023,["GJX@GJXAIOU",[[1,647,"`"],[1,657,"`"]],[647,657],[647,659]]],[1559891719194,["GJX@GJXAIOU",[[-1,647,"`"],[-1,658,"`"]],[647,659],[647,657]]],[1559891719359,["GJX@GJXAIOU",[[1,647,"`"],[1,657,"`"]],[647,657],[647,659]]],[1559891721187,["GJX@GJXAIOU",[[-1,647,"`"],[-1,658,"`"]],[647,659],[647,657]]],[1559891721405,["GJX@GJXAIOU",[[1,647,"`"],[1,657,"`"]],[647,657],[647,659]]],[1559891722695,["GJX@GJXAIOU",[[-1,647,"`JavaPython`"]],[647,659],[647,647]]],[1559891724912,["GJX@GJXAIOU",[[1,647,"```java"]],[647,647],[654,654]]],[1559891727909,["GJX@GJXAIOU",[[1,1083,"\n"]],[1082,1082],[1083,1083]]],[1559891729005,["GJX@GJXAIOU",[[1,1083,"```"]],[1083,1083],[1086,1086]]],[1559891736015,["GJX@GJXAIOU",[[1,1087,"**"],[1,1092,"**"]],[1087,1092],[1087,1096]]],[1559891737862,["GJX@GJXAIOU",[[1,1087,"\n"]],[1086,1086],[1087,1087]]],[1559891741935,["GJX@GJXAIOU",[[1,1105,"`"],[1,1113,"`"]],[1105,1113],[1105,1115]]],[1559891747645,["GJX@GJXAIOU",[[-1,1115,"O(n+m)"]],[1115,1121],[1115,1115]]],[1559891753654,["GJX@GJXAIOU",[[1,1160,"`"]],[1160,1160],[1161,1161]]],[1559891756141,["GJX@GJXAIOU",[[1,1174,"`"]],[1174,1174],[1175,1175]]],[1559891760602,["GJX@GJXAIOU",[[-1,1221," + m)O(n"]],[1218,1226],[1218,1218]]],[1559891760782,["GJX@GJXAIOU",[[1,1218,"`"]],[1218,1218],[1219,1219]]],[1559891762632,["GJX@GJXAIOU",[[1,1225,"`"]],[1225,1225],[1226,1226]]],[1559891765189,["GJX@GJXAIOU",[[1,1099,"- "]],[1099,1099],[1101,1101]]],[1559891767200,["GJX@GJXAIOU",[[1,1214,"- "]],[1214,1214],[1216,1216]]],[1559891772521,["GJX@GJXAIOU",[[-1,1284,"n+m "]],[1284,1288],[1284,1284]]],[1559891775837,["GJX@GJXAIOU",[[-1,1299,"O(n+m)"]],[1299,1305],[1299,1299]]],[1559891788711,["GJX@GJXAIOU",[[1,1306,"**"],[1,1313,"**"]],[1306,1313],[1306,1317]]],[1559891790317,["GJX@GJXAIOU",[[1,1306,"\n"]],[1305,1305],[1306,1306]]],[1559891790455,["GJX@GJXAIOU",[[1,1307,"\n"]],[1306,1306],[1307,1307]]],[1559891790603,["GJX@GJXAIOU",[[1,1308,"\n"]],[1307,1307],[1308,1308]]],[1559891790693,["GJX@GJXAIOU",[[1,1309,"\n"]],[1308,1308],[1309,1309]]],[1559891793014,["GJX@GJXAIOU",[[1,1322,"**"],[1,1324,"**"]],[1322,1324],[1322,1328]]],[1559891797473,["GJX@GJXAIOU",[[1,1398,"**"],[1,1400,"**"]],[1398,1400],[1398,1404]]],[1559891800719,["GJX@GJXAIOU",[[1,1322,"\n"]],[1322,1322],[1323,1323]]],[1559891816623,["GJX@GJXAIOU",[[1,1758,"\n"]],[1756,1756],[1757,1757]]],[1559891816757,["GJX@GJXAIOU",[[1,1759,"\n"]],[1757,1757],[1758,1758]]],[1559891816879,["GJX@GJXAIOU",[[1,1760,"\n"]],[1758,1758],[1759,1759]]],[1559891822837,["GJX@GJXAIOU",[[-1,1761,"1 / 35\nJavaPython"]],[1761,1778],[1761,1761]]],[1559891826578,["GJX@GJXAIOU",[[1,1761,"```jAVA"]],[1761,1761],[1768,1768]]],[1559891828202,["GJX@GJXAIOU",[[-1,1765,"AVA"]],[1768,1768],[1765,1765]]],[1559891829673,["GJX@GJXAIOU",[[1,1765,"ava"]],[1765,1765],[1768,1768]]],[1559891833390,["GJX@GJXAIOU",[[1,2502,"\n"]],[2501,2501],[2502,2502]]],[1559891833531,["GJX@GJXAIOU",[[1,2503,"\n"]],[2502,2502],[2503,2503]]],[1559891834439,["GJX@GJXAIOU",[[1,2503,"```"]],[2503,2503],[2506,2506]]],[1559891836127,["GJX@GJXAIOU",[[1,2507,"\n"]],[2507,2507],[2508,2508]]],[1559891836264,["GJX@GJXAIOU",[[1,2508,"\n"]],[2508,2508],[2509,2509]]],[1559891839453,["GJX@GJXAIOU",[[1,2509,"**"],[1,2514,"**"]],[2509,2514],[2509,2518]]],[1559891841599,["GJX@GJXAIOU",[[1,2520,"- "]],[2520,2520],[2522,2522]]],[1559891843711,["GJX@GJXAIOU",[[1,2631,"- "]],[2631,2631],[2633,2633]]],[1559891846517,["GJX@GJXAIOU",[[-1,2640,"(1)O"]],[2643,2643],[2639,2639]]],[1559891849761,["GJX@GJXAIOU",[[-1,2529,"(n + m)O"]],[2536,2536],[2528,2528]]],[1559892260109,["GJX@GJXAIOU",[[1,1758,"![合并两个有序链表]($resource/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.gif)"]],[1758,1758],[1858,1858]]],[1559894659570,["GJX@GJXAIOU",[[1,66,"\n"]],[65,65],[66,66]]],[1559894662533,["GJX@GJXAIOU",[[1,55," "]],[55,55],[56,56]]]],null,"GJX@GJXAIOU"],["13ce58ae-a77e-4b3c-a92a-3855bea7c5dd",1560058618367,"---\ntags: \n  - 线性表\n  - 单链表\n  - 链表合并\n\nflag: green\n\ndata: '2019-6-7'\n\n---\n\n\n\n# 7.合并两个有序链表\n\n\n## 一、题目\n\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n示例：\n\n输入：`1->2->4, 1->3->4`\n输出：`1->1->2->3->4->4`\n\n\n\n\n\n\n## 二、解答\n\n**方法 1：递归**\n**想法**\n\n我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：\n\n$\\left\\{ \\begin{array}{ll} list1[0] + merge(list1[1:], list2) & list1[0] < list2[0] \\\\ list2[0] + merge(list1, list2[1:]) & otherwise \\end{array} \\right.$\n也就是说，两个链表头部较小的一个与剩下元素的 `merge` 操作结果合并。\n\n**算法** \n我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 `l1` 或者 `l2` 一开始就是 `null` ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 `l1` 和 `l2` 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：`O(n + m)`。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 `mergeTwoList `中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。\n\n- 空间复杂度：`O(n+m)`。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + m个栈帧会消耗 O(n + m) 的空间。\n\n\n\n\n\n**方法 2：迭代**\n\n**想法**\n\n我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。\n\n**算法**\n\n首先，我们设定一个哨兵节点 \"prehead\" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。\n\n在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。\n\n\n![合并两个有序链表]($resource/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.gif)\n\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        ListNode prehead = new ListNode(-1);\n\n        ListNode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n\n        return prehead.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。\n\n- 空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n- 个人解法\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode rspHead = new ListNode(0);\n        ListNode rsp = rspHead;\n\n        while(l1 != null && l2 != null){\n        \tif (l1.val < l2.val) {\n        \t\trspHead.next = l1;\n        \t\tl1 = l1.next;\n        \t}else{\n        \t\trspHead.next = l2;\n        \t\tl2 = l2.next;\n        \t}\n        \trspHead = rspHead.next;\n\n        }\n        \n        //当l1为空的况就是，l1链表中最后一个元素是小于l2中最后一个元素，\n        //所以当l1取完之后，实际上l2还剩下最后一个元素，因此指向l2\n        if (l1 == null) {\n        \trspHead.next = l2;\n        }else{\n        \trspHead.next = l1;\n        }\n\n        return rsp.next;\n    }\n}\n\n```\n",[[1560058579525,["GJX@GJXAIOU",[[1,11,"\n"]],[10,10],[11,11]]],[1560058586472,["GJX@GJXAIOU",[[1,11,"-   简单"]],[11,11],[17,17]]],[1560058590968,["GJX@GJXAIOU",[[1,11," "]],[11,11],[12,12]]],[1560058592925,["GJX@GJXAIOU",[[-1,15," "]],[16,16],[15,15]]],[1560058595020,["GJX@GJXAIOU",[[1,12," "]],[12,12],[13,13]]]],null,"GJX@GJXAIOU"],["7c9edc90-ae2e-45cd-91ab-503f4ccfa62c",1560157473923,"---\ntags: \n  -  简单\n  - 线性表\n  - 单链表\n  - 链表合并\n\nflag: green\n\ndata: '2019-6-7'\n\n---\n\n\n\n# 7.合并两个有序链表\n\n\n## 一、题目\n\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n示例：\n\n输入：`1->2->4, 1->3->4`\n输出：`1->1->2->3->4->4`\n\n\n\n\n\n\n## 二、解答\n\n**方法 1：递归**\n**想法**\n\n我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：\n\n$\\left\\{ \\begin{array}{ll} list1[0] + merge(list1[1:], list2) & list1[0] < list2[0] \\\\ list2[0] + merge(list1, list2[1:]) & otherwise \\end{array} \\right.$\n也就是说，两个链表头部较小的一个与剩下元素的 `merge` 操作结果合并。\n\n**算法** \n我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 `l1` 或者 `l2` 一开始就是 `null` ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 `l1` 和 `l2` 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：`O(n + m)`。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 `mergeTwoList `中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。\n\n- 空间复杂度：`O(n+m)`。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + m个栈帧会消耗 O(n + m) 的空间。\n\n\n\n\n\n**方法 2：迭代**\n\n**想法**\n\n我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。\n\n**算法**\n\n首先，我们设定一个哨兵节点 \"prehead\" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。\n\n在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。\n\n\n![合并两个有序链表]($resource/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.gif)\n\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        ListNode prehead = new ListNode(-1);\n\n        ListNode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n\n        return prehead.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。\n\n- 空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n- 个人解法\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode rspHead = new ListNode(0);\n        ListNode rsp = rspHead;\n\n        while(l1 != null && l2 != null){\n        \tif (l1.val < l2.val) {\n        \t\trspHead.next = l1;\n        \t\tl1 = l1.next;\n        \t}else{\n        \t\trspHead.next = l2;\n        \t\tl2 = l2.next;\n        \t}\n        \trspHead = rspHead.next;\n\n        }\n        \n        //当l1为空的况就是，l1链表中最后一个元素是小于l2中最后一个元素，\n        //所以当l1取完之后，实际上l2还剩下最后一个元素，因此指向l2\n        if (l1 == null) {\n        \trspHead.next = l2;\n        }else{\n        \trspHead.next = l1;\n        }\n\n        return rsp.next;\n    }\n}\n\n```\n",[[1560157455916,["GJX@GJXAIOU",[[-1,85,"7"]],[86,86],[85,85]]],[1560157456339,["GJX@GJXAIOU",[[1,85,"21"]],[85,85],[87,87]]]],null,"GJX@GJXAIOU"],["f3db84b5-2038-41e9-bb05-2ff0403d2681",1561422407218,"---\ntags: \n  -  简单\n  - 线性表\n  - 单链表\n  - 链表合并\n\nflag: green\n\ndata: '2019-6-7'\n\n---\n\n\n\n# 21.合并两个有序链表\n\n\n## 一、题目\n\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n示例：\n\n输入：`1->2->4, 1->3->4`\n输出：`1->1->2->3->4->4`\n\n\n\n\n\n\n## 二、解答\n\n**方法 1：递归**\n**想法**\n\n我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：\n\n$\\left\\{ \\begin{array}{ll} list1[0] + merge(list1[1:], list2) & list1[0] < list2[0] \\\\ list2[0] + merge(list1, list2[1:]) & otherwise \\end{array} \\right.$\n也就是说，两个链表头部较小的一个与剩下元素的 `merge` 操作结果合并。\n\n**算法** \n我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 `l1` 或者 `l2` 一开始就是 `null` ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 `l1` 和 `l2` 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：`O(n + m)`。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 `mergeTwoList `中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。\n\n- 空间复杂度：`O(n+m)`。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n + m个栈帧会消耗 O(n + m) 的空间。\n\n\n\n\n\n**方法 2：迭代**\n\n**想法**\n\n我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。\n\n**算法**\n\n首先，我们设定一个哨兵节点 \"prehead\" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。\n\n在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。\n\n\n![合并两个有序链表]($resource/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.gif)\n\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        ListNode prehead = new ListNode(-1);\n\n        ListNode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n\n        return prehead.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。\n\n- 空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/two-sum/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n\n\n\n\n\n\n- 个人解法\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode rspHead = new ListNode(0);\n        ListNode rsp = rspHead;\n\n        while(l1 != null && l2 != null){\n        \tif (l1.val < l2.val) {\n        \t\trspHead.next = l1;\n        \t\tl1 = l1.next;\n        \t}else{\n        \t\trspHead.next = l2;\n        \t\tl2 = l2.next;\n        \t}\n        \trspHead = rspHead.next;\n\n        }\n        \n        //当l1为空的况就是，l1链表中最后一个元素是小于l2中最后一个元素，\n        //所以当l1取完之后，实际上l2还剩下最后一个元素，因此指向l2\n        if (l1 == null) {\n        \trspHead.next = l2;\n        }else{\n        \trspHead.next = l1;\n        }\n\n        return rsp.next;\n    }\n}\n\n```\n",[[1561422397658,["GJX@GJXAIOU",[[1,57,"style: summer"]],[57,57],[70,70]]],[1561422399781,["GJX@GJXAIOU",[[-1,74,"a"]],[75,75],[74,74]]],[1561422400567,["GJX@GJXAIOU",[[1,74,"e"]],[74,74],[75,75]]],[1561422928350,["GJX@GJXAIOU",[[1,21,"\n  "]],[18,18],[21,21]]],[1561422930625,["GJX@GJXAIOU",[[1,21,"- 完成"]],[21,21],[25,25]]],[1561422930912,["GJX@GJXAIOU",[[1,28,"\n  "]],[25,25],[28,28]]],[1561422933729,["GJX@GJXAIOU",[[1,28,"- 数组"]],[28,28],[32,32]]],[1561422946981,["GJX@GJXAIOU",[[-1,28,"- 数组"]],[32,32],[28,28]]],[1561422947574,["GJX@GJXAIOU",[[-1,26,"  "]],[28,28],[26,26]]],[1561422947988,["GJX@GJXAIOU",[[-1,26,"\n"]],[26,26],[25,25]]]],null,"GJX@GJXAIOU"]]}