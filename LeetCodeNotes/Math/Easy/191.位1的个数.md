---
layout:     post
title:      191.位 1 的个数
subtitle:   Math.easy
date:       2020-02-04
author:     GJXAIOU
header-img: img/post-bg-leetcode.png
catalog: true
tags:
    - 数学
	- 位运算	
	- 完成
---

# 191.位 1 的个数

## 一、题目

编写一个函数，输入是一个**无符号整数**，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

- 示例 1：

> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

- 示例 2：

> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

- 示例 3：

> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。



- 提示：
    - 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
    - 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

- 进阶:
    如果多次调用这个函数，你将如何优化你的算法？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/number-of-1-bits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 二、解答

**方法 1：循环和位移动**
算法

这个方法比较直接。我们遍历数字的 32 位。如果某一位是 1 ，将计数器加一。

我们使用 位掩码 来检查数字的第 $i^{th}$位。一开始，掩码 m=1 因为 1 的二进制表示是
0000 0000 0000 0000 0000 0000 0000 0001

显然，任何数字跟掩码 1 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。
0000 0000 0000 0000 0000 0000 0000 0010

并重复此过程。

```java
package math.easy;

/**
 * @Author GJXAIOU
 * @Date 2020/2/4 11:16
 */
public class LeetCode191 {
    public int hammingWeight(int n) {
        int count = 0;
        int mask = 1;
        for (int i = 0; i < 32; i++) {
            if ((n & mask) != 0) {
                count++;
            }
            mask <<= 1;
        }
        return count;
    }
}
```

- 复杂度分析
    - 时间复杂度：O(1) 。运行时间依赖于数字 n 的位数。由于这题中 n 是一个 32 位数，所以运行时间是 O(1) 的。
    - 空间复杂度：O(1)。没有使用额外空间。



**方法 2：位操作的小技巧**
算法

我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候，我们就知道它没有 1 的位了，此时返回答案。

这里关键的想法是对于任意数字 n ，将 n 和 n−1 做与运算，会把最后一个 1 的位变成 0 。为什么？考虑 n 和 n - 1 的二进制表示。

<img src="191.%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0.resource/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png" alt="image.png" style="zoom:50%;" />

图片 1. 将 n 和 n−1 做与运算会将最低位的 1 变成 0

在二进制表示中，数字 n 中最低位的 1 总是对应 n−1 中的 0 。因此，将 n 和 n−1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。

使用这个小技巧，代码变得非常简单。

```java
public int hammingWeight(int n) {
    int sum = 0;
    while (n != 0) {
        sum++;
        n &= (n - 1);
    }
    return sum;
}
```

- 复杂度分析
    - 时间复杂度：O(1) 。运行时间与 n 中位为 1 的有关。在最坏情况下， n 中所有位都是 1 。对于 32 位整数，运行时间是 O(1) 的。
    - 空间复杂度：O(1) 。没有使用额外空间。



## ==特殊：如果输入为 Double==

double 不能使用 `>>`

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long inputValue = sc.nextLong();
        int mask = 1;
        int count = 0;
        for (int i = 0; i < 64; i++) {
            if ((inputValue & mask) != 0) {
                count++;
            }
            mask <<= 1;
        }
        System.out.println(count);
    }

    // 方法二：
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long inputValue = sc.nextLong();
        int res = 0;
        // 注意 & 只能 Int 或者 long，double 不能用
        while (inputValue != 0) {
            inputValue = inputValue & (inputValue - 1);
            res++;
        }
        System.out.println(res);

    }

    // 方法三：
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long inputValue = sc.nextLong();
        // 方法二：调用 API
        int resNum = 0;
        // 只有 long 有这个方法
        String resString = Long.toBinaryString(inputValue);
        for (int i = 0; i < resString.length(); i++) {
            if (resString.charAt(i) == '1') {
                resNum++;
            }
        }
        System.out.println(resNum);
    }
}
```