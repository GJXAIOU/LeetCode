---
layout:     post
title:      69.x 的平方根
subtitle:   Math.easy
date:       2020-02-05
author:     GJXAIOU
header-img: img/post-bg-leetcode.png
catalog: true
tags:
    - 数学
    - 二分查找
	- 完成
---

# 69.x 的平方根

## 一、题目

实现 `int  sqrt(int x)` 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

- 示例 1:

> 输入: 4
> 输出: 2

- 示例 2:

> 输入: 8
> 输出: 2

说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sqrtx
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 二、解答

**方法一：二分法**
思路分析：就类似于“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。

**一个数的平方根最多不会超过它的一半**，例如 8 的平方根，8 的一半是 4，4^2=16>84 ，如果这个数越大越是如此，通过解如下不等式或者这个结论的边界：

$\left(\cfrac{a}{2}\right)^2 \ge a$


意即：如果一个数的一半的平方大于它自己，那么这个数的取值范围。解以上不等式得 $a \ge 4$ 或者 $a \le 0$。

于是边界值就是 4，那么对 0、1、2、3 分别计算结果，得这 4 个数的平方根依次是 0、1、1、1。

参考代码 1：所有的数都放在一起考虑，为了照顾到 0 把左边界设置为 0，为了照顾到 1 把右边界设置为 `x / 2 + 1`。

```java
package math.easy;

/**
 * @Author GJXAIOU
 * @Date 2020/2/5 11:50
 */
public class LeetCode69 {
    public int mySqrt(int x) {
        // 为了照顾到 0 把左边界设置为 0
        long left = 0;
        // # 为了照顾到 1 把右边界设置为 x / 2 + 1
        long right = x / 2 + 1;
        while (left < right) {
            // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环
            long mid = (left + right + 1) >>> 1;
            long square = mid * mid;
            if (square > x) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        // 因为一定存在，因此无需后处理
        return (int) left;
    }
}
```

复杂度分析：
- 时间复杂度：O(logN)，二分法的时间复杂度是对数级别的。

- 空间复杂度：O(1)，使用了常数个数的辅助空间用于存储和比较。

    

**方法二：牛顿法**
使用牛顿法可以得到一个正实数的算术平方根，因为题目中说“结果只保留整数部分”，因此，我们把使用牛顿法得到的浮点数转换为整数即可。

这里给出牛顿法的思想：

> 在迭代过程中，以直线代替曲线，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 xx 轴的交点，重复这个过程直到收敛。

![image.png](https://pic.leetcode-cn.com/e6550b4a77fbe722a9a4634619ece70e8b7e60ef7eb2e5b7af7bba3037308879-file_1563817671864)

说明：

2、@LOAFER 的题解[《牛顿迭代法》](https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/) 的图和文字说明更好，见下面。

![image.png](https://pic.leetcode-cn.com/36b76d291e8c934a5f1826f52f9f4f8b20c47e301e7c408123a43486a8c4e3dc-image.png)

注意：**牛顿法得到的是平方根的浮点型精确值**（可能会有一定误差），根据题目中的要求，把最后得到的这个数转换为 int 型，即去掉小数部分即可。

对“牛顿法”感兴趣的朋友们可以查一下牛顿法的应用：一个是求方程的根，另一个是求解最优化问题，在这里就不展开了。

参考代码 4：

```java
public class Solution {

    public int mySqrt(int a) {
        long x = a;
        while (x * x > a) {
            x = (x + a / x) / 2;
        }
        return (int) x;
    }
}
```

说明：1e-6 是科学计数法，表示 1 乘以 10 的负 6 次方，也就是 0.000001。有的地方使用 epsilon（$\epsilon$）表示 1e-6 ，用来抵消浮点运算中因为误差造成的相等无法判断的情况，它通常是一个非常小的数字，具体多小要根据你的精度需求来设置。

- 复杂度分析：
    - 时间复杂度：（待讨论）。
    - 空间复杂度：O(1)，使用了常数个数的辅助空间用于存储和比较。

**总结一下**，如果使用牛顿法，初值应该选择一个正数，否则会得到负数的那个平方根，不符合题目要求，这一点在我手写的那个笔记中有用红色标注。

另外牛顿法是求解方程的根近似解的方法，所以当然可以用于求解 x^2 = a（a 是正数），它的思想是以直线代替曲线，直线方程求解无非就是加减乘除，好算。研究机器学习、深度学习的朋友，可能有必要了解一下牛顿法。

如果面试遇到这道题，应该首先回答二分法，这是程序员的思路，然后回答牛顿法，能推导一下公式当然是最好的啦。个人建议，仅供参考。





这题的解法用暴力解法是非常简单的。主要的麻烦在于如何解的更好，答案就是用牛顿迭代法。

下面这种方法可以很有效地求出根号 aa 的近似值：首先随便猜一个近似值 xx，然后不断令 xx 等于 xx 和 a/xa/x 的平均数，迭代个六七次后 xx 的值就已经相当精确了。

例如，我想求根号 22 等于多少。假如我猜测的结果为 44，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 22 了：

( 4 + 2/ 4 ) / 2 = 2.25

( 2.25 + 2/ 2.25 ) / 2 = 1.56944..

( 1.56944..+ 2/1.56944..) / 2 = 1.42189..

( 1.42189..+ 2/1.42189..) / 2 = 1.41423..

….



这种算法的原理很简单，我们仅仅是不断用 (x, f(x))(x,f(x)) 的切线来逼近方程 x^2-a=0x 
2
 −a=0 的根。根号 aa 实际上就是 x^2-a=0x 
2
 −a=0 的一个正实根，这个函数的导数是 2x2x。也就是说，函数上任一点 (x,f(x))(x,f(x)) 处的切线斜率是 2x2x。那么，x-f(x)/(2x)x−f(x)/(2x) 就是一个比 xx 更接近的近似值。代入 f(x)=x^2-af(x)=x 
2
 −a 得到 x-(x^2-a)/(2x)x−(x 
2
 −a)/(2x)，也就是 (x+a/x)/2(x+a/x)/2。

同样的方法可以用在其它的近似值计算中。Quake III 的源码中有一段非常牛B的开方取倒函数。

知道方程实现就非常简单了。

我用了递归

```java
class Solution {
    int s;
    
 public int mySqrt(int x) {
     s=x;
     if(x==0) return 0;
    return ((int)(sqrts(x)));
  }
    
    public double sqrts(double x){
      double res = (x + s / x) / 2;
    if (res == x) {
      return x;
    } else {
      return sqrts(res);
    }
    } 
}
```

