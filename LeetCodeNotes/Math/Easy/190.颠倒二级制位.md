---
layout:     post
title:      190.颠倒二进制位
subtitle:   Math.easy
date:       2020-02-04
author:     GJXAIOU
header-img: img/post-bg-leetcode.png
catalog: true
tags:
    - 数学
	- 位运算	
	- 完成
---



# 190.颠倒二进制位

## 一、题目

颠倒给定的 32 位无符号整数的二进制位。

- 示例 1：

> 输入: 00000010100101000001111010011100
> 输出: 00111001011110000010100101000000
> 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
>       因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

- 示例 2：

> 输入：11111111111111111111111111111101
> 输出：10111111111111111111111111111111
> 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
>       因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。

- 提示：
    - 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
    - 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

- 进阶:
    如果多次调用这个函数，你将如何优化你的算法？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-bits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 二、解答

**解法一**
用一个变量 res 去存储结果，依次得到要转换数字的低位，然后依次保存到 res 中。res 每得到一位后进行左移腾出位置保存下一位。举个具体的例子。

> 原数字 1011 ，res = 0
>
> res 左移一位，res = 0，
> 得到 1011 的最低位 1 加过来, res = 1
> 1011 右移一位变为 101
>
> res = 1 左移一位，res = 10，
> 得到 101 的最低位 1 加过来, res = 11
> 101 右移一位变为 10 
>    
> res = 11 左移一位，res = 110，
> 得到 10 的最低位 0 加过来, res = 110
> 10 右移一位变为 1 
>    
> res = 110 左移一位，res = 1100，
> 得到 1 的最低位 1 加过来, res = 1101
> 1 右移一位变为 0, 结束 



至于怎么得到最低位，和把最低位加过来，我们可以通过位操作完成。

```java
package math.easy;

/**
 * @Author GJXAIOU
 * @Date 2020/2/4 14:40
 */
public class LeetCode190 {

    public int reverseBits(int n) {
        int res = 0;
        int count = 0;
        while (count < 32) {
            // res 左移一位空出位置
            res <<= 1;
            // 得到的最低位加过来，因为 1 对应二进制为：00000...0001，所以 & 之后获得最后一位
            res |= (n & 1);
            // 原数字右移一位去掉已经处理过的最低位
            n >>= 1;
            count++;
        }
        return res;
    }
}

```



**方法二：**

**解题思路**
首先先看 ret | (((n>>(31-i)) & 1) << i) 中的 ((n>>(31-i)) & 1) 这一部分做了什么操作。

其实这部分所做的操作就是取出 n 的从右往左数的第 x 位的数。

PS：此处的 31 表示数值类型所占用的内存大小，即：sizeof(uint32_t) = 4 字节 = (4 * 8) 位 = 32 位，之所以为 31 是因为位移操作是从第一位开始的。

例如：假设 n = 1101（此处使用 4 位二进制进行演示）
当 i = 3 时，就有 ((n >> (3-3)) & 1) -> ((n >> 0) & 1 -> 1101 & 0001 = 0001
当 i = 2 时，就有 ((n >> (3-2)) & 1) -> ((n >> 1) & 1 -> 0110 & 0001 = 0000
当 i = 1 时，就有 ((n >> (3-1)) & 1) -> ((n >> 2) & 1 -> 0011 & 0001 = 0001
当 i = 0 时，就有 ((n >> (3-0)) & 1) -> ((n >> 3) & 1 -> 0001 & 0001 = 0001

从上面的例子就可以很清晰的验证我们的想法（其实这部分所做的操作就是取出 n 的从右往左数的第 x 位的数）

接下来再看 ret | (((n>>(31-i)) & 1) << i) 中的 << i 这一部分的操作，从上面的分析中我们已知 ((n>>(31-i)) & 1) 就是取 n 的第 31 - i 位，即从右往左按顺序取出。

然后再执行 <<i，即表示：将取到的 n 的第 31 - i 位上的数向左位置 i 位，且 i 是从最高位往下最低位走的。

因此，(((n>>(31-i)) & 1) << i) 所做的操作就是 ((从最低位往最高位取出 n 对应位上的值) << 将取到的值从最高位往最低位偏移)，其实就是将 n 的第 31 -i 位颠倒，还是用例子演示。

例如：假设 n = 1101（此处使用 4 位二进制进行演示）
当 i = 3 时，就有 ((n >> (3-3)) & 1) = 0001，然后再进行 0001 << i -> 0001 << 3 = 1000
当 i = 2 时，就有 ((n >> (3-2)) & 1) = 0000，然后再进行 0000 << i -> 0000 << 2 = 0000
当 i = 1 时，就有 ((n >> (3-1)) & 1) = 0001，然后再进行 0001 << i -> 0001 << 1 = 0010
当 i = 0 时，就有 ((n >> (3-0)) & 1) = 0001，然后再进行 0001 << i -> 0001 << 0 = 0001

最后就是 ret | (((n>>(31-i)) & 1) << i) 中的 ret | 这一部分做的操作，从上面的分析中可以知道 (((n>>(31-i)) & 1) << i) 的操作就是将 n 的第 31 - i 位颠倒，然后再 ret |，其实就是设置 ret 的第 n 位二进制数。

例如：假设 n = 1101（此处使用 4 位二进制进行演示）
当 i = 3 时，就有 ((n >> (3-3)) & 1 << 3) = 1000，然后再进行 ret | 1000 -> 0000 | 1000 = 1000
当 i = 2 时，就有 ((n >> (3-2)) & 1 << 2) = 0000，然后再进行 ret | 0000 -> 1000 | 0000 = 1000
当 i = 1 时，就有 ((n >> (3-1)) & 1 << 1) = 0010，然后再进行 ret | 0010 -> 1000 | 0010 = 1010
当 i = 0 时，就有 ((n >> (3-0)) & 1 << 0) = 0001，然后再进行 ret | 0001 -> 1010 | 0001 = 1011

最终 n(1101) -> ret(1011)。

关于位操作的更多原理和实践内容，可以参考一下我写的一篇文章：位操作奇技淫巧之原理加实践

```java
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ret = 0;
        for(int i = 31; i >= 0; i--) {
            ret = ret | (((n>>(31-i)) & 1) << i);
        }

        return ret;
    }
};
```

